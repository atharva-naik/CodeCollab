{
    "Movie streaming service dataset": {
        "16bc75e33edbc348401f0231489762b5197294504195b20410193cf4d9a0cc78": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    # pass\n\n    binary = X !=0\n\n    um = user_means.reshape((len(user_means),-1))\n\n    return um + W@ ((X - um)*binary) / ((W@binary)+eps)",
            "diff_index": 45,
            "id": 211,
            "person_id": "16bc75e33edbc348401f0231489762b5197294504195b20410193cf4d9a0cc78",
            "submission_id": "97c9e5c2d5c3e600e739b2cfb5b863ba35ed14bf61962d15ee2f051778b9da83",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-f7hadvl2",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:fd4c57a0-d1a3-45e3-8d3a-1d43bcbbb241",
            "event_time": "2023-02-07 16:00:58",
            "module_date_to_activate": "2023-02-05 05:01:00",
            "module_date_to_submit": "2023-02-19 04:59:59",
            "score_obtained": "90.0"
        },
        "b29de73eb4903b487679e2c2831a24bfff7f46fa965b50f997e59e69fd6c070b": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    X_normalized = X-user_means.reshape(-1,1)\n\n    X_mask = np.where(X>0, 1,0)\n\n    num = W.dot(X_normalized*X_mask)\n\n    W_non_zero = W.dot(X_mask)\n\n    term = num / (eps + W_non_zero)\n\n    return user_means.reshape(-1,1) + term",
            "diff_index": 45,
            "id": 281,
            "person_id": "b29de73eb4903b487679e2c2831a24bfff7f46fa965b50f997e59e69fd6c070b",
            "submission_id": "dbe8280af4e16eae0e75d05ec260c089dd3c3146c0ac5917911beeab40956145",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-f7hadvl2",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:c836de51-922c-44cf-885b-eeb635b8c6b7",
            "event_time": "2023-02-18 19:26:31",
            "module_date_to_activate": "2023-02-05 05:01:00",
            "module_date_to_submit": "2023-02-19 04:59:59",
            "score_obtained": "80.0"
        },
        "0d5c28b308339548b6dcbf0c31ba645fa31fcdbf173c1ea584b7c65d72d77ba4": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    numerator = (W.dot((X != 0) * (X - user_means.reshape(-1, 1))))\n\n    denominator = eps + np.abs(W).dot((X != 0))\n\n    return user_means.reshape(-1, 1) + numerator / denominator",
            "diff_index": 45,
            "id": 283,
            "person_id": "0d5c28b308339548b6dcbf0c31ba645fa31fcdbf173c1ea584b7c65d72d77ba4",
            "submission_id": "850218e31a9d441b30d75d7ecd79d2eae7f221a244d90f0553bafcb0d8ed2513",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-f7hadvl2",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:fc30afb5-0b56-4aa1-894e-277d31eba517",
            "event_time": "2023-02-18 20:17:07",
            "module_date_to_activate": "2023-02-05 05:01:00",
            "module_date_to_submit": "2023-02-19 04:59:59",
            "score_obtained": "75.0"
        },
        "7e56eade081fe976526b47d4ddcebb2ed913be568de4cc51522d0c177b56c978": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 225,
            "person_id": "7e56eade081fe976526b47d4ddcebb2ed913be568de4cc51522d0c177b56c978",
            "submission_id": "97a8b91e9f433c15a526f1aef2faab209e11ffe47a68cca37b083e91f4fd9d08",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-f7hadvl2",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:d11c748e-e3ef-421f-a220-d9a68a5b9c57",
            "event_time": "2023-02-11 14:50:05",
            "module_date_to_activate": "2023-02-05 05:01:00",
            "module_date_to_submit": "2023-02-19 04:59:59",
            "score_obtained": "0.0"
        },
        "85b6c5d3712a109e5a69d2ac284c702bc93646b2809b48fdf36887129fc306a0": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    mask = X != 0\n\n    numerator_non_zero = np.dot(W, np.multiply(mask, X - user_means[:, np.newaxis]))\n\n    denominator_non_zero = np.dot(np.abs(W), mask) + eps\n\n    new_X_non_zero = (numerator_non_zero / denominator_non_zero) + user_means[:, np.newaxis]\n\n\n\n    return new_X_non_zero\n",
            "diff_index": 45,
            "id": 277,
            "person_id": "85b6c5d3712a109e5a69d2ac284c702bc93646b2809b48fdf36887129fc306a0",
            "submission_id": "3bc89847bc0afa25dd591416b3e5f1df7dea698b2cbad8c7eed23d4ad93c409e",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-f7hadvl2",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:d48c2a48-ae85-4158-b8d5-575f77942fc1",
            "event_time": "2023-02-18 07:02:43",
            "module_date_to_activate": "2023-02-05 05:01:00",
            "module_date_to_submit": "2023-02-19 04:59:59",
            "score_obtained": "90.0"
        },
        "27ce4ca0fedbf2eed93fa81ebf40c77a05500fd4addd7365689671548e55d247": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    X_bin = X != 0\n\n    num = W @ (X_bin * (X - user_means.reshape(-1, 1)))\n\n    den = eps + abs(W) @ X_bin \n\n    return user_means.reshape(-1, 1) + num/den",
            "diff_index": 45,
            "id": 220,
            "person_id": "27ce4ca0fedbf2eed93fa81ebf40c77a05500fd4addd7365689671548e55d247",
            "submission_id": "b06117c07d1bc0e36015d98f92fecfc1b034adda55a9bb0ec9bfc6572041d259",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-f7hadvl2",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:e236369b-cf13-4573-a119-d3dc974e1b32",
            "event_time": "2023-02-09 19:44:06",
            "module_date_to_activate": "2023-02-05 05:01:00",
            "module_date_to_submit": "2023-02-19 04:59:59",
            "score_obtained": "75.0"
        },
        "f0229913be5ca8841bf71d4492c0b1f6b36b35ea4d9eab77c1ca079bc8fc219a": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    rated = np.array(X != 0, dtype=int)\n\n    numerator = np.dot(W, rated * (X - user_means[:, np.newaxis]))\n\n    denominator = np.dot(np.abs(W), rated) + eps\n\n    X_pred = user_means[:, np.newaxis] + (numerator / denominator)\n\n    \n\n    return X_pred",
            "diff_index": 45,
            "id": 270,
            "person_id": "f0229913be5ca8841bf71d4492c0b1f6b36b35ea4d9eab77c1ca079bc8fc219a",
            "submission_id": "a2a91f532f978146cdd0dede1e3ce568e8bc735a8f1bd501d7b593ef690de3b5",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-f7hadvl2",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:c5ec843b-8444-47a8-83a3-664aecc8e670",
            "event_time": "2023-02-17 22:14:39",
            "module_date_to_activate": "2023-02-05 05:01:00",
            "module_date_to_submit": "2023-02-19 04:59:59",
            "score_obtained": "65.0"
        },
        "0c2a88db65f0d0d7b081994c940bef45c838764f369623b11803a13b679785d4": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n#working solution\n\n    #get number of users and movies\n\n    #num_users, num_movies = X.shape\n\n    dim = X.shape\n\n    num_users = dim[0]\n\n    num_movies = dim[1]\n\n    #print(user_means)\n\n    binary_matrix = np.array(X != 0, dtype=int)\n\n    #print(rated)\n\n    #broadcasting to 2D\n\n    meanx = np.broadcast_to(user_means.reshape(-1, 1), (num_users, num_movies))\n\n    #print(meanx)\n\n    numerator = np.dot(W, binary_matrix * (X - meanx))\n\n    denominator = eps + np.dot(W, binary_matrix)\n\n    #print(num)\n\n    #print(denom)\n\n    #print(meanx)\n\n    #print(num / denom)\n\n    Xpredicted = meanx + (numerator / denominator)\n\n    return Xpredicted\n\n    pass",
            "diff_index": 45,
            "id": 272,
            "person_id": "0c2a88db65f0d0d7b081994c940bef45c838764f369623b11803a13b679785d4",
            "submission_id": "57dcdb69ba1fdd022fb06e335e45f6ebb7673cc9a600e561cc1eb85a3f6faf0d",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-f7hadvl2",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:bc090681-4fd2-460f-a3b3-be75ee8e797c",
            "event_time": "2023-02-17 22:45:24",
            "module_date_to_activate": "2023-02-05 05:01:00",
            "module_date_to_submit": "2023-02-19 04:59:59",
            "score_obtained": "30.0"
        },
        "0a9441e8caa84325ce6dececee4b003fc1d2b94676347d8426caefc375784a48": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    temp = X - np.reshape(user_means, (user_means.shape[0], 1))\n\n    temp[X == 0] = 0\n\n    numer = np.matmul(W, temp)\n\n\n\n    d = np.zeros_like(X)\n\n    d[X > 0] = 1\n\n    denom = np.matmul(np.absolute(W), d)\n\n    denom += eps\n\n\n\n    return np.reshape(user_means, (user_means.shape[0], 1)) + (numer / denom)",
            "diff_index": 45,
            "id": 294,
            "person_id": "0a9441e8caa84325ce6dececee4b003fc1d2b94676347d8426caefc375784a48",
            "submission_id": "064444f7164ebcff2e96eed301c79b9148053ba5688855f43f466b815fe2008e",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-f7hadvl2",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:ed98621c-3816-4575-858a-f5dba2f8ec2b",
            "event_time": "2023-02-19 00:22:51",
            "module_date_to_activate": "2023-02-05 05:01:00",
            "module_date_to_submit": "2023-02-19 04:59:59",
            "score_obtained": "90.0"
        },
        "b477c1c79d053afa4062b01ac3c2520ed2d8146de6fec21b6ebd0ee6df404e81": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 245,
            "person_id": "b477c1c79d053afa4062b01ac3c2520ed2d8146de6fec21b6ebd0ee6df404e81",
            "submission_id": "dc3075d5d8a53d427cdc07c090c5969759e4e94f34a2d412276f6e41c44738e7",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-f7hadvl2",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:e84262ac-d0f3-45e4-913c-59cd7328549d",
            "event_time": "2023-02-15 21:03:48",
            "module_date_to_activate": "2023-02-05 05:01:00",
            "module_date_to_submit": "2023-02-19 04:59:59",
            "score_obtained": "35.0"
        },
        "db9bd564d9c335f9ff8ccdcb8558cc8ecf415a54de48e82b18de3c2c48505fb2": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    indicator = np.copy(X)\n\n    indicator[np.where(indicator!=0)] = 1 \n\n\n\n    # - x_k_mean\n\n    x_prediction = X - (np.reshape(user_means,(user_means.shape[0],1)))\n\n    x_prediction = np.matmul(W, np.multiply(x_prediction,indicator))\n\n    denoms=np.reciprocal((np.matmul(np.absolute(W),indicator) + eps))\n\n    x_prediction = np.multiply(x_prediction,denoms)\n\n    # + x_i_mean\n\n    x_prediction = x_prediction + np.reshape(user_means,(user_means.shape[0],1))\n\n\n\n    return x_prediction",
            "diff_index": 45,
            "id": 2372,
            "person_id": "db9bd564d9c335f9ff8ccdcb8558cc8ecf415a54de48e82b18de3c2c48505fb2",
            "submission_id": "3a5fd7366d414cbd2350741eb31462e54298d8853b911e19cffb2841036132fd",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:17b4d621-ca63-4ca5-8d53-0f839be42b24",
            "event_time": "2023-05-30 22:27:57",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "95.0"
        },
        "8c5cd3c00e335d2270df2c9749d34bac3cb55a1833b31f4d199924bbccfd610c": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    indicator_matrix = (X != 0).astype(np.int64) \n\n\n\n    deviations = X - user_means[:, np.newaxis]\n\n    deviations_conditional = deviations * indicator_matrix\n\n    numerator = np.dot(W, deviations_conditional)\n\n    \n\n    denominator = eps + np.dot(np.absolute(W), indicator_matrix)\n\n    \n\n    predictions = (numerator / denominator) + user_means[:, np.newaxis]\n\n    return predictions",
            "diff_index": 45,
            "id": 276,
            "person_id": "8c5cd3c00e335d2270df2c9749d34bac3cb55a1833b31f4d199924bbccfd610c",
            "submission_id": "1c67e7d98c52638757a82d89fa89a51aed43b5a2ef9b010c334396bbb7403d55",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-f7hadvl2",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:e8a87c12-fe77-4a05-aa2a-de87bee27989",
            "event_time": "2023-02-18 02:02:16",
            "module_date_to_activate": "2023-02-05 05:01:00",
            "module_date_to_submit": "2023-02-19 04:59:59",
            "score_obtained": "65.0"
        },
        "1e766457eb034a06ba8a2b65e5cc55c7ccbc3f51a05f50969ac44e74a2cd36db": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n#     x_new = np.copy(X)\n\n    \n\n#     count_r = 0\n\n#     for r in x_new:\n\n#         count_c = 0\n\n#         movie_mean = user_means[count_r]\n\n#         for c in r:\n\n#             if c == 0:\n\n#                 movie_col = x_new[:, count_c]\n\n#         count_r += 1\n\n    pass",
            "diff_index": 45,
            "id": 190,
            "person_id": "1e766457eb034a06ba8a2b65e5cc55c7ccbc3f51a05f50969ac44e74a2cd36db",
            "submission_id": "e76015698197195a0964cb61b3026361e88a1062415195a54471a7623451332c",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-f7hadvl2",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:831b7300-6c4f-4fcb-83af-64f12f309e05",
            "event_time": "2023-02-18 06:41:55",
            "module_date_to_activate": "2023-02-05 05:01:00",
            "module_date_to_submit": "2023-02-19 04:59:59",
            "score_obtained": "35.0"
        },
        "c9af2334b06388dbf4c60341c1d5d2dbb63077958e0c8190c3bc47d09d20e6dc": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    \n\n    binary_non_zero_matrix = np.where(X != 0, 1 ,0)\n\n\n\n    norm_rating_matrix = (X.T - user_means).T * binary_non_zero_matrix\n\n\n\n    numerator = np.dot(W, norm_rating_matrix)\n\n\n\n    denominator = eps + np.dot(np.abs(W), binary_non_zero_matrix)\n\n\n\n    return (user_means.reshape(-1, 1) + numerator / denominator)",
            "diff_index": 45,
            "id": 278,
            "person_id": "c9af2334b06388dbf4c60341c1d5d2dbb63077958e0c8190c3bc47d09d20e6dc",
            "submission_id": "a74baf5c73a5088f86d65f84b4ca74ee0492d5c3c2197ecfd37c4d207f9d6738",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-f7hadvl2",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:fd0d1c02-5aa4-40d3-a6d2-0fe098acdad7",
            "event_time": "2023-02-18 07:08:11",
            "module_date_to_activate": "2023-02-05 05:01:00",
            "module_date_to_submit": "2023-02-19 04:59:59",
            "score_obtained": "45.0"
        },
        "7ff340b71f15a2d45613f46e0b1cb7aa4d3a37d5aef9b40f30cf6d522f5b97e4": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    X_indicator = (X != 0).astype(int)    \n\n    X_masked = X_indicator * (X-user_means[:,np.newaxis])\n\n    numerator = W.dot(X_masked)\n\n    denominator = eps + (W.dot(X_indicator))\n\n    result = user_means[:, np.newaxis] + (numerator/denominator)\n\n    return result\n\n    \n\n\n\n\n\n    \n\n    \n\n\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass\n\n\n",
            "diff_index": 45,
            "id": 93,
            "person_id": "7ff340b71f15a2d45613f46e0b1cb7aa4d3a37d5aef9b40f30cf6d522f5b97e4",
            "submission_id": "f2e7a903ea6869f225216056c141c97b923bc494ff621eca01a636dce51f521a",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-f7hadvl2",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:2e768528-3a50-4863-afd1-fac0e939600e",
            "event_time": "2023-02-19 01:07:53",
            "module_date_to_activate": "2023-02-05 05:01:00",
            "module_date_to_submit": "2023-02-19 04:59:59",
            "score_obtained": "75.0"
        },
        "0f23cdf295d39ac98defc0ee761d7475cebf511054ef56163e1c38fb4b1cf126": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    x, y = X.shape\n\n    mean_ = np.tile(user_means, (y,1))\n\n    mean_matrix = X-mean_.T\n\n       \n\n    X_binary = X!=0\n\n    \n\n    X_binary_matrix = np.multiply(mean_matrix, X_binary)\n\n    numerator =W@X_binary_matrix\n\n    denominator = np.abs(W)@X_binary + eps\n\n    \n\n    matrix = np.divide(numerator, denominator) + mean_.T\n\n    \n\n    return matrix.astype('float64')   ",
            "diff_index": 45,
            "id": 298,
            "person_id": "0f23cdf295d39ac98defc0ee761d7475cebf511054ef56163e1c38fb4b1cf126",
            "submission_id": "9da70099ab415704f0a6fb3d8e8631942a672c2ade53fdb5675cfc33ad040c78",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-f7hadvl2",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:f34a2b2c-1ce5-4b74-8266-9a9c150716cd",
            "event_time": "2023-02-19 04:50:00",
            "module_date_to_activate": "2023-02-05 05:01:00",
            "module_date_to_submit": "2023-02-19 04:59:59",
            "score_obtained": "0.0"
        },
        "c8fbcf76871add9af022e28241c28a6e7510527f3f00303d3248727626301869": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n\n\n    bool_ind = X != 0\n\n    bool_ind = bool_ind.astype(int)\n\n\n\n    num = W @ ((bool_ind) * (X - user_means.reshape(-1,1) ))\n\n    den = eps + (abs(W) @ bool_ind)\n\n    pred_rat = user_means.reshape(-1,1) + (num/den)\n\n    return pred_rat\n\n    #pass\n",
            "diff_index": 45,
            "id": 299,
            "person_id": "c8fbcf76871add9af022e28241c28a6e7510527f3f00303d3248727626301869",
            "submission_id": "53f59506e40ad29546f2ca54415e28dd49d0c2f2bcd18a533c9f8b5b238d1b36",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-f7hadvl2",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:f59ea0e9-9952-4fe7-b21b-d7a275da150c",
            "event_time": "2023-02-19 23:57:40",
            "module_date_to_activate": "2023-02-05 05:01:00",
            "module_date_to_submit": "2023-02-19 04:59:59",
            "score_obtained": "70.0"
        },
        "ba14245dab5c8159e3a36631debe0b8940f314324a629e70785ca2efdc2e4796": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n\n\n    # binary matrix for ratings of a user\n\n    binary_x = np.array(X != 0, dtype=int)\n\n    pred =( W @ (binary_x * (X - user_means.reshape(-1, 1))) ) / (W.T @ binary_x + eps) + user_means.reshape(-1, 1)\n\n    \n\n                \n\n    return pred\n\n    \n",
            "diff_index": 45,
            "id": 300,
            "person_id": "ba14245dab5c8159e3a36631debe0b8940f314324a629e70785ca2efdc2e4796",
            "submission_id": "31d155398b1d6aa4c8d164a835f8e4f89bf1e4dba184f903a84466b44c6e4775",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-f7hadvl2",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:d957791a-f7d3-4d08-ab99-050c4558e51b",
            "event_time": "2023-02-20 21:53:03",
            "module_date_to_activate": "2023-02-05 05:01:00",
            "module_date_to_submit": "2023-02-19 04:59:59",
            "score_obtained": "90.0"
        },
        "180a619dfe5c6131d0912d3cf07a5c9e4b4d035ccc64d1d7e821b00698bb276b": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    binary_nonzero = (X > 0).astype(int)\n\n    # binary_zero = (X == 0).astype(int)\n\n\n\n    user_means_matrix = user_means.reshape((len(user_means),1))@np.ones((1,X.shape[1]))\n\n\n\n    numerator = ((((X-user_means_matrix)*binary_nonzero).T)@W).T\n\n    denominator = (binary_nonzero.T @ np.abs(W)).T + eps*np.ones(X.shape)\n\n    \n\n    # X+(user_means_matrix + numerator/denominator)*binary_zero\n\n    return user_means_matrix + numerator/denominator\n\n    pass",
            "diff_index": 45,
            "id": 153,
            "person_id": "180a619dfe5c6131d0912d3cf07a5c9e4b4d035ccc64d1d7e821b00698bb276b",
            "submission_id": "8b106449b425681cfa6bf96a3aeb5b7faa33eb5ec6e1f16f59e1183f28a18ef7",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-f7hadvl2",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:59e33334-8d9c-45ab-9de6-c145cf66b407",
            "event_time": "2023-02-15 05:06:35",
            "module_date_to_activate": "2023-02-05 05:01:00",
            "module_date_to_submit": "2023-02-19 04:59:59",
            "score_obtained": "75.0"
        },
        "24bd48f2d99580fa112c446b8f13466daea5acc54ee7c4451e20bda7d2a87d4b": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    # Approach used here, the major approach used is that multiplyinhg the binry matrix with X and mean respectively and then the dot product is done so as to \n\n    # match the shape and requirement of the question.\n\n    \n\n    # Convert the input matrix X to a binary matrix, with True where X is non-zero and False otherwise\n\n    binary_matrix=X.astype(bool)\n\n    # \u2211\ud835\udc5a\ud835\udc58=1\ud835\udfd9(\ud835\udc4b\ud835\udc58\ud835\udc57\u22600)W.\ud835\udc4b\ud835\udc58\ud835\udc57 (complete multiplication for the first term)\n\n    term_1=W.dot(X*binary_matrix)\n\n    # \u2211\ud835\udc5a\ud835\udc58=1\ud835\udfd9(\ud835\udc4b\ud835\udc58\ud835\udc57\u22600) W.\ud835\udc65\u00af\ud835\udc58 (complete multiplication for the second term)\n\n    term_2=W.dot(user_means[:, np.newaxis]*binary_matrix)\n\n     # denominator\n\n    absolute_w=eps+np.abs(W).dot(binary_matrix)\n\n    #final answer\n\n    final_answer=user_means[:, np.newaxis]+((term_1-term_2)/absolute_w)\n\n    return final_answer",
            "diff_index": 45,
            "id": 206,
            "person_id": "24bd48f2d99580fa112c446b8f13466daea5acc54ee7c4451e20bda7d2a87d4b",
            "submission_id": "1c26e3f64f2a24533e282e9fe6b85f04eea4d065f1bc22a43d0c9be33385793a",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-f7hadvl2",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:5e5e618f-c9ad-4b81-bb3f-c3a3bbcbd3c4",
            "event_time": "2023-02-19 04:18:23",
            "module_date_to_activate": "2023-02-05 05:01:00",
            "module_date_to_submit": "2023-02-19 04:59:59",
            "score_obtained": "90.0"
        },
        "31ead8de0288b587fd13539e47ab97183201ac499506962b6b3ed3cf30d5a853": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    filt = np.zeros(X.shape)\n\n    filt[X>0] = 1\n\n    Num = W @ (filt * (X - user_means.reshape(-1,1)))\n\n    Denom = np.abs(W) @ filt\n\n    result = user_means.reshape(-1,1) + Num/(Denom + eps)\n\n    \n\n    return result\n\n    pass",
            "diff_index": 45,
            "id": 288,
            "person_id": "31ead8de0288b587fd13539e47ab97183201ac499506962b6b3ed3cf30d5a853",
            "submission_id": "0d1529694c68e3226cf3a29b703918bb0a37721afae98664d08d4a4efabe17e6",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-f7hadvl2",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:f9448b49-588a-4188-b5ba-ff8662561614",
            "event_time": "2023-02-18 21:12:04",
            "module_date_to_activate": "2023-02-05 05:01:00",
            "module_date_to_submit": "2023-02-19 04:59:59",
            "score_obtained": "90.0"
        },
        "d6ff356b1314b42034b11f843492415ad8b04fb16c5ab9b11e76a9016280e462": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3407,
            "person_id": "d6ff356b1314b42034b11f843492415ad8b04fb16c5ab9b11e76a9016280e462",
            "submission_id": "998847438015d6c56ad65053a859415d3ec6b94fd774ed84865cbd58221b897c",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:fa37027a-cf73-4f93-935a-a783f871ffb5",
            "event_time": "2023-05-30 10:02:57",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "15.0"
        },
        "bb78b1c162b8d3094c9c534f7e9c1e38e9d6bf9ad17bf22099f59c1d3093fa37": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\n\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n\n\n- To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n- Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.\n",
            "answer": "def predict_user_user(X: np.array, W: np.array, user_means: np.array, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    user_means = user_means.reshape(-1, 1)\n\n    individual_diff = (X != 0) * (X - user_means)\n\n    numerator = W @ individual_diff\n\n    denominator = eps + np.abs(W @ (X != 0))\n\n    mean_score = numerator / denominator\n\n    return user_means + mean_score\n",
            "diff_index": 45,
            "id": 3420,
            "person_id": "bb78b1c162b8d3094c9c534f7e9c1e38e9d6bf9ad17bf22099f59c1d3093fa37",
            "submission_id": "30453eab7f99d2231b32dedb7a50a49b4fbe59dee46596f55183c375f5e28750",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:f4f5a0ec-03d0-48d8-8a9e-8e2f4a851057",
            "event_time": "2023-05-31 15:46:05",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "95.0"
        },
        "532d0da52f174ff17d007c0aa64d1d0bf90c5385d972548554fe7b42245c7891": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3408,
            "person_id": "532d0da52f174ff17d007c0aa64d1d0bf90c5385d972548554fe7b42245c7891",
            "submission_id": "5bf9102e3e7097d61664a09a96eb989fb9b41d00fa898b6cfa2606fd71bc5335",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:f9faefb4-b21d-447e-8d46-84466379b221",
            "event_time": "2023-05-30 17:11:42",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "0.0"
        },
        "431d3a8df9b3c144bd4fe89162220ef2cffb7804f6f40111b850afbe85062b56": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3409,
            "person_id": "431d3a8df9b3c144bd4fe89162220ef2cffb7804f6f40111b850afbe85062b56",
            "submission_id": "f9da4d6dc073555e08a424ff92c9b1e7ace4e70252f11999aa353d47007646d7",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:f4a12bf7-a7ce-4d86-9f6f-903b26a4f3f2",
            "event_time": "2023-05-30 17:13:39",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "15.0"
        },
        "bf314980fa0ae5e7e07c9dcf34eed5eb911ad78fd8b42ed81d821cb5747725d8": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3417,
            "person_id": "bf314980fa0ae5e7e07c9dcf34eed5eb911ad78fd8b42ed81d821cb5747725d8",
            "submission_id": "df44da8705156c44e635071056e82d5190c8b3369a8a0389dda46ad312482975",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:ea9b10f7-a89e-4555-ab7c-3354c6dfafb6",
            "event_time": "2023-05-31 08:14:45",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "10.0"
        },
        "9a8bf2d29d93e832e6059fda02be855f624a3701cdbeed6893b46a7b9f687dd2": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    rated_mask = np.where(X > 0, 1, 0)\n\n\n\n    user_means_matrix = user_means[:,None]\n\n\n\n    nom = (X - user_means_matrix) * rated_mask\n\n    nom = W.dot(nom)\n\n\n\n    denom = W.dot(rated_mask) + eps\n\n    \n\n    X_predicted = user_means_matrix + nom/denom\n\n\n\n    return X_predicted",
            "diff_index": 45,
            "id": 3425,
            "person_id": "9a8bf2d29d93e832e6059fda02be855f624a3701cdbeed6893b46a7b9f687dd2",
            "submission_id": "ecf3403e2e83879b2f5c8ceacff2ca9bb17d6b4fe8ce4ef901304b3af4f281f6",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:efc4a206-ba56-4c9f-90fe-553ba2c2214c",
            "event_time": "2023-06-01 09:20:30",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "75.0"
        },
        "f0add638f6b197f6d85ab03d3b343c471bae80f77fb5e959e02bc55d69c0b9bc": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3218,
            "person_id": "f0add638f6b197f6d85ab03d3b343c471bae80f77fb5e959e02bc55d69c0b9bc",
            "submission_id": "125c02a615fc59e77196544cfdad4edfdac8ad718b09a7df3a759888f80a62d9",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:cbc159fe-bc0e-46f7-ae83-55acc5fde37d",
            "event_time": "2023-06-01 13:41:16",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "35.0"
        },
        "b1d9a27b449675fefaa3bb00dfaac7779f4120dc959c4beafbe82d9cd82b27c6": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    mask = (X!=0)\n\n    dinomiator = eps + np.abs(W@mask)\n\n    numerator = W@((X-user_means.reshape(-1, 1))*mask)\n\n\n\n    return user_means.reshape(-1, 1) + numerator/dinomiator\n\n    \n\n    ",
            "diff_index": 45,
            "id": 3427,
            "person_id": "b1d9a27b449675fefaa3bb00dfaac7779f4120dc959c4beafbe82d9cd82b27c6",
            "submission_id": "0dc7a2c638b4e9875bfaac3b91305a86736f19ffa769300f6d3b48f9b879da0d",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:f8a1e1bf-cc26-4f14-9ae6-2590ad17fe3f",
            "event_time": "2023-06-01 14:34:40",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "85.0"
        },
        "93921947301e98a0db2a717b4c09d333257dadbc800e2a28a2baf8f83b34fbd3": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    user_means_reshape = user_means[:, None]\n\n    indicator_matrix = (X != 0).astype(int)\n\n    denorm = eps + abs(W) @ indicator_matrix\n\n    norm = W @ ((X - user_means_reshape) * indicator_matrix) \n\n    X_predicted = user_means_reshape + norm/denorm      \n\n    return X_predicted              \n\n    return X_predicted\n\n    pass",
            "diff_index": 45,
            "id": 3443,
            "person_id": "93921947301e98a0db2a717b4c09d333257dadbc800e2a28a2baf8f83b34fbd3",
            "submission_id": "f9dee9aa01a4cfddf7248923f477ba68864b3686118582e249e5ceb654be9693",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:fdf095f6-de5e-47f5-902f-0b46715a7f3a",
            "event_time": "2023-06-05 01:53:06",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "0.0"
        },
        "8673740ea1c42996565a5bfdf21af5b69e8d014adcea037867ee8e587d625575": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3428,
            "person_id": "8673740ea1c42996565a5bfdf21af5b69e8d014adcea037867ee8e587d625575",
            "submission_id": "ec5acbe75ff55752b41d6be2342a7ea69e0d52397e834935f5759bd4804fe534",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:f33c6378-d7ea-41ce-b875-57aef029c508",
            "event_time": "2023-06-01 22:21:11",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "15.0"
        },
        "d7954a735f3c35198e1d53b06469523b8c9bd5de31e54d772206044d6d749f4f": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3414,
            "person_id": "d7954a735f3c35198e1d53b06469523b8c9bd5de31e54d772206044d6d749f4f",
            "submission_id": "e5cfc5063e2ca54d467970ca3bf8e4aa72a6c56af3462524e96f3343ed2c899b",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:ef1b2aaa-9b88-4030-8a35-71e00663134f",
            "event_time": "2023-05-31 03:37:29",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "10.0"
        },
        "1213fd028aa0e4cd77d2d103b672135757e2e5ce4e8b9e031ce015163be92895": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3339,
            "person_id": "1213fd028aa0e4cd77d2d103b672135757e2e5ce4e8b9e031ce015163be92895",
            "submission_id": "757cdff2e95a34ffb545bda3e41267bd0e7e66c1a6e02be6ce1154c818cf2380",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:e2083431-6571-4fe5-b842-b3cf126cb6ba",
            "event_time": "2023-06-04 01:49:09",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "20.0"
        },
        "f0118d638717d451ee32c602e220cfa55cb921be249a75690ad2332630e70b34": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n\n\n    one_hot = np.zeros((X.shape[0],X.shape[1]))\n\n    rows = coo_matrix(X).row\n\n    cols = coo_matrix(X).col\n\n\n\n    one_hot[rows,cols] = 1\n\n    # print(one_hot)\n\n    # print(one_hot.T)\n\n\n\n    diff = X-user_means.reshape((-1,1))\n\n    # print(diff)\n\n    # print(diff*one_hot)\n\n    cond_sum = W@(diff*one_hot)\n\n    # print(cond_sum)\n\n\n\n    divide = np.absolute(W)@one_hot\n\n    # print(user_means.shape)\n\n    result =user_means.reshape((-1,1))+ cond_sum/(divide+eps)\n\n    \n\n\n\n    return result",
            "diff_index": 45,
            "id": 3438,
            "person_id": "f0118d638717d451ee32c602e220cfa55cb921be249a75690ad2332630e70b34",
            "submission_id": "c2ab0c52d5041c33de07d6b40079e253cc9d51cff9476cd131769b2d43e9aeec",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:e96e86d7-c355-4d7f-a8ed-3eb55ea38870",
            "event_time": "2023-06-04 09:24:32",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "75.0"
        },
        "f5d9bf79d2512460ca1ec79f48682c05c73494082f64897f1ddbeb0b048a750f": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3431,
            "person_id": "f5d9bf79d2512460ca1ec79f48682c05c73494082f64897f1ddbeb0b048a750f",
            "submission_id": "2869142398ca6cf8b5437b9b1aa12c2fecd09f992216cf3682b0c9556c14f2e0",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:ed617b86-5648-4f93-8802-f9510fe5462d",
            "event_time": "2023-06-02 12:48:16",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "20.0"
        },
        "58d4962e846c8754e3b0dc975e61d164ad45771252706ee87bc9275658bc323d": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3435,
            "person_id": "58d4962e846c8754e3b0dc975e61d164ad45771252706ee87bc9275658bc323d",
            "submission_id": "8db21f373620ff2e67317eb677b559a84f5d992f1c8ce13525b67ab15feddd40",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:fdab7ab0-faef-4ee1-9ff0-0b6b8ef16713",
            "event_time": "2023-06-03 17:04:29",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "35.0"
        },
        "ca9f84a987fe35943e20e74b898acecb263ff8a5b947566ec0700f3e3265275a": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    \n\n#     print(user_means.shape)\n\n#     print(user_means[None].shape)\n\n#     print(user_means[None].T.shape)\n\n\n\n#     print(X - user_means[None].T)\n\n   \n\n    numer = W @ ((X - user_means[None].T) * (X != 0))\n\n#     print(numer)\n\n    \n\n    denom = eps + np.dot(W, (X !=0))\n\n#     print(denom)\n\n    \n\n#     print(numer/denom[None].T)\n\n    return user_means[None].T + (numer / denom)\n\n\n\n#     pass\n\n\n\n# X = np.array([[0, 3], [0, 1], [2, 3]])\n\n# user_means = np.array([3, 1, 2.5]\n\n# W_user_cosine = cosine_similarity(X)\n\n# X_predicted = predict_user_user(X, W_user_cosine, user_means)\n\n# X_predicted",
            "diff_index": 45,
            "id": 3447,
            "person_id": "ca9f84a987fe35943e20e74b898acecb263ff8a5b947566ec0700f3e3265275a",
            "submission_id": "99132a14d464aee87b6823b6f27ccad6bd8da8a6c5c7edf62c2bb769adc98a68",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:f20f1575-e0b0-4e28-890f-049cb3b1c925",
            "event_time": "2023-06-05 11:20:17",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "55.0"
        },
        "8740f9d2f2c16780ca5b988d310c0fd42c1ecb3a8127d557f4418b9ce3fa1a8b": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3122,
            "person_id": "8740f9d2f2c16780ca5b988d310c0fd42c1ecb3a8127d557f4418b9ce3fa1a8b",
            "submission_id": "3b77856e14e9b60eefc301f6d9cfdfb8ec96e417d36e8b734848d998a413ccd4",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:b7a706ac-7926-4d87-b862-48d2dfbdadd2",
            "event_time": "2023-06-02 21:52:03",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "10.0"
        },
        "0b75117573e58bb174e5cc899006dee645208f3267855fe0ae47b03a7104d030": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    num_users, num_movies = X.shape\n\n    indicator_matrix = np.where(X != 0, 1, 0)\n\n    predicted_X = np.zeros((num_users, num_movies))\n\n\n\n    for i in range(num_users):\n\n        numerator = np.sum(indicator_matrix * W[i].reshape(-1, 1) * (X - user_means.reshape(-1, 1)), axis=0)\n\n        denominator = eps + np.sum(indicator_matrix * np.abs(W[i].reshape(-1, 1)), axis=0)\n\n        \n\n        predicted_X[i] = user_means[i] + numerator / denominator\n\n\n\n    return predicted_X",
            "diff_index": 45,
            "id": 3235,
            "person_id": "0b75117573e58bb174e5cc899006dee645208f3267855fe0ae47b03a7104d030",
            "submission_id": "5db162e218138fd11ec75eb8741175933d8a0f68b4821aedccdd75a3a570a6ca",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:c67ed857-a95f-4744-a35e-a099e717cd47",
            "event_time": "2023-06-04 02:09:16",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "95.0"
        },
        "65008cf17265ab6622032f7f3414976086557542bd51c0ff770f2ddfc936bb79": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3456,
            "person_id": "65008cf17265ab6622032f7f3414976086557542bd51c0ff770f2ddfc936bb79",
            "submission_id": "4b9dc82219609a1d7ed241ff5c454c301452147e2f333745a77744355c4d528c",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:eb755198-0faa-48e2-bdb8-cf79e99408c6",
            "event_time": "2023-06-06 15:45:53",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "40.0"
        },
        "bdc98b4dec8552d57441cf548036649735e816d78d5b54a928d7b61994ce9697": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    return np.array()",
            "diff_index": 45,
            "id": 3437,
            "person_id": "bdc98b4dec8552d57441cf548036649735e816d78d5b54a928d7b61994ce9697",
            "submission_id": "a9606faef8130d2d495c74f68d162c78f53e52d5cd821bdbc0c9090d6c923e90",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:eaa61818-6cc6-4b70-81bf-c2686df3ce6f",
            "event_time": "2023-06-04 04:08:15",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "25.0"
        },
        "f5c58761ed0a279bd9633d20ee74484fb85494e409d810b78fa83d39cc34d885": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    binary_matrix = np.where(X==0, 0, 1)\n\n    num = W @ ((X-user_means[:,None]) * binary_matrix)\n\n    den = (W @ binary_matrix) + eps\n\n    X_pred = (num/den)+user_means[:,None]\n\n\n\n    return X_pred",
            "diff_index": 45,
            "id": 3439,
            "person_id": "f5c58761ed0a279bd9633d20ee74484fb85494e409d810b78fa83d39cc34d885",
            "submission_id": "838c78e461c30828215504b1b354d69563ca5635c4ac6fa61833c1b3636002c3",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:f0b08d70-95aa-4faa-a7d0-f9eeeacefa15",
            "event_time": "2023-06-04 11:11:24",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "75.0"
        },
        "62edec51d5547fbf55edbf40900066b654259107a00d468c919db438baba82d4": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3348,
            "person_id": "62edec51d5547fbf55edbf40900066b654259107a00d468c919db438baba82d4",
            "submission_id": "8d77947060e560f3a534b91ed5d008942622c504a2944e7a92fb1dbd9ae9a3ae",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:d79caa3c-b982-4b54-ae72-a094b0f96d8f",
            "event_time": "2023-06-04 18:28:39",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "10.0"
        },
        "1ec62d57d2e3261032b1eff2546e5f220cdd1d82b814b8814184506b2a98d82e": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    # pass\n\n    indicator = (X > 0).astype(float)\n\n    diff = (X - user_means.reshape(-1, 1)) * indicator\n\n    numerator = W.dot(diff)\n\n    denominator = np.abs(W).dot(indicator) + eps\n\n    pred = user_means.reshape(-1, 1) + numerator / denominator\n\n    \n\n    return pred",
            "diff_index": 45,
            "id": 3448,
            "person_id": "1ec62d57d2e3261032b1eff2546e5f220cdd1d82b814b8814184506b2a98d82e",
            "submission_id": "3e542011dab84998639d1550a37c0a65f11378ecd8f1cd377a383005efc0257d",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:e997eee6-64e7-419a-8129-32486ccb93f8",
            "event_time": "2023-06-05 13:53:20",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "75.0"
        },
        "7604d84f9376ffbcd4327ea4d6d8b8e9791303f9c0c33ea6363405472590acd5": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    indicator_matrix = np.where(X != 0, 1, 0)\n\n    numerator = np.dot(W, indicator_matrix * (X - user_means[:, np.newaxis]))\n\n    denominator = eps + np.abs(W).dot(indicator_matrix)\n\n    X_predicted = user_means[:, np.newaxis] + numerator / denominator\n\n    print(X_predicted[0, 0:10])\n\n    return X_predicted\n\n    X_indicator = X.copy()\n\n    X_indicator[X_indicator > 0] = 1\n\n    m, n = X.shape\n\n    X_predicted = np.zeros((m, n))\n\n    for i in range(m):\n\n        for j in range(n):\n\n            numerator = X_indicator[:, j] * W[i, :] * (X[:, j] - user_means)\n\n            denominator = eps + X_indicator[:, j] * abs(W[i, :])\n\n            X_predicted[i][j] = user_means[i] + sum(numerator)/sum(denominator)\n\n\n\n    return X_predicted\n\n\n\n    pass",
            "diff_index": 45,
            "id": 3449,
            "person_id": "7604d84f9376ffbcd4327ea4d6d8b8e9791303f9c0c33ea6363405472590acd5",
            "submission_id": "a1eb7d06c47c8309d49aeaf898a37b4c5a18ad87428ef28bc115e051deff5cc9",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:ebf1bb4f-1eee-417c-b466-f5cf870bd38e",
            "event_time": "2023-06-05 15:46:33",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "55.0"
        },
        "eb132361504d91ef94cbcdf1c8d86426d9a1fc1b570377befcd33ae4656f6126": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    user_means = user_means[:,None]\n\n    \n\n    denominator = eps + np.abs(W)@(X>0)\n\n\n\n    numerator = X-user_means\n\n    numerator = numerator*(X>0)\n\n    numerator = W@numerator\n\n\n\n    ans = user_means + numerator/denominator\n\n    return ans\n\n    pass",
            "diff_index": 45,
            "id": 3159,
            "person_id": "eb132361504d91ef94cbcdf1c8d86426d9a1fc1b570377befcd33ae4656f6126",
            "submission_id": "530da25e4a3d6a45dc0d496a4baaaa50f0dbb1e30d076126e42a5e4d1868c42a",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:b4c6b9c9-5e3c-4f60-9ce2-6a24a0d3511a",
            "event_time": "2023-06-07 07:43:58",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "55.0"
        },
        "6f10071b8ad2b3f8d456a8f4ee963f654148c3c34f66c278a108e7672de1a6d7": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    mean_difference = (X.T - user_means).T * (X != 0).astype(int)\n\n    num = np.dot(mean_difference.T, W).T\n\n    den = (eps + np.dot(np.abs(W), (X != 0).astype(int)))\n\n    predicted_ratings = ((num / den).T + user_means).T\n\n\n\n    return predicted_ratings",
            "diff_index": 45,
            "id": 3463,
            "person_id": "6f10071b8ad2b3f8d456a8f4ee963f654148c3c34f66c278a108e7672de1a6d7",
            "submission_id": "41e10bc7be711bc9be13ed567c4eceee59dc8f88b948f2745ccb6089285dc6ce",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:f5de6f94-6f8c-4992-bbcb-efc8c91b3848",
            "event_time": "2023-06-07 22:16:11",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "90.0"
        },
        "99e9a35b1323991749a653ff7a995532505210a03c803cca11b7034f9e7ce599": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "from typing import AnyStr\n\ndef predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    n = W @ (X - user_means.reshape(-1,1) * (X != 0))\n\n    d = np.abs(W) @ (X != 0) + eps\n\n    predict = user_means.reshape(-1,1) + n/d\n\n    return predict\n\n    pass",
            "diff_index": 45,
            "id": 3180,
            "person_id": "99e9a35b1323991749a653ff7a995532505210a03c803cca11b7034f9e7ce599",
            "submission_id": "4ce4404fb2337403f162c7ee36918cba205be02b7e4aef87de5cb049f1b4ce4d",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:b8d90d7e-5761-47ee-8a33-a537b0e1d290",
            "event_time": "2023-06-10 00:02:56",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "0.0"
        },
        "d40142db22835ef2c018c7bfd40902b524a5a619a019730251afbe39b57aeca8": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    \n\n    pass",
            "diff_index": 45,
            "id": 3479,
            "person_id": "d40142db22835ef2c018c7bfd40902b524a5a619a019730251afbe39b57aeca8",
            "submission_id": "abebfd5dc3c6d6f78535901bb2e7314a4a3652d1011ff8ae874e536c2afc970a",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:f4ff7716-8f54-43be-9f04-a9a67c1ca88f",
            "event_time": "2023-06-10 03:11:35",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "45.0"
        },
        "374a5796f41694e25c8ad74fd00d9e02d5f1aa10f122c43e39bbd7f3e4021933": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    \n\n    mask = X>0\n\n    return user_means[:,None] + (W@((X - user_means[:,None])*mask))/(eps + np.abs(W)@mask)",
            "diff_index": 45,
            "id": 3488,
            "person_id": "374a5796f41694e25c8ad74fd00d9e02d5f1aa10f122c43e39bbd7f3e4021933",
            "submission_id": "c3ca41dfaf1cd6d33d9224b6f81b30d2e7c4b522061483ec53c7127acd4bb887",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:edb710e1-1109-4f44-8c64-5a5eee19e322",
            "event_time": "2023-06-11 12:06:48",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "95.0"
        },
        "e04e7139e4147492ddd932aefe527b2a7c04427e542ea5492c572acbaf2acb15": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    binary_mat = X != 0\n\n    user_means_col_vec = user_means[:, None]\n\n    nom = np.matmul(W, binary_mat * (X - user_means_col_vec)) \n\n    return user_means_col_vec + nom / (eps + np.matmul(np.abs(W), binary_mat))\n",
            "diff_index": 45,
            "id": 3473,
            "person_id": "e04e7139e4147492ddd932aefe527b2a7c04427e542ea5492c572acbaf2acb15",
            "submission_id": "b7e302561138cb1a52768c663bf02518b81b115a889deef427a6a9053e3be74d",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:ff37ffbf-3e77-4518-a0c8-38e55236e0e9",
            "event_time": "2023-06-09 08:32:11",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "95.0"
        },
        "fd29b2f257538e5acd2751ff7511cb58cac275011a1aaa98ab1e090fadf1eb66": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n\n\n    user_means = user_means[:, np.newaxis]\n\n    # Skip when X_ij = 0\n\n    mask = X != 0\n\n    return user_means + (W @ ((X - user_means) * mask) / (eps + np.abs(W) @ mask)) ",
            "diff_index": 45,
            "id": 3481,
            "person_id": "fd29b2f257538e5acd2751ff7511cb58cac275011a1aaa98ab1e090fadf1eb66",
            "submission_id": "fd7b03cd205f9e1b96f5f891d08ab1f3494bf758fa12ed11418f2f056e4be87e",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:f2415128-ed5b-4a93-bd92-b550a0f6e52f",
            "event_time": "2023-06-10 16:30:16",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "55.0"
        },
        "2d0feac6abcacffb68be0fe61bebe2f197590907551389d3ce79fa0d51d93e2d": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    \n\n    bin_indicator = np.where(X == 0, 0, 1)\n\n#     print((W).shape)\n\n#     print((X).shape)\n\n#     print((user_means[:,np.newaxis]).shape)\n\n    num = np.dot(W, (X - user_means[:,np.newaxis]) * bin_indicator)\n\n    den = (eps + np.dot(np.abs(W), bin_indicator))\n\n    return user_means[:,np.newaxis] + num/den",
            "diff_index": 45,
            "id": 2663,
            "person_id": "2d0feac6abcacffb68be0fe61bebe2f197590907551389d3ce79fa0d51d93e2d",
            "submission_id": "8931442f59399798507df3272357b0e0093603a3c99ff4c771254cc4dd8ce10d",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:3f1dd994-861e-479d-99e0-f25c590b91dd",
            "event_time": "2023-06-10 07:55:00",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "75.0"
        },
        "2e1656090c058cd84a13f1faa30fc1b29f80cd06eccb59d66872af95669568ad": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    matrix_not_zero = (X != 0)\n\n    \n\n   \n\n    num = W @ ((X - user_means.reshape(-1, 1)) * matrix_not_zero)\n\n    \n\n    denom = eps + np.abs(W) @ matrix_not_zero\n\n    \n\n    \n\n    output = user_means.reshape(-1, 1) + num / denom\n\n    \n\n    return output",
            "diff_index": 45,
            "id": 3494,
            "person_id": "2e1656090c058cd84a13f1faa30fc1b29f80cd06eccb59d66872af95669568ad",
            "submission_id": "91e8e07015dfb3961cf4148af2218e88f528dfa7966a7ce7559eda0d3027567c",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:f452b80a-c4b4-4233-a24d-23b079c305b1",
            "event_time": "2023-06-12 09:57:33",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "90.0"
        },
        "cc6df0e3a651a204d4156d558777a0c3995ea1ee763a3117cab2b78d12aa08ce": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n\n\n    # binary indicator matrix for handling conditional sums\n\n    X_indicator = np.where(X > 0, 1, 0)\n\n\n\n    # centralize the ratings matrix: you can add a vector to every column of a matrix by broadcasting that vector to 2D.\n\n    X_centralized = X - user_means.reshape(-1, 1)\n\n    \n\n    # numerator of the user-user prediction formula: \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)\n\n    numerator = W.dot(X_centralized*X_indicator)\n\n\n\n    # denominator: \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0\n\n    denominator = abs(W).dot(X_indicator)+eps\n\n\n\n    X_pred = (numerator / denominator) + user_means.reshape(-1, 1)\n\n\n\n    return X_pred",
            "diff_index": 45,
            "id": 2461,
            "person_id": "cc6df0e3a651a204d4156d558777a0c3995ea1ee763a3117cab2b78d12aa08ce",
            "submission_id": "25600f1e540f0bbed3144ea8dc7d2281cea1ab528eeaac3ac79b469a5742656b",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:05f04e4a-d507-4f20-95bf-77a14dde9247",
            "event_time": "2023-06-12 16:52:59",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "95.0"
        },
        "0e7ad91c633cf5126e02bcc5a37d746b869fde0d3faef764a8f1e3b9cf060226": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    \n\n    X_indicator = X != 0\n\n    \n\n    # step1: subtract \uff0c transpose\n\n    conditional_sum = X.transpose() - user_means \n\n    conditional_sum *= X_indicator.transpose()\n\n    conditional_sum = conditional_sum.transpose()\n\n    conditional_sum = np.dot(W, conditional_sum)  \n\n\n\n    absolute_weights_sum = np.dot(np.abs(W), X_indicator)\n\n    X_hat = user_means[:, np.newaxis] + conditional_sum / (eps + absolute_weights_sum)\n\n\n\n    return X_hat",
            "diff_index": 45,
            "id": 3399,
            "person_id": "0e7ad91c633cf5126e02bcc5a37d746b869fde0d3faef764a8f1e3b9cf060226",
            "submission_id": "b70e4f29b4eaa5d727f0611cfb2ad57b8d7241e56999133e538f57881f073dfb",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:de377adb-7823-4b51-86a7-d0da5e52c353",
            "event_time": "2023-06-13 00:55:45",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "55.0"
        },
        "99582505329ebe3f7400613f305e5f9df8432cf712035e01fbb09295132a3e95": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args:\n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    num_users, num_movies = X.shape\n\n\n\n    # Create binary indicator matrix from X\n\n    binary_X = X.copy()\n\n    binary_X[binary_X != 0] = 1\n\n\n\n    # Calculate weighted sum of ratings differences\n\n    weighted_sum_diff = np.dot(W, binary_X * (X - user_means[:, None]))\n\n\n\n    # Calculate sum of absolute weights\n\n    sum_abs_weights = np.dot(np.abs(W), binary_X)\n\n\n\n    # Predict ratings\n\n    pred_ratings = user_means[:, None] + weighted_sum_diff / (eps + sum_abs_weights)\n\n\n\n    return pred_ratings",
            "diff_index": 45,
            "id": 3406,
            "person_id": "99582505329ebe3f7400613f305e5f9df8432cf712035e01fbb09295132a3e95",
            "submission_id": "3bdb5bc7910f08133e7089fc3ae29748eda5f4bf990e2a238aee87f801cc3bcf",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:e7353c07-ec35-4597-97bb-44bf614a50e7",
            "event_time": "2023-06-19 16:14:56",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "80.0"
        },
        "b141452ad3110c1127959693cf480afdcf683c140858dc21d1e580e3354afc15": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    means_col_vector = user_means.reshape(-1, 1)\n\n    binary_matrix = np.ones(X.shape) * (X != 0)\n\n    # get the weighted average ratings\n\n    diff_space = X - means_col_vector # get the average ratings\n\n    diff_space = diff_space * binary_matrix # eliminate unrated values\n\n    numerator = W @ diff_space\n\n    # divide by the weights\n\n    denominator = eps + np.abs(W) @ binary_matrix\n\n    return means_col_vector + numerator / denominator",
            "diff_index": 45,
            "id": 3502,
            "person_id": "b141452ad3110c1127959693cf480afdcf683c140858dc21d1e580e3354afc15",
            "submission_id": "28ed972db2800b019515246b2f2fea287c83f067aaf88795a51dc8e6b9997ac2",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:fc5e3247-6fa7-4737-96d2-3a59bc980bff",
            "event_time": "2023-06-14 04:15:40",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "0.0"
        },
        "b377f6633d367610ad78a44e8c243af9add9b305cace5a599961e5e134dbc716": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    diff = (X - user_means[:, np.newaxis]) * (X!=0)\n\n    num = W.dot(diff)\n\n    den = eps + np.dot(np.abs(W), X!=0)\n\n    return user_means[:, np.newaxis] + num/den\n\n    ",
            "diff_index": 45,
            "id": 3365,
            "person_id": "b377f6633d367610ad78a44e8c243af9add9b305cace5a599961e5e134dbc716",
            "submission_id": "95d4aa5f3ec853eccf2456d08de37af27251c8655bb03a3bdfb37f238becbed4",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:e805d114-83f1-488c-8aa2-195ab4e01f0d",
            "event_time": "2023-06-07 08:13:32",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "75.0"
        },
        "865e6cd64b2141578cfd795d6400f9f6114426112bc825baef1da87ce9c70aee": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3416,
            "person_id": "865e6cd64b2141578cfd795d6400f9f6114426112bc825baef1da87ce9c70aee",
            "submission_id": "43dc82e52143fa41b8e88cbadc2697046d9e25ef554470e49d0c69f2ecc863e6",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:fac58774-7728-4b48-9ad6-1a5b5570f0d9",
            "event_time": "2023-05-31 04:34:25",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "15.0"
        },
        "aad2a5e3be178b75824530286bc11fae13caa902faf741a0554cdb831c5cef6b": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3433,
            "person_id": "aad2a5e3be178b75824530286bc11fae13caa902faf741a0554cdb831c5cef6b",
            "submission_id": "0061786a806280b0c475b8c561b243bf7ac08cc9dae9358bdfd0687b39037af6",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:efef30f7-d747-411e-a8d2-187fb9e11102",
            "event_time": "2023-06-02 18:54:01",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "45.0"
        },
        "09a5e978000ed845af1b76ea4bfa5039afe72d48807045281dcb055b9b015121": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    # Compute indicator matrix\n\n    indicator = (X != 0).astype(int)\n\n    # Compute numerator\n\n    numerator = W @ (indicator *(X - np.expand_dims(user_means, axis=-1)))\n\n    # Compute denominator\n\n    denominator = (np.abs(W) @ indicator) + eps\n\n    # Compute and return X_hat matrix\n\n    return np.expand_dims(user_means, axis=-1) + (numerator / denominator)\n\n    # pass",
            "diff_index": 45,
            "id": 3445,
            "person_id": "09a5e978000ed845af1b76ea4bfa5039afe72d48807045281dcb055b9b015121",
            "submission_id": "4589f63fbb575eb5ecb19bedeedf9724b801a38be40219e3596ded4d6a82b030",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:f9c5e7b9-2d39-41cb-8704-1b1ce8f469b8",
            "event_time": "2023-06-05 07:15:54",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "65.0"
        },
        "608b98bf2688b0972cf99229ad2b6d1d3710ae9c0c162b3b61a9f2aaee48aac8": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    # Create binary matrix for conditional sum\n\n    binary_X = (X != 0).astype(int)\n\n    \n\n    # Compute numerator and denominator of rating prediction formula\n\n    numerator = W @ ((X - user_means.reshape(-1, 1)) * binary_X)\n\n    denominator = eps + np.abs(W) @ binary_X\n\n    \n\n    # Broadcast user means and rating prediction formula\n\n    ratings_pred = user_means.reshape(-1, 1) + numerator / denominator\n\n    \n\n    return ratings_pred",
            "diff_index": 45,
            "id": 3247,
            "person_id": "608b98bf2688b0972cf99229ad2b6d1d3710ae9c0c162b3b61a9f2aaee48aac8",
            "submission_id": "01d714d71a49073fe42d4b996f708ee9cd7489351cfdefc7e8d7cf4b382910a3",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:c30a9634-1bdd-4c02-9356-268545cd15ca",
            "event_time": "2023-06-05 09:27:55",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "95.0"
        },
        "9558865d3da37aee18bf01448dcfc3675e51c4b0c281fd4988d3ad1bb462577c": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n   \n\n\n\n    \"\"\"\n\n    Calculate the mean rating of each user: user_means = np.mean(X, axis=1).\n\n    Create a binary indicator matrix where 1 indicates that a user has rated a movie: indicator_matrix = (X != 0).astype(int).\n\n    Compute the weighted sum of the differences between each user's rating and the mean rating of the other users: weighted_diff = np.dot(W, (X - user_means[:, np.newaxis])).\n\n    Compute the sum of the absolute weights for each user: abs_weights_sum = np.sum(np.abs(W), axis=1).\n\n    Add the mean rating of each user and the weighted differences, divided by the sum of absolute weights and the smoothing constant eps: prediction_matrix = user_means[:, np.newaxis] + weighted_diff / (eps + abs_weights_sum[:, np.newaxis]).\n\n    Return the prediction matrix.\n\n    \"\"\"\n\n    ",
            "diff_index": 45,
            "id": 3429,
            "person_id": "9558865d3da37aee18bf01448dcfc3675e51c4b0c281fd4988d3ad1bb462577c",
            "submission_id": "c89157d4e0a38edc01f66b033b3c03fb47a43d723b81702ec858a188b5525acc",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:fdb182bc-2c83-4a0f-a384-ac8c031b8fd8",
            "event_time": "2023-06-02 00:07:49",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "45.0"
        },
        "1c0b732799b2bc0c8ca987fa3f688d6dbd2a0096229f65272ec081267cc324cd": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3430,
            "person_id": "1c0b732799b2bc0c8ca987fa3f688d6dbd2a0096229f65272ec081267cc324cd",
            "submission_id": "ff38fe0d1b4c07a69a22e27ba7b12406463a0d1485f5a96785e826c4a2b29c15",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:ef98ef64-1b00-4696-8788-277f021f46c8",
            "event_time": "2023-06-02 06:18:35",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "20.0"
        },
        "315f40cd2616367e40846131678f14f40982028bba68f9791cc09cb47402b43a": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    X_bool = (X!=0).astype(int)\n\n    return user_means[:, None] + (W@(X_bool*(X-user_means[:, None]))) / (eps + np.abs(W)@X_bool)",
            "diff_index": 45,
            "id": 3475,
            "person_id": "315f40cd2616367e40846131678f14f40982028bba68f9791cc09cb47402b43a",
            "submission_id": "d4336b4edb9f65b5cf151188c3d6b8f9cec7f03f0ffbce8cfa5a4a7e3092a8b6",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:e92fbaf1-1625-4299-8a6b-b942414e349f",
            "event_time": "2023-06-09 12:47:06",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "60.0"
        },
        "59e681cf2ea9056593501dfa5592cf6fd0e08bc78b9a67cb9c10a8d4f9b75c7e": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n\n\n    ans = W @ np.multiply(X - user_means[:, None], X != 0)\n\n    ans /= (eps + (np.abs(W) @ (X != 0)))\n\n    ans += user_means[:, None]\n\n\n\n    return ans",
            "diff_index": 45,
            "id": 3487,
            "person_id": "59e681cf2ea9056593501dfa5592cf6fd0e08bc78b9a67cb9c10a8d4f9b75c7e",
            "submission_id": "0af61f568b45153598550872771e223e02b49de2f922cdf26845d7c53cc2bc98",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:fc623991-4856-48fb-8990-4fcd5d58c884",
            "event_time": "2023-06-11 08:56:59",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "75.0"
        },
        "fc1c35ee9dc8ff5e6798d0a009ad11f2d23ee48355c9820151532f976500ba7c": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    m, n = X.shape\n\n\n\n    indicator = np.where(X != 0, 1, 0)\n\n\n\n    numerator = np.dot(W, (X - user_means.reshape(-1, 1)) * (X!=0))\n\n\n\n    denominator = np.dot(np.abs(W), (X!=0))\n\n\n\n    epsilon = eps\n\n    denominator += epsilon\n\n\n\n    X_hat = user_means.reshape(-1, 1) + numerator / denominator\n\n\n\n    return X_hat\n",
            "diff_index": 45,
            "id": 3492,
            "person_id": "fc1c35ee9dc8ff5e6798d0a009ad11f2d23ee48355c9820151532f976500ba7c",
            "submission_id": "98cc867aaea5013f018ae4c2786ae73743800b13f7d88f9353dc5d0462488101",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:fa820ae3-a0f7-407e-8b2f-e3786aff752a",
            "event_time": "2023-06-11 18:39:58",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "75.0"
        },
        "1d0478f2ae7dcf64d5b142d2960b316bddb614b408f1c0e9bd5fcd5c4de3e38e": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    user_means_reshaped = user_means[:, np.newaxis]\n\n    b = np.array(X != 0).astype('int64')\n\n    \n\n    numer = W.dot(b * (X - user_means_reshaped))\n\n    denom = eps + np.abs(W).dot(b)\n\n    \n\n    return user_means_reshaped + numer/denom",
            "diff_index": 45,
            "id": 3424,
            "person_id": "1d0478f2ae7dcf64d5b142d2960b316bddb614b408f1c0e9bd5fcd5c4de3e38e",
            "submission_id": "7cdb5ca358e35f57e23c29903dff430719fc5b04aa19100d64a8a09b427084a9",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:fe02b7e5-66d6-421e-ab41-56c698befc48",
            "event_time": "2023-06-01 01:58:04",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "75.0"
        },
        "2f62b30a336d58eb746cbb7acfbe72d46621d58d0722b697e22867025f4187d8": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3419,
            "person_id": "2f62b30a336d58eb746cbb7acfbe72d46621d58d0722b697e22867025f4187d8",
            "submission_id": "01ea7f642354ae209de0439308d219115b41281736b2c9fa3e6a8a23b1c079b5",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:f84bfb6a-fc66-4353-beed-249ddc951717",
            "event_time": "2023-05-31 14:52:33",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "10.0"
        },
        "89b278acf9077e36a25848570808806b4cdd6a69d6185d68fb1ff74b1385acd1": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    sign = np.absolute(np.sign(X))\n\n\n\n    X = X - user_means[:, None]\n\n    X = W@(X*sign)/(W@sign + eps) + user_means[:, None]\n\n    return X\n\n\n\n    pass",
            "diff_index": 45,
            "id": 2804,
            "person_id": "89b278acf9077e36a25848570808806b4cdd6a69d6185d68fb1ff74b1385acd1",
            "submission_id": "d028c9c037ac417cab32419f89134877bbafcbcfe59293d9febc4331f2eec527",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:6b890e74-d77f-4a5e-89ea-15e8bed9e6aa",
            "event_time": "2023-06-03 10:07:41",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "85.0"
        },
        "1036ed10f6f968631ef4569d77606ed1ce5cd59cabf859592b9292ce3d4475d3": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    ind = X != 0\n\n    ret = ind * (X - user_means.reshape(-1, 1)) # reshaped to column vector. ret: (num_users, num_movies)\n\n    ret = W @ ret # ret: (num_users, num_movies), numerator in the equation\n\n    # denominator in the equation\n\n    denom = eps + W @ ind   # shape: (num_users, num_movies)\n\n    ret = user_means.reshape(-1, 1) + ret / denom\n\n    return ret",
            "diff_index": 45,
            "id": 3233,
            "person_id": "1036ed10f6f968631ef4569d77606ed1ce5cd59cabf859592b9292ce3d4475d3",
            "submission_id": "dce80b8574495cb45457055f1b15690ac8d270f9a930e58a87039d466652105a",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:cc5f4e65-ed9c-4794-8b2e-8446f386737d",
            "event_time": "2023-06-03 17:49:44",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "95.0"
        },
        "dfc198a26d19c7379219f4414ce502fc396517b29f7aaf82bb66dc196fc9c050": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3146,
            "person_id": "dfc198a26d19c7379219f4414ce502fc396517b29f7aaf82bb66dc196fc9c050",
            "submission_id": "c781ef6609c27e639c7ce6b6c59810dd507d33cee6bddb6280afd1aad0f2dfb9",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:a5f84579-0d55-446b-97aa-78552afe716b",
            "event_time": "2023-06-05 04:50:43",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "20.0"
        },
        "49f23aadb259f078f27eef99ae1e35db2336393cafdff9e91cf576895e3fd5e3": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    M = np.where(X == 0, 0, 1)\n\n\n\n    D = eps + W.T @ M\n\n\n\n    U = W.T @ np.multiply(M, (X - user_means[:,None]) )\n\n\n\n    R = np.divide(U,D)\n\n\n\n    L = user_means[:, None]\n\n\n\n    result = L + R\n\n\n\n    return result",
            "diff_index": 45,
            "id": 3396,
            "person_id": "49f23aadb259f078f27eef99ae1e35db2336393cafdff9e91cf576895e3fd5e3",
            "submission_id": "d2d80e8d548cfccb3e0084bb157bdcceb1b74dcb67fb654c805dd954c8abdafb",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:e7c45a7c-a5a1-492a-80ca-d678416ea1f3",
            "event_time": "2023-06-11 13:40:23",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "95.0"
        },
        "f1d3bc01fbbb656bc2a6ab024c8525ff4116bfeedd0d1605f43a3dbc5f2045cd": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3110,
            "person_id": "f1d3bc01fbbb656bc2a6ab024c8525ff4116bfeedd0d1605f43a3dbc5f2045cd",
            "submission_id": "259792d6b41d2e5843f636c668ca866e14e3b6ba4a4aa8f3b0e4cc2f68b566cf",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:b1965534-4fd5-4173-a607-62d70c1ba812",
            "event_time": "2023-06-01 06:56:46",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "20.0"
        },
        "d99f9ae3712814404ddd80975f51080e402152ebcc6e1d7e489a059d3820994c": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3495,
            "person_id": "d99f9ae3712814404ddd80975f51080e402152ebcc6e1d7e489a059d3820994c",
            "submission_id": "8a5e56073e47fbadef58b4ab719be3b99b186586dfb5f3a06bbf1a0b41ea1405",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:fb1015ed-1081-46f2-bc2b-7ac4057ffc4b",
            "event_time": "2023-06-12 11:11:31",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "15.0"
        },
        "6f91bbf822374b6663f7e1615231b0862c07ff5414d7e73fa732cddd64a17b32": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    binary_ind = (X != 0)\n\n    X_diff = (X - user_means[:, None]) * binary_ind\n\n    num = W.dot(X_diff)\n\n    denom = W.dot(binary_ind) + eps\n\n    X_hat = user_means[:, None] + num / denom\n\n\n\n    return X_hat\n\n    pass",
            "diff_index": 45,
            "id": 2946,
            "person_id": "6f91bbf822374b6663f7e1615231b0862c07ff5414d7e73fa732cddd64a17b32",
            "submission_id": "7b9f45e909e638d35811afc8b5eafc24f24b1f47a6a27d9ecff60c74f78cad45",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:8c123357-3f48-48e7-9d14-543480860a59",
            "event_time": "2023-06-06 12:27:42",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "90.0"
        },
        "caca2566bff4c788833ee1360ce9fc74d00bcf24e4d37eed018e46ea26dfbcc4": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3320,
            "person_id": "caca2566bff4c788833ee1360ce9fc74d00bcf24e4d37eed018e46ea26dfbcc4",
            "submission_id": "0dcc742332858e729a0e61440e251a983edd1d4c9f78ee2460ad822d5f8f02cc",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:d974864b-bc37-4246-9b51-8763cfd1699c",
            "event_time": "2023-06-01 15:38:19",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "0.0"
        },
        "e3175b35e85a352c5f6ef895cfae7ef3c646f1876741f959544b9c6ffe0a6206": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    pass",
            "diff_index": 45,
            "id": 3097,
            "person_id": "e3175b35e85a352c5f6ef895cfae7ef3c646f1876741f959544b9c6ffe0a6206",
            "submission_id": "821d1953e3d77fb6854d90fae90d6538ea1b27f63b6c060c69fc53d80ca2082a",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:a4628cff-0804-4059-bf04-053df821d318",
            "event_time": "2023-05-30 15:39:23",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "10.0"
        },
        "c5324c71931c07fa0c65d1feda8a284de2c12b4ecafa63e1e7b7fe83f86406be": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    \n\n    # boolean mask for X\n\n    mask = np.where(X != 0, 1, 0)\n\n    diff = np.where(X != 0, X - user_means[:, np.newaxis], 0)\n\n\n\n    numerator = np.dot(W, diff)\n\n    denominator = np.dot(np.abs(W), mask) + eps\n\n    second_term = numerator / denominator\n\n\n\n    return user_means[:, np.newaxis] + second_term",
            "diff_index": 45,
            "id": 3496,
            "person_id": "c5324c71931c07fa0c65d1feda8a284de2c12b4ecafa63e1e7b7fe83f86406be",
            "submission_id": "0016f1f133ee8a1cd8a82d33b1e5d1853c6747ff6dfc3bab74682894b919861e",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:f869b47c-6f1a-4fab-9c8a-d1ca2d40963d",
            "event_time": "2023-06-12 20:02:55",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "90.0"
        },
        "ed4e2fed716a4b3bdfca3aec88efa57b62f30faa4ebc4ca0793273cb930b405d": {
            "question": "### Question 8a: Predict user ratings based on user-user similarity\n\nWe are now ready to make predictions about the missing ratings:\n\n\n\n$$\\hat X_{ij} = \\bar x_i + \\frac{  \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot w_{ik}(X_{kj} - \\bar x_k)}{ \\epsilon + \\sum_{k=1}^m \\mathbb{1}(X_{kj} \\ne 0) \\cdot |w_{ik}|}$$\n\n\n\nNote that we add a smoothing constant $\\epsilon$ in the denominator to cover the case where no user has previously rated the movie $j$. Complete the `predict_user_user` function which takes as input the rating matrix `X`, user-user similarity matrix `W` and `user_means` array; it then returns the rating prediction matrix $\\hat{X}$.\n\n\n\n**Notes**:\n\n* To handle conditional sum, we can multiply our input matrix with some binary indicator matrix. Which binary matrix is suitable here?\n\n* Recall that you can add a vector to every column of a matrix by broadcasting that vector to 2D.",
            "answer": "def predict_user_user(X, W, user_means, eps=1e-12):\n\n    \"\"\"\n\n    Using the user-user similarity matrix, return the predicted ratings matrix\n\n\n\n    args: \n\n        X (np.array[num_users, num_movies]) : the actual ratings matrix, where missing entries are 0\n\n        W (np.array[num_users, num_users])  : user-user similarity weight matrix\n\n        user_means (np.array[num_users, ])  : mean-user-rating array\n\n        user_id (int)  : the id of the user whose missing ratings are predicted (from 0 to num_user)\n\n        eps (float) : smoothing constant to avoid division by zero\n\n\n\n    return:\n\n        np.array[num_users,  num_movies] -- the predicted ratings matrix\n\n    \"\"\"\n\n    # user_means_row_vector = user_means[None, :]\n\n    user_means_col_vector = user_means[:, None]\n\n\n\n    # one operation of W @ X should be wi1*X1j + wi2*X2j + ....\n\n\n\n    \"\"\"\n\n    For one Xij\n\n    We take weighted sum of the ratings given by all the users \n\n    where the weights are given by a similarity matrix\n\n    One row of a similarity matrix multiplied by one column of the user-item matrix\n\n    will provide us with a weighted sum of the ratings given by all the user for an item j with respect to user i\n\n\n\n    TODO: Finish this bruv\n\n    \"\"\"\n\n\n\n    initialX = X.copy()\n\n    num = (W @ ((X - user_means_col_vector)*(initialX != 0)))\n\n    denom = eps + (np.abs(W)@(initialX != 0))\n\n    res = (num / denom) + user_means_col_vector\n\n\n\n    return res",
            "diff_index": 45,
            "id": 3366,
            "person_id": "ed4e2fed716a4b3bdfca3aec88efa57b62f30faa4ebc4ca0793273cb930b405d",
            "submission_id": "d6a15510c2dfe2ebe9788d9e7171011d7bbd1701f330c59d793cfe5c4644bbf7",
            "module_name": "Problem Representation",
            "module_slug": "project-learn-problem-re-e3ybvztr",
            "task_name": "Movie streaming service dataset",
            "task_slug": "2ec6fdf7-cc17-4511-8f9c-a81571ef7454",
            "event_id": "urn:id:e7979ea4-a0e7-49a3-8ef2-4866dcc12f3e",
            "event_time": "2023-06-07 11:01:49",
            "module_date_to_activate": "2023-05-30 04:00:01",
            "module_date_to_submit": "2023-06-13 03:59:59",
            "score_obtained": "85.0"
        }
    },
    "Develop Python solutions using Jupyter Notebook": {
        "16bc75e33edbc348401f0231489762b5197294504195b20410193cf4d9a0cc78": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n\n\n    if b == 0:\n\n      return a\n\n    \n\n    return gcd(b, a%b)\n\n    ",
            "diff_index": 2,
            "id": 301,
            "person_id": "16bc75e33edbc348401f0231489762b5197294504195b20410193cf4d9a0cc78",
            "submission_id": "8104f86528e376d48c62deafbce4d912da22bd09c7c9b78e48120c0eac064137",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:9c92ed03-e264-4aa1-a2bc-3b5272a06213",
            "event_time": "2023-01-20 16:11:15",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "db9bd564d9c335f9ff8ccdcb8558cc8ecf415a54de48e82b18de3c2c48505fb2": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if (b == 0):\n\n      return abs(a)\n\n    else: \n\n      return gcd (b, a% b)\n\n    pass",
            "diff_index": 2,
            "id": 302,
            "person_id": "db9bd564d9c335f9ff8ccdcb8558cc8ecf415a54de48e82b18de3c2c48505fb2",
            "submission_id": "88dfb11324335d7849f2f775d780814f1a9415393055c198aa033c576c9423da",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:626a65f6-1a9a-46f5-9594-7e54db15c484",
            "event_time": "2023-01-20 23:53:13",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "0a9441e8caa84325ce6dececee4b003fc1d2b94676347d8426caefc375784a48": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n  hcf = min(a, b)\n\n  if (hcf == 0):\n\n    return max(a, b)\n\n  while(hcf > 0):\n\n    if(a % hcf == 0 and b % hcf == 0):\n\n      break\n\n    else:\n\n      hcf-=1\n\n  return hcf",
            "diff_index": 2,
            "id": 304,
            "person_id": "0a9441e8caa84325ce6dececee4b003fc1d2b94676347d8426caefc375784a48",
            "submission_id": "2513ed2aa29d3c9842c1a7a7090ab0d7869c66faca0f85828c38c4c3654dbbc9",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:19ed042a-f3d6-4529-9458-93b6fabd2ae2",
            "event_time": "2023-01-21 23:07:28",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "b29de73eb4903b487679e2c2831a24bfff7f46fa965b50f997e59e69fd6c070b": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a == 0:\n\n        return b\n\n    if b == 0:\n\n        return a\n\n    gcd = 1\n\n    minm = min(a,b)\n\n    for i in range(1,minm+1):\n\n        if a % i == 0 and b % i == 0:\n\n            gcd = i\n\n\n\n    return gcd",
            "diff_index": 2,
            "id": 306,
            "person_id": "b29de73eb4903b487679e2c2831a24bfff7f46fa965b50f997e59e69fd6c070b",
            "submission_id": "8202c701d0501d12f6df9adf8454f346fc908bc7a747083232429e55f26b68c8",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:d6e0afc6-feeb-4879-bbf6-f9a6d16bf722",
            "event_time": "2023-01-22 01:05:37",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "d1e53d3a2824cb135e1452ad8089fcf3ac692aa25f3d0196548d15f531833c4d": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    while b!=0:\n\n        a,b = b, a%b\n\n    \n\n    return a",
            "diff_index": 2,
            "id": 308,
            "person_id": "d1e53d3a2824cb135e1452ad8089fcf3ac692aa25f3d0196548d15f531833c4d",
            "submission_id": "a93c9c90509e84f7839eb983b5467b24ed1039a7e2e39eb08cb75384e5aa29ef",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:709e2b14-b0a6-4e5b-88d1-5dfaee4b3005",
            "event_time": "2023-01-23 01:26:13",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "0c2a88db65f0d0d7b081994c940bef45c838764f369623b11803a13b679785d4": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    res = 0\n\n    m = min(a,b)\n\n    for i in range(1,m+1):\n\n        if a%i==0 and b%i==0:\n\n            res = i\n\n    if a==0:\n\n        res=b\n\n    elif b==0:\n\n        res=a\n\n    return res\n\n    pass",
            "diff_index": 2,
            "id": 309,
            "person_id": "0c2a88db65f0d0d7b081994c940bef45c838764f369623b11803a13b679785d4",
            "submission_id": "70761e2dbac297ebf01e1f6a0d3d53e58ad68b9d108f3a91e4b4aab93ffd973d",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:a73ce3a2-5a89-40ca-8fff-a010531ed65d",
            "event_time": "2023-01-23 02:11:20",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "27ce4ca0fedbf2eed93fa81ebf40c77a05500fd4addd7365689671548e55d247": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    while min(a, b) > 1:\n\n      mini = min(a, b)\n\n      maxi = max(a, b)\n\n      maxi = maxi %  mini\n\n      a = mini\n\n      b = maxi\n\n    \n\n    if a == 0: return b\n\n    if b == 0: return a\n\n    return min(a, b)",
            "diff_index": 2,
            "id": 311,
            "person_id": "27ce4ca0fedbf2eed93fa81ebf40c77a05500fd4addd7365689671548e55d247",
            "submission_id": "cb8f6645071bad720713fa897784b93bc6d48a7700f71044ee5477f3e41feee8",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:9fd594da-2ac5-4b23-a7cd-8f84ccc617c4",
            "event_time": "2023-01-23 16:30:59",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "e0c7bf6edae953e8d8cbd4eabafb488cff19306d290ee18b4aa3cf81fa0e9b9a": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    \n\n    if a == 0:\n\n        return b\n\n    if b == 0:\n\n        return a\n\n    if a >= b:\n\n        return gcd(b, a%b)\n\n    elif a <= b:\n\n        return gcd(a, b%a)\n\n        ",
            "diff_index": 2,
            "id": 313,
            "person_id": "e0c7bf6edae953e8d8cbd4eabafb488cff19306d290ee18b4aa3cf81fa0e9b9a",
            "submission_id": "b8a7d2dae3b21a52a8a10ec20f7dcdb333ec86ce27f6bb9978bad13014b2ffc3",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:810e32aa-29e4-48f2-bad7-600651af5b2e",
            "event_time": "2023-01-23 19:40:52",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "0d5c28b308339548b6dcbf0c31ba645fa31fcdbf173c1ea584b7c65d72d77ba4": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a == 0:\n\n        return b\n\n    if b == 0:\n\n        return a\n\n    smaller = a if a<b else b\n\n    for i in range(smaller, 0, -1):\n\n        if a%i == 0 and b%i == 0:\n\n            return i\n\n    pass",
            "diff_index": 2,
            "id": 314,
            "person_id": "0d5c28b308339548b6dcbf0c31ba645fa31fcdbf173c1ea584b7c65d72d77ba4",
            "submission_id": "96f11a2495415c72220a4191067343c03447cbbb83fbc78fd71bb63d9f1fb54b",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:6498b7fd-f22a-46a7-b5fe-ce18e850d0f3",
            "event_time": "2023-01-24 03:54:19",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "717aa2afc8b2093fa507767616743a43abf54d168c3f2f17dd7614de39a115c5": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    while b:\n\n        temp = a\n\n        a = b\n\n        b = temp % b\n\n    \n\n    return abs(a)\n\n#     pass",
            "diff_index": 2,
            "id": 316,
            "person_id": "717aa2afc8b2093fa507767616743a43abf54d168c3f2f17dd7614de39a115c5",
            "submission_id": "b1c49065f866220be6363d942d79fe8521bc50cf76ceef72bdb8af32186f3582",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:f1c8944a-7f26-49c2-92ec-f185b9321211",
            "event_time": "2023-01-25 23:10:23",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "ba14245dab5c8159e3a36631debe0b8940f314324a629e70785ca2efdc2e4796": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if b != 0:\n\n        return gcd(b,a%b)\n\n    else:\n\n        return a\n\n\n",
            "diff_index": 2,
            "id": 318,
            "person_id": "ba14245dab5c8159e3a36631debe0b8940f314324a629e70785ca2efdc2e4796",
            "submission_id": "3d28737544fdf570cc60ad0df50fa1466e46e98a7ea9c7281720a6689e1075f4",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:55252e8d-b2b7-42af-a044-a24cd28a5a4b",
            "event_time": "2023-01-26 04:39:52",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "b477c1c79d053afa4062b01ac3c2520ed2d8146de6fec21b6ebd0ee6df404e81": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a==0: return b\n\n    if b==0: return a\n\n    smallerNum = a if (a < b) else b\n\n    for i in range(smallerNum, 0, -1):\n\n      if a%i==0 and b%i==0:\n\n        return i",
            "diff_index": 2,
            "id": 319,
            "person_id": "b477c1c79d053afa4062b01ac3c2520ed2d8146de6fec21b6ebd0ee6df404e81",
            "submission_id": "1e447a2cd0a2ae2752bbcd2fe55d55cbb9296ca0467783747cfdcaeb59d81c05",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:c22ed003-efe3-4eed-9993-114ca0a9a45b",
            "event_time": "2023-01-27 09:01:06",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "c63974eda3ed8212eff439046e3f7e53326d736e6d927cef213242e7e24520dd": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    mini = min(a,b)\n\n    maxi = max(a,b)\n\n    largest_divisor = 1  # default result\n\n    \n\n    for i in range(2,maxi+1): # iterate from 2 to the maximum value\n\n        if maxi%i == 0 and mini%i == 0:  # check if the remainder is 0 for both terms\n\n            largest_divisor = i  # update when the terms are both divisible by i\n\n            \n\n    return largest_divisor\n\n    pass",
            "diff_index": 2,
            "id": 320,
            "person_id": "c63974eda3ed8212eff439046e3f7e53326d736e6d927cef213242e7e24520dd",
            "submission_id": "e2726ed458392b5c516e0bd3ebabca0b1ebb03a044f79943ea0898e31ff9098a",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:3f5d3496-53ad-4f71-bf32-6fc2d192ba2d",
            "event_time": "2023-01-27 21:09:12",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "b15fa1b6d1b6aee261a87f0e499e6a2240c9d4581a9d3104ff378e4218be51ee": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    result = 0\n\n    if a == 0 or b == 0:\n\n        return max(a, b)\n\n    for i in range(1, min(a, b)+1):\n\n        if a % i == 0 and b % i == 0 and i > result:\n\n            result = i\n\n    return result",
            "diff_index": 2,
            "id": 322,
            "person_id": "b15fa1b6d1b6aee261a87f0e499e6a2240c9d4581a9d3104ff378e4218be51ee",
            "submission_id": "2f1cd621e3d8da27c6d3d46be95b5a2b56b0f6e6bc5ccdf12e744cc4010905cb",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:bd5cc8b5-c529-4051-a8da-628953c62ce9",
            "event_time": "2023-01-28 03:56:14",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "85b6c5d3712a109e5a69d2ac284c702bc93646b2809b48fdf36887129fc306a0": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    pass",
            "diff_index": 2,
            "id": 323,
            "person_id": "85b6c5d3712a109e5a69d2ac284c702bc93646b2809b48fdf36887129fc306a0",
            "submission_id": "fb132540fb3df57af7e21c17b70296d55536f1096f02fc3f285c90901a4f294a",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:1a7a08e5-888a-490d-8aa8-f1c6d60d9102",
            "event_time": "2023-01-28 19:56:06",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "0.0"
        },
        "8c5cd3c00e335d2270df2c9749d34bac3cb55a1833b31f4d199924bbccfd610c": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if (a + b) > 0:\n\n        if b == 0:\n\n            result_gcd = a\n\n        else:\n\n            result_gcd = gcd(b, a % b)\n\n        return result_gcd\n\n    pass",
            "diff_index": 2,
            "id": 325,
            "person_id": "8c5cd3c00e335d2270df2c9749d34bac3cb55a1833b31f4d199924bbccfd610c",
            "submission_id": "52e0484c4e6f1c5f640ad187f3695e79985be1a5ddd70b0275e19afc96512ae5",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:706ebf78-f14a-4df3-a6b3-a349f4695e92",
            "event_time": "2023-01-28 20:37:37",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "24bd48f2d99580fa112c446b8f13466daea5acc54ee7c4451e20bda7d2a87d4b": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    gcd=0\n\n    if a==0:\n\n        return b\n\n    elif b==0:\n\n        return a\n\n    if a+b>0:\n\n        small=min(a,b)\n\n        for i in range(1,small+1):\n\n            if ((a%i==0) and (b%i==0)):\n\n                gcd=i\n\n    return gcd\n\n    pass",
            "diff_index": 2,
            "id": 326,
            "person_id": "24bd48f2d99580fa112c446b8f13466daea5acc54ee7c4451e20bda7d2a87d4b",
            "submission_id": "054e15b56dd17dd1222f6b10c1a534501a9f0bcd52ea57bb626344912fe014be",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:86d7b733-9e86-4248-af11-2e4ac13b1f78",
            "event_time": "2023-01-28 21:10:05",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "1b52591a6b6b255976fb376f7f011afa41f79dfb3a52684d93db0ffc4675f3c0": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    common_div = min(a,b)\n\n    for k in range(1, common_div+1):\n\n        if a % k == b % k and a % k == 0:\n\n            common_div = k \n\n    if common_div != 0:\n\n        return common_div\n\n    else:\n\n        return max(a,b)",
            "diff_index": 2,
            "id": 331,
            "person_id": "1b52591a6b6b255976fb376f7f011afa41f79dfb3a52684d93db0ffc4675f3c0",
            "submission_id": "bb1db87d56d61da13f3fe9405f63a77c12193f2e45bcab76019c728affbcb74d",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:310f758f-5f10-4727-81d7-535635f940fe",
            "event_time": "2023-01-28 22:35:48",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "c8fbcf76871add9af022e28241c28a6e7510527f3f00303d3248727626301869": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a == 0:\n\n        return b\n\n    elif b == 0:\n\n        return a\n\n    elif a == b:\n\n        return a\n\n    diff = 0\n\n    if (a > b):\n\n        diff = a - b\n\n    else:\n\n        diff = b - a\n\n    if (a > b):\n\n        return gcd(diff, b)\n\n    else:\n\n        return gcd(a, diff)\n\n    pass",
            "diff_index": 2,
            "id": 332,
            "person_id": "c8fbcf76871add9af022e28241c28a6e7510527f3f00303d3248727626301869",
            "submission_id": "773790d983a74dcf8c6347a36e6e86c6a22db659d7f3a40ecf7ad9650fe6fe58",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:05a72629-fe32-498d-a4e2-555b9511229c",
            "event_time": "2023-01-28 23:07:38",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "7e56eade081fe976526b47d4ddcebb2ed913be568de4cc51522d0c177b56c978": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if (a!= 0 and b!= 0):\n\n        if a<b:\n\n            smallest = a\n\n        else:\n\n            smallest = b\n\n    elif a != 0:\n\n        return a\n\n    else:\n\n        return b\n\n        \n\n    for i in range(1,smallest+1):\n\n        if(a%i == 0 and b%i == 0):\n\n            result = i\n\n                    \n\n    return result",
            "diff_index": 2,
            "id": 333,
            "person_id": "7e56eade081fe976526b47d4ddcebb2ed913be568de4cc51522d0c177b56c978",
            "submission_id": "5ac4795fc0853a52399c855af9e9a390ac83f187602cf0d0043ee11362b3bffa",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:99010be0-4370-4b9c-9169-f35f6ba29fc8",
            "event_time": "2023-01-29 00:11:08",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "1e766457eb034a06ba8a2b65e5cc55c7ccbc3f51a05f50969ac44e74a2cd36db": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    while b != 0:\n\n        (a, b) = (b, a % b)\n\n    return a",
            "diff_index": 2,
            "id": 334,
            "person_id": "1e766457eb034a06ba8a2b65e5cc55c7ccbc3f51a05f50969ac44e74a2cd36db",
            "submission_id": "df3f39eb7559c9400b98816e2f44fa5b924931c71d938940882a7cd8ed1814af",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:02d9320a-b043-45a3-a0f9-818e51a1d39e",
            "event_time": "2023-02-03 21:30:13",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "0f23cdf295d39ac98defc0ee761d7475cebf511054ef56163e1c38fb4b1cf126": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    while b:\n\n        a, b = b, a%b\n\n    return abs(a)\n\n        ",
            "diff_index": 2,
            "id": 335,
            "person_id": "0f23cdf295d39ac98defc0ee761d7475cebf511054ef56163e1c38fb4b1cf126",
            "submission_id": "9edc5639ef27727316c11e6b17785c9c62459963ef14fe7134d5d72bc347845f",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:c92591a7-12ae-4eff-81b1-4432cd7fabd3",
            "event_time": "2023-02-04 10:06:27",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "36d99f41f09b4b933a488723fed464dbffc23bbe7718e857fa09e53580db4980": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a > b:\n\n        firstNumber = b\n\n    else:\n\n        firstNumber = a\n\n    if a == 0:\n\n        gcd = b\n\n    if b==0:\n\n        gcd = a   \n\n    for x in range(1, firstNumber + 1):\n\n        if((a % x == 0) and (b % x == 0)):\n\n            gcd = x\n\n             \n\n    return gcd",
            "diff_index": 2,
            "id": 336,
            "person_id": "36d99f41f09b4b933a488723fed464dbffc23bbe7718e857fa09e53580db4980",
            "submission_id": "5d37ea8adad10422787ec3e258d4b5e253af6ae5c0b89e28080cdaa2ee4e9739",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:b147b352-50d9-4c29-9637-84bfca01b2ae",
            "event_time": "2023-02-04 23:09:31",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "c9af2334b06388dbf4c60341c1d5d2dbb63077958e0c8190c3bc47d09d20e6dc": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    pass",
            "diff_index": 2,
            "id": 337,
            "person_id": "c9af2334b06388dbf4c60341c1d5d2dbb63077958e0c8190c3bc47d09d20e6dc",
            "submission_id": "03c5cb3698ced838e64920616c5b05bb7cbfc6e8c00cb9c429e15d70120bf9ec",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:ac749e56-28f9-41bc-a13d-193870262dd9",
            "event_time": "2023-02-05 00:08:47",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "0.0"
        },
        "bc56e199f18353a5d1fbd477402cdd457f0b7259d5eb274aab8b095a5ab40c22": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if b > a:\n\n        c = a\n\n        a = b\n\n        b = c\n\n    if b == 0:\n\n        return a\n\n    c = a % b\n\n    if c == 0:\n\n        return b\n\n    a = b\n\n    b = c\n\n    return gcd(a, b)\n\n    ",
            "diff_index": 2,
            "id": 338,
            "person_id": "bc56e199f18353a5d1fbd477402cdd457f0b7259d5eb274aab8b095a5ab40c22",
            "submission_id": "3f105c5606553002781f2ec56cebd5abd469d02630651c63a2741390f9369e27",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-ya5473vb",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:a2d09ff5-57ac-4e6e-a38b-e201024ffb0e",
            "event_time": "2023-02-06 06:04:35",
            "module_date_to_activate": "2023-01-19 05:01:00",
            "module_date_to_submit": "2023-01-29 04:59:59",
            "score_obtained": "35.0"
        },
        "93921947301e98a0db2a717b4c09d333257dadbc800e2a28a2baf8f83b34fbd3": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    if a + b <= 0:\n\n        raise ValueError(\"Invalid input: a + b must be greater than 0.\")\n\n    \n\n    while b:\n\n        a, b = b, a % b\n\n    return a\n\ngcd(3,6)",
            "diff_index": 2,
            "id": 2156,
            "person_id": "93921947301e98a0db2a717b4c09d333257dadbc800e2a28a2baf8f83b34fbd3",
            "submission_id": "f7737a58d528943c0cfe35665923b16a72289c9bc94987c62264b096cef16f63",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:7cf510cf-0395-45a9-b85e-94f97410e2ec",
            "event_time": "2023-05-17 20:31:02",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "58d4962e846c8754e3b0dc975e61d164ad45771252706ee87bc9275658bc323d": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a==0:\n\n        return b\n\n    \n\n    if b==0:\n\n        return a\n\n    \n\n    if a<b:\n\n        x=a\n\n    else:\n\n        x=b\n\n    \n\n    gcd=1\n\n    for i in range(1,x+1):\n\n        if a%i==0 and b%i==0:\n\n            gcd=i\n\n    \n\n    return gcd   \n\n\n\n    pass",
            "diff_index": 2,
            "id": 2048,
            "person_id": "58d4962e846c8754e3b0dc975e61d164ad45771252706ee87bc9275658bc323d",
            "submission_id": "6295f71ef20c4eeeacfa665d15f953d5ae69fb82050bdd12ef19f3559a910f97",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:16a294a1-6195-4dab-b4c5-d25694205e74",
            "event_time": "2023-05-19 15:45:34",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "d40142db22835ef2c018c7bfd40902b524a5a619a019730251afbe39b57aeca8": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    l1,l2,l3=[],[],[];\n\n    if a==0 or b==0:\n\n      return max(a,b)\n\n    else:\n\n      for i in range(1,a+1):\n\n        if a%i==0:\n\n          l1.append(i)\n\n      \n\n      for i in range(1,b+1):\n\n        if b%i==0:\n\n          l2.append(i)\n\n      \n\n      for i in l1:\n\n        for j in l2:\n\n          if i==j:\n\n            l3.append(i)\n\n      \n\n      result = max(l3)\n\n      return result",
            "diff_index": 2,
            "id": 2050,
            "person_id": "d40142db22835ef2c018c7bfd40902b524a5a619a019730251afbe39b57aeca8",
            "submission_id": "f77c41d34f192f05349eeeb3d7508ffaf22eaafd544171c75f634d1dc0a82efb",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:1a968d6b-e1ba-4856-9c1e-25b1c87191b8",
            "event_time": "2023-05-20 10:00:43",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "aad2a5e3be178b75824530286bc11fae13caa902faf741a0554cdb831c5cef6b": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a == 0:\n\n      return b\n\n    if b == 0:\n\n      return a\n\n    if a > b:\n\n      c = a%b\n\n      if c == 0:\n\n        return b\n\n      return gcd(b,c)\n\n    else:\n\n      c = b%a\n\n      if c == 0:\n\n        return a\n\n      return gcd(a,c)\n\n    ",
            "diff_index": 2,
            "id": 2051,
            "person_id": "aad2a5e3be178b75824530286bc11fae13caa902faf741a0554cdb831c5cef6b",
            "submission_id": "9e192d0638943727490d174801e51fed31a6e621059a30a835d27ef4eefc1eb6",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:1c08538b-360f-4e75-99bd-02e0db797455",
            "event_time": "2023-05-20 14:55:33",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "c0c68f26d38e9e55ac7bfd5e94f5db549c4f935a80162b6dd811f93e458f8d4f": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    return_val = 0\n\n    if a % b == 0 and (a > b or a == 0 or a == b):\n\n      return_val = b\n\n    elif b % a == 0 and (b > a or b == 0):\n\n      return_val = a\n\n    else:\n\n      a_divs = []\n\n      b_divs = []\n\n      for num in range(1,a+1):\n\n        if(a%num==0):\n\n          a_divs.append(num)\n\n      for num in range(1,b+1):\n\n        if(b%num==0):\n\n          b_divs.append(num)\n\n      a_divs.sort(reverse = True)\n\n      b_divs.sort(reverse = True)\n\n      if a > b:\n\n        for i in b_divs:\n\n          if i in a_divs:\n\n            return_val = i\n\n            break\n\n      elif b > a:\n\n        for i in a_divs:\n\n          if i in b_divs:\n\n            return_val = i\n\n            break\n\n      else:\n\n        print(\"Invalid args\")\n\n    return return_val\n\n        ",
            "diff_index": 2,
            "id": 2052,
            "person_id": "c0c68f26d38e9e55ac7bfd5e94f5db549c4f935a80162b6dd811f93e458f8d4f",
            "submission_id": "75126600844f42947e2499196cbcfaf2c06748691cba1fade9e6687372e9c843",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:16870c8d-4279-45ec-a728-ed9efab65750",
            "event_time": "2023-05-21 20:26:36",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "6f91bbf822374b6663f7e1615231b0862c07ff5414d7e73fa732cddd64a17b32": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    while b:\n\n        a, b = b, a % b\n\n    return a\n\n    pass",
            "diff_index": 2,
            "id": 2053,
            "person_id": "6f91bbf822374b6663f7e1615231b0862c07ff5414d7e73fa732cddd64a17b32",
            "submission_id": "1b6d0bc803258672dbcb01c18a65cb5d6e10d3c2ad9f40ab5be7926aba3eb306",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:1c53ee1f-5847-417e-9686-049f8b61ded4",
            "event_time": "2023-05-22 17:29:11",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "1ec62d57d2e3261032b1eff2546e5f220cdd1d82b814b8814184506b2a98d82e": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    # pass\n\n    while b:\n\n        a, b = b, a % b\n\n    return a",
            "diff_index": 2,
            "id": 2054,
            "person_id": "1ec62d57d2e3261032b1eff2546e5f220cdd1d82b814b8814184506b2a98d82e",
            "submission_id": "f7127d01a6b71af51f93e89d8fb0d3b781378219eac37bb1e4dcfb7f5df5d3cf",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:022f1d85-b2e0-4ae4-946b-df7acab8127a",
            "event_time": "2023-05-22 21:01:28",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "b2e07fd5dd8e7ffb2af968625b897ee5ee3b264ade758b5f550702cd091ac1ab": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n        while (b != 0):\n\n        temp = a\n\n        a = b\n\n        b = temp % b\n\n    \n\n    return a",
            "diff_index": 2,
            "id": 2237,
            "person_id": "b2e07fd5dd8e7ffb2af968625b897ee5ee3b264ade758b5f550702cd091ac1ab",
            "submission_id": "5a822003c90b267725c46a1e142d645f02fe8df5d8fc02c6c412fe8c9f419558",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:2f624d84-1e64-43da-9bff-2be69c8a5f88",
            "event_time": "2023-05-23 03:12:16",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "0.0"
        },
        "1d0478f2ae7dcf64d5b142d2960b316bddb614b408f1c0e9bd5fcd5c4de3e38e": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    c, d = min(a, b), max(a, b)\n\n    if c == 0:\n\n        return d\n\n    else:\n\n        return gcd(d%c, c)",
            "diff_index": 2,
            "id": 2150,
            "person_id": "1d0478f2ae7dcf64d5b142d2960b316bddb614b408f1c0e9bd5fcd5c4de3e38e",
            "submission_id": "40e9b5028746a39a5a4d26b8bd0f7a9d41991049aff5eed08bb267d3b3bfea09",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:6bccafaa-7e82-4cc6-9eaa-aaf36eafa6d0",
            "event_time": "2023-05-17 16:40:45",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "bb78b1c162b8d3094c9c534f7e9c1e38e9d6bf9ad17bf22099f59c1d3093fa37": {
            "question": "### Question 1: Computing the greatest common divisor\n\n\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.\n",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n\n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n\n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if (0 in [a, b]):\n\n        return max(a, b)\n\n    common_divisor = None\n\n    for divisor in range(1, min(a, b) + 1):\n\n        if (a % divisor == 0) and (b % divisor == 0):\n\n            common_divisor = divisor\n\n    return common_divisor\n",
            "diff_index": 2,
            "id": 2151,
            "person_id": "bb78b1c162b8d3094c9c534f7e9c1e38e9d6bf9ad17bf22099f59c1d3093fa37",
            "submission_id": "afa6cc9898750cb9e83c01977685889faaf7210a932b350df2c36c3239ce0833",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:cb3ce5f8-ec24-4944-83b6-671acbe0f675",
            "event_time": "2023-05-17 17:10:58",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "89b278acf9077e36a25848570808806b4cdd6a69d6185d68fb1ff74b1385acd1": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a*b==0:\n\n        return max(a,b)\n\n    elif a>b:\n\n        return gcd(b, a%b)\n\n    else:\n\n        return gcd(a, b%a)\n\n    pass",
            "diff_index": 2,
            "id": 2153,
            "person_id": "89b278acf9077e36a25848570808806b4cdd6a69d6185d68fb1ff74b1385acd1",
            "submission_id": "f83eea8355c01d601009e89411ea9912a6803f7cd44a886c5aaed95b3586618f",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:a46e22cb-0c9e-4575-a992-295a430f4ecf",
            "event_time": "2023-05-17 18:32:40",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "dd2a6ee9cac6624c423475064cf0dbe9b7de12ee57efcff347dcadf34cf778e4": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    \n\n    # Invalid Input Case 1: Note the prompt requires that the inputs are nonnegative\n\n    if a<0 or b<0:\n\n        print('Please input two positive integers\\n')\n\n        return -1\n\n    \n\n    # Invalid Input Case 2: Note that the gcd of 0 and 0 is undefined\n\n    if a==0 and b==0:\n\n        print('The greatest common divisor of 0 and 0 does not exist\\n')\n\n        return -2\n\n    \n\n    # Trivial Case 1: If only one of a and b are 0, the opposite\n\n    # is the greatest common divisor\n\n    if a==0:\n\n        return b\n\n    elif b==0:\n\n        return a\n\n    \n\n    # Trivial Case 2: If a and b are identical but not 0, then the\n\n    # greatest common divisor will be that number\n\n    if a == b:\n\n        return a\n\n    \n\n    # Otherwise, we need to first determine the minimum of a and b\n\n    if a<b:\n\n        min = a\n\n    else:\n\n        min = b\n\n    \n\n    # We proceed by checking for any number from min to 2 if there\n\n    # is a common number that divides both a and b, as this will\n\n    # be the greatest common divisor. If none exists, the gcd is 1.\n\n    \n\n    # Note this is not an efficient solution for this problem, \n\n    # it just requires minimial lines of code\n\n    \n\n    gcd = 1\n\n    for i in range(min, 1, -1):\n\n        if a%i==0 and b%i==0:\n\n            gcd = i\n\n            break\n\n        else:\n\n            continue\n\n            \n\n    return gcd\n\n    \n\n    \n\n    ",
            "diff_index": 2,
            "id": 2157,
            "person_id": "dd2a6ee9cac6624c423475064cf0dbe9b7de12ee57efcff347dcadf34cf778e4",
            "submission_id": "ac1007155d93ee380030e4f76a987130c0405fbab237898191c9a5f953ff4692",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:381dca05-c729-46b1-a818-eed9019b8490",
            "event_time": "2023-05-17 20:47:05",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "315f40cd2616367e40846131678f14f40982028bba68f9791cc09cb47402b43a": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a == 0:\n\n        return b\n\n    elif b == 0:\n\n        return a\n\n    elif a > b:\n\n        return gcd(a-b, b)\n\n    else:\n\n        return gcd(a, b-a)\n\n    pass",
            "diff_index": 2,
            "id": 2158,
            "person_id": "315f40cd2616367e40846131678f14f40982028bba68f9791cc09cb47402b43a",
            "submission_id": "9953ae2bd1e8969984cbaa7a1bfab34047ca5f868dc5da95e15649c158e43ccc",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:385b67b5-6815-4246-b132-562837968f36",
            "event_time": "2023-05-18 09:19:33",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "82028d78b89f693ce3f7cbf298f40d26e81ddeb769b8eaf760cd8a9e3b7b5c51": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n\n\n    if (a == 0):\n\n      return b\n\n    elif (b == 0):\n\n      return a\n\n    elif (b%a==0 or a%b==0):\n\n      return min(a,b)\n\n    else:\n\n      temp1 = 0\n\n      temp2 = 0\n\n      diff = 0\n\n      if (a>b):\n\n        temp1 = a\n\n        temp2 = b\n\n      else:\n\n        temp1 = b\n\n        temp2 = a\n\n      diff = temp1 - (temp2*(temp1//temp2))\n\n      if (temp2%diff == 0):\n\n        return diff\n\n      else:\n\n        return 1\n\n\n\n    pass",
            "diff_index": 2,
            "id": 2159,
            "person_id": "82028d78b89f693ce3f7cbf298f40d26e81ddeb769b8eaf760cd8a9e3b7b5c51",
            "submission_id": "49341bba4cfae8e78b5dccba243aea81f991de18dd9a181b3f1692ceeebe539d",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:b2076d36-ae61-4af1-afec-dc937cb9af6e",
            "event_time": "2023-05-18 10:40:45",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "9558865d3da37aee18bf01448dcfc3675e51c4b0c281fd4988d3ad1bb462577c": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    #get min\n\n   # Min = min(a,b);\n\n    \n\n    # if the min if the two numbers are both zero, the Min\n\n    # from above is the gcd\n\n    if b == 0:\n\n        return a\n\n    return gcd(b, a%b)\n\n    \n\n    \n\n    ",
            "diff_index": 2,
            "id": 2160,
            "person_id": "9558865d3da37aee18bf01448dcfc3675e51c4b0c281fd4988d3ad1bb462577c",
            "submission_id": "e6fcf5d88af01a0840d6a0dc8c1b567fcbd301c9a0fec0f5b214b6cd75d96827",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:fa7d0941-aec5-42c6-a752-06293b6f6eac",
            "event_time": "2023-05-18 21:24:36",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "865e6cd64b2141578cfd795d6400f9f6114426112bc825baef1da87ce9c70aee": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a%b==0:\n\n        return b\n\n    if b%a==0:\n\n        return a\n\n    m=min(a,b)\n\n    ans=0\n\n    for i in range(1,m):\n\n        if (a%i==0) and (b%i==0):\n\n            ans=i\n\n    return ans",
            "diff_index": 2,
            "id": 2161,
            "person_id": "865e6cd64b2141578cfd795d6400f9f6114426112bc825baef1da87ce9c70aee",
            "submission_id": "684ee8bc54c8aea80fe5b977511a9a5a85b3bf386c50aece850da6b529812515",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:6df1bdb9-c510-4680-994e-61cc1e3b42fa",
            "event_time": "2023-05-19 02:05:55",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "2f62b30a336d58eb746cbb7acfbe72d46621d58d0722b697e22867025f4187d8": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n\n\n    # return the other integer if one of them is 0\n\n    if a == 0:\n\n        return b\n\n    if b == 0:\n\n        return a\n\n\n\n    # return if one of the number is the divosor of another\n\n    if a % b == 0:\n\n        return b;\n\n    if b % a == 0:\n\n        return a\n\n\n\n    # calculate the greatest common divisor if none of the above cases exist\n\n    while a >= 0 & b >= 0:\n\n      # use the larger number to minus the smaller number\n\n      if a > b:\n\n        a = a - b\n\n      elif a < b:\n\n        b = b - a\n\n      else:\n\n        # return the greatest common divisor if a == b\n\n        return a\n\n    \n\n    ",
            "diff_index": 2,
            "id": 2162,
            "person_id": "2f62b30a336d58eb746cbb7acfbe72d46621d58d0722b697e22867025f4187d8",
            "submission_id": "7ce566faac6d7af5ce8ffb0a0d63cefc48e34fcd725035e22fbad763ff84ca4a",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:476f8737-cc39-4a9b-8ffa-26892d01db87",
            "event_time": "2023-05-19 02:13:10",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "bf314980fa0ae5e7e07c9dcf34eed5eb911ad78fd8b42ed81d821cb5747725d8": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    # by Euclidean algorithm\n\n    if a > b:\n\n        big, small = a, b\n\n    else:\n\n        big, small = b, a\n\n\n\n    while small:\n\n        big, small = small, big % small\n\n\n\n    return big",
            "diff_index": 2,
            "id": 2163,
            "person_id": "bf314980fa0ae5e7e07c9dcf34eed5eb911ad78fd8b42ed81d821cb5747725d8",
            "submission_id": "0f790ecb2096013bf625881451e4a38b89e2946146f1ffd7d237ce32da4f1aae",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:20cfda61-dea2-46b4-9d77-c0cc9ac1023e",
            "event_time": "2023-05-19 03:37:10",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "f5c58761ed0a279bd9633d20ee74484fb85494e409d810b78fa83d39cc34d885": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a==0:\n\n        return b\n\n    if b==0:\n\n        return a\n\n    return gcd(b, a%b)",
            "diff_index": 2,
            "id": 2164,
            "person_id": "f5c58761ed0a279bd9633d20ee74484fb85494e409d810b78fa83d39cc34d885",
            "submission_id": "555897da574a61b8354d48d0c929048cf3295022b35fed643846c98e9e32c46e",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:1d6d1d06-8b70-4298-817f-96fe039122b1",
            "event_time": "2023-05-19 04:19:00",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "caca2566bff4c788833ee1360ce9fc74d00bcf24e4d37eed018e46ea26dfbcc4": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a > b:\n\n      for i in range(a, 1, -1):\n\n        if (a % i) == 0 and (b % i) == 0:\n\n          return i\n\n      return 1\n\n    else:\n\n      for i in range(b, 1, -1):\n\n        if (a % i) == 0 and (b % i) == 0:\n\n          return i\n\n      return 1",
            "diff_index": 2,
            "id": 2168,
            "person_id": "caca2566bff4c788833ee1360ce9fc74d00bcf24e4d37eed018e46ea26dfbcc4",
            "submission_id": "2e0422abf0a76ae5ce479795d9e7eb7b725cddb91d5e69b37023892944eff2c7",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:42fc217f-0000-480c-a295-bc5813fb4fc8",
            "event_time": "2023-05-19 09:42:01",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "6f10071b8ad2b3f8d456a8f4ee963f654148c3c34f66c278a108e7672de1a6d7": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a == 0:\n\n        return b\n\n    if b == 0:\n\n        return a\n\n    return gcd(b, a % b)",
            "diff_index": 2,
            "id": 2170,
            "person_id": "6f10071b8ad2b3f8d456a8f4ee963f654148c3c34f66c278a108e7672de1a6d7",
            "submission_id": "5146c72b698cefa3acb284ac2f862f7d9a9ee8a65efd67392e3984084e3b2209",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:83d8fb5c-6536-4ac7-8565-1190bdf9dea0",
            "event_time": "2023-05-19 14:31:41",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "608b98bf2688b0972cf99229ad2b6d1d3710ae9c0c162b3b61a9f2aaee48aac8": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    while b != 0:\n\n        a, b = b, a % b\n\n    return a",
            "diff_index": 2,
            "id": 2172,
            "person_id": "608b98bf2688b0972cf99229ad2b6d1d3710ae9c0c162b3b61a9f2aaee48aac8",
            "submission_id": "973fcc2ad2cbd67170401d3645a70da9ab3ff237e8dc33eca5d1a0ddf9e298ff",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:6eb5d81b-69b2-4ff0-b875-ca371b849526",
            "event_time": "2023-05-19 14:55:29",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "d7954a735f3c35198e1d53b06469523b8c9bd5de31e54d772206044d6d749f4f": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a == 0 or b == 0:\n\n        return a if b == 0 else b\n\n\n\n    primes_a = prime_factorization(a)\n\n    primes_b = prime_factorization(b)\n\n\n\n    gcd = 1\n\n    for prime in primes_a:\n\n        if prime not in primes_b:\n\n            continue\n\n        gcd = gcd * (prime ** min(primes_a[prime], primes_b[prime]))\n\n    \n\n    return gcd\n\n\n\n\n\ndef prime_factorization(x):\n\n    \"\"\"\n\n    Computes the prime factorization of a given integer.\n\n    Returns a dictionary with keys = prime numbers and values = exponents of that prime number in the prime factorization.\n\n    \"\"\"\n\n    results = {}\n\n\n\n    div = 2\n\n    while div <= x:\n\n        if x % div == 0:\n\n            results[div] = results[div] + 1 if div in results else 1\n\n            x = x / div\n\n        else:\n\n            div += 1\n\n\n\n    return results",
            "diff_index": 2,
            "id": 2173,
            "person_id": "d7954a735f3c35198e1d53b06469523b8c9bd5de31e54d772206044d6d749f4f",
            "submission_id": "bdc865841399ab07bf46d03c5d851eaf489b42970171e11639dd458d041b590e",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:ad38ba4c-be80-4c3b-87dd-77078a323845",
            "event_time": "2023-05-19 19:51:55",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "431d3a8df9b3c144bd4fe89162220ef2cffb7804f6f40111b850afbe85062b56": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if (a == 0):\n\n      return b\n\n    if (b == 0):\n\n      return a\n\n    if (a > b):\n\n      smaller = b\n\n    else:\n\n      smaller = a\n\n    gcd = 1\n\n    for divisor in range(2,smaller+1):\n\n      if (a%divisor == 0 and b%divisor == 0 and divisor>gcd):\n\n        gcd = divisor\n\n    return gcd",
            "diff_index": 2,
            "id": 2174,
            "person_id": "431d3a8df9b3c144bd4fe89162220ef2cffb7804f6f40111b850afbe85062b56",
            "submission_id": "3df5c73a5ba8e20ef23cba416aea06ed6bb385245aa36c595c12ba36385c07e8",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:46e70a35-ca99-4aa9-b47f-4a892c039687",
            "event_time": "2023-05-19 20:29:32",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "7d94b7729e1d005dd3fcfa701477f129dfb718bd28a895dc3fc0cc15c48aade5": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if(b==0): return a\n\n    else: return gcd(b, a%b)\n\n\n\n    pass",
            "diff_index": 2,
            "id": 2175,
            "person_id": "7d94b7729e1d005dd3fcfa701477f129dfb718bd28a895dc3fc0cc15c48aade5",
            "submission_id": "051c41cc987acdf7625c313c70deaa2bc21853b7855b03bf4dcaf7856aa366f1",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:7d1eed43-cd32-4111-93fb-a1647244fead",
            "event_time": "2023-05-20 03:24:09",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "d6ff356b1314b42034b11f843492415ad8b04fb16c5ab9b11e76a9016280e462": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n\n\n    if b:\n\n        return gcd(b, a%b)   \n\n    else:\n\n        return a\n",
            "diff_index": 2,
            "id": 2178,
            "person_id": "d6ff356b1314b42034b11f843492415ad8b04fb16c5ab9b11e76a9016280e462",
            "submission_id": "740d15c96ca29826e2b5aebe09326ee25ef2e51264cdf0313f41434cc54c668f",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:f7572ed1-e8a4-4503-9eb0-9b0265bfa44c",
            "event_time": "2023-05-20 06:59:43",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "532d0da52f174ff17d007c0aa64d1d0bf90c5385d972548554fe7b42245c7891": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    import math\n\n    ab_min, ab_max = min(a, b), max(a, b)\n\n\n\n    if ab_min == 0:\n\n        return ab_max\n\n    \n\n    divisors = set()\n\n    \n\n    for x in range(1, math.floor(math.sqrt(ab_min))+1):\n\n        gcd_candidate = ab_min // x\n\n        if ab_min % gcd_candidate == 0 and ab_max % gcd_candidate == 0:\n\n            return gcd_candidate\n\n        elif ab_min % x == 0 and ab_max % x == 0:\n\n            divisors.add(x)\n\n    return min(divisors)",
            "diff_index": 2,
            "id": 2180,
            "person_id": "532d0da52f174ff17d007c0aa64d1d0bf90c5385d972548554fe7b42245c7891",
            "submission_id": "9468e553cb29da3e130777c703da661527a53ad4da8b8d94eb4d4a8dbdf931de",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:c85da85c-9660-4a39-a72d-066c78f6c292",
            "event_time": "2023-05-20 14:32:23",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "26fe6267831b0e237f66bd7ea0df7d559012660f7f8ea9c160813eb8104af6a6": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "from prompt_toolkit.shortcuts.prompt import E\n\ndef gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a==0 or b==0:\n\n      if a==0:\n\n        return b\n\n      else:\n\n        return a\n\n    elif a>b:\n\n      if a%b == 0:\n\n        return b\n\n      elif b>1:\n\n        return gcd(a-b,b)\n\n      else:\n\n        return 1\n\n    else:\n\n      if b%a == 0:\n\n        return a\n\n      elif a>1:\n\n        return gcd(a,b-a)\n\n      else:\n\n        return 1",
            "diff_index": 2,
            "id": 2181,
            "person_id": "26fe6267831b0e237f66bd7ea0df7d559012660f7f8ea9c160813eb8104af6a6",
            "submission_id": "77c911045b014bf38bc74bc3ddb726346b0d7327d529c76eaf29168dcb98e3c3",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:c3b69a2a-beb3-46be-a630-cf6869ac013e",
            "event_time": "2023-05-20 14:33:36",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "ca9f84a987fe35943e20e74b898acecb263ff8a5b947566ec0700f3e3265275a": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a == 0:\n\n      return b\n\n    if b == 0:\n\n      return a\n\n    if a > b:\n\n      return gcd(b, a)\n\n    if b % a == 0:\n\n      return a\n\n    return gcd(b%a, a)",
            "diff_index": 2,
            "id": 2184,
            "person_id": "ca9f84a987fe35943e20e74b898acecb263ff8a5b947566ec0700f3e3265275a",
            "submission_id": "5ea9086056d4d6f85cd063624e155df1ca404adf7710407565082347a410a3fe",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:9a2f401f-06b4-4191-b2f2-894dc34a8f5c",
            "event_time": "2023-05-20 17:25:42",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "c46ef2ed3312ebd7bb9ea8aeb58f2860227f6d759389a43d7c76424e1f0172a7": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a==b:\n\n      return a\n\n    elif a>b:\n\n      a,b = b,a\n\n    if a==0:\n\n      return b\n\n    for i in range(a, 0, -1):\n\n      if(a%i ==0 and b%i==0):\n\n        return i\n",
            "diff_index": 2,
            "id": 2185,
            "person_id": "c46ef2ed3312ebd7bb9ea8aeb58f2860227f6d759389a43d7c76424e1f0172a7",
            "submission_id": "3bfdc989f21bcef75097a1635d19ab475ecc1b9d777528ec09f04fe0ff8e67be",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:96cb861a-255a-439b-bc00-4d202c58bba7",
            "event_time": "2023-05-20 20:07:59",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "8673740ea1c42996565a5bfdf21af5b69e8d014adcea037867ee8e587d625575": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    while (b):\n\n        a, b = b, a % b\n\n    a = abs(a)\n\n    return a",
            "diff_index": 2,
            "id": 2186,
            "person_id": "8673740ea1c42996565a5bfdf21af5b69e8d014adcea037867ee8e587d625575",
            "submission_id": "5ae690c8c9afbe10450b9e0b8c4198447083a40ca04bd00bd48d0c2a68294a39",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:24b4b9b0-346b-48c9-8255-1236df8e7b86",
            "event_time": "2023-05-20 20:32:01",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "09a5e978000ed845af1b76ea4bfa5039afe72d48807045281dcb055b9b015121": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    # If any of the inputs is zero, gcd is the higher number\n\n    if (a == 0) or (b == 0):\n\n        if a >= b:\n\n            return a\n\n        else:\n\n            return b\n\n    # If both inputs are equal, gcd is equal to both\n\n    elif a == b:\n\n        return a\n\n    # If both numbers are unequal set dividend to higher number and divisor to lower number\n\n    elif a > b:\n\n        divisor, dividend = b, a\n\n    elif a < b:\n\n        divisor, dividend = a, b\n\n    # Continue dividing dividend by divisor till remainder is zero\n\n    # When remainder becomes zero, divisor is equal to gcd\n\n    while True:\n\n        remainder = dividend % divisor\n\n        if remainder == 0:\n\n            break\n\n        else:\n\n            dividend = divisor\n\n            divisor = remainder\n\n    return divisor\n\n    # pass",
            "diff_index": 2,
            "id": 2187,
            "person_id": "09a5e978000ed845af1b76ea4bfa5039afe72d48807045281dcb055b9b015121",
            "submission_id": "3a05d7058dc672d85fbc21fc12d6fc6515920e25fe978a3fcf8da36398a24341",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:e211c52e-1b67-4dfe-a542-a9c5a564d720",
            "event_time": "2023-05-20 21:47:51",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "1036ed10f6f968631ef4569d77606ed1ce5cd59cabf859592b9292ce3d4475d3": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a == 0 or b == 0:    # zero can be divided by any integer\n\n        return max(a, b)\n\n    # Note that the gcd of two positive integers is in the range [1, min(a, b)] inclusive.\n\n    for i in range(min(a, b), 0, -1):\n\n        if a % i == 0 and b % i == 0:   # both a and b divisible by i\n\n            return i\n\n    raise RuntimeError(\"Unreachable code reached!\")",
            "diff_index": 2,
            "id": 2188,
            "person_id": "1036ed10f6f968631ef4569d77606ed1ce5cd59cabf859592b9292ce3d4475d3",
            "submission_id": "4499e282eee050a992a037a728c100f53a1e738471bf322c709d00ef905293b9",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:74f744af-18a0-4167-ba0f-e9724aa2fd9b",
            "event_time": "2023-05-20 23:44:17",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "2d0feac6abcacffb68be0fe61bebe2f197590907551389d3ce79fa0d51d93e2d": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n\n\n    if a == 0:\n\n        return b\n\n    return gcd(b%a, a)",
            "diff_index": 2,
            "id": 2189,
            "person_id": "2d0feac6abcacffb68be0fe61bebe2f197590907551389d3ce79fa0d51d93e2d",
            "submission_id": "c9278b0d3b15398f5f3cec08317e88914d330d81d02b98ace2f63e5bfa8df205",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:c0816670-66b4-421c-94f5-e961f8d4b055",
            "event_time": "2023-05-21 00:03:26",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "b1d9a27b449675fefaa3bb00dfaac7779f4120dc959c4beafbe82d9cd82b27c6": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a >= b:\n\n        if b == 0:\n\n            return a\n\n        return gcd(b, a % b)\n\n    else:\n\n        return gcd(b, a)",
            "diff_index": 2,
            "id": 2191,
            "person_id": "b1d9a27b449675fefaa3bb00dfaac7779f4120dc959c4beafbe82d9cd82b27c6",
            "submission_id": "63a830b3db41faa3429f6725c0a00bd57ca022036c55ae0aba2b8d34e972bc13",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:5204a846-8acc-45ce-91f7-922a9904603b",
            "event_time": "2023-05-21 08:02:29",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "fc1c35ee9dc8ff5e6798d0a009ad11f2d23ee48355c9820151532f976500ba7c": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    min_num = min(a,b)\n\n    if min_num == 0:\n\n      return max(a,b)\n\n    ans = 1\n\n    for i in range(1, min_num+1):\n\n      if a%i==0 and b%i==0:\n\n        ans = i\n\n    return ans",
            "diff_index": 2,
            "id": 2193,
            "person_id": "fc1c35ee9dc8ff5e6798d0a009ad11f2d23ee48355c9820151532f976500ba7c",
            "submission_id": "530375b8164864c3305dbb7e8957d8e55151f22328ce15199beae921b6f7b09c",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:42b47576-f231-48d6-8214-d003f6240d09",
            "event_time": "2023-05-21 10:41:58",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "1418a26151858c4666cc2545042cb187265a2b03e8d4124524e3c87b64b9a29d": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    n = max(a,b)\n\n    res=0\n\n    for i in range(1,n+1):\n\n        if (a%i==0 and b%i==0):\n\n            res=i\n\n            continue\n\n    return res ",
            "diff_index": 2,
            "id": 2194,
            "person_id": "1418a26151858c4666cc2545042cb187265a2b03e8d4124524e3c87b64b9a29d",
            "submission_id": "e5df754b4fae9a25c759da5f82173decf009d8c36e43fcb3f69064cbd93fe1c4",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:732d9bb0-c938-434b-bf48-2762b8a272d3",
            "event_time": "2023-05-21 10:47:22",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "9a8bf2d29d93e832e6059fda02be855f624a3701cdbeed6893b46a7b9f687dd2": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    a, b = max(a,b), min(a,b)\n\n    if b == 0: return a\n\n    elif b == 1 or a%b == 0:\n\n        return b\n\n    else:\n\n        return gcd(a%b, b)\n\n    pass",
            "diff_index": 2,
            "id": 2195,
            "person_id": "9a8bf2d29d93e832e6059fda02be855f624a3701cdbeed6893b46a7b9f687dd2",
            "submission_id": "0b52d5da30a62a2cbbf8d2c951dcc5e9939d0ddd642b13a23cf8b24e6cce3548",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:4edde4ee-b505-4b40-986f-f836cac0356c",
            "event_time": "2023-05-21 11:40:35",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "7cfd7af0c057229f8ab7eca2ad05f183635af2555acb01c863bc0aedbd1a2bc4": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    \n\n    if a > b:\n\n        a, b = b, a\n\n\n\n    # a is now greater than b\n\n    \n\n    while b != 0:\n\n        a, b = b, a % b\n\n\n\n    return a",
            "diff_index": 2,
            "id": 2196,
            "person_id": "7cfd7af0c057229f8ab7eca2ad05f183635af2555acb01c863bc0aedbd1a2bc4",
            "submission_id": "089b0b50f9c37e12e66dd914ef377f56d8787889ca588d48e83fe2b373c470e0",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:97645b69-4474-4c80-a500-147a8f0829ed",
            "event_time": "2023-05-21 12:04:30",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "1c0b732799b2bc0c8ca987fa3f688d6dbd2a0096229f65272ec081267cc324cd": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    gcd=1\n\n    m=max(a,b)\n\n    for i in range(2,m+1):\n\n        if a%i==0 and b%i==0:\n\n            gcd=i    \n\n    return gcd",
            "diff_index": 2,
            "id": 2198,
            "person_id": "1c0b732799b2bc0c8ca987fa3f688d6dbd2a0096229f65272ec081267cc324cd",
            "submission_id": "56c54154e7493601ab17ff439174f168f5d7079ff4bdebbde6942488bd5e0e31",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:266ee846-bac7-4981-8053-5e60585be494",
            "event_time": "2023-05-21 14:17:23",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "99e9a35b1323991749a653ff7a995532505210a03c803cca11b7034f9e7ce599": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if b == 0:\n\n        return a\n\n    return gcd(b, a%b)\n\n    pass",
            "diff_index": 2,
            "id": 2199,
            "person_id": "99e9a35b1323991749a653ff7a995532505210a03c803cca11b7034f9e7ce599",
            "submission_id": "ff1a5bd2bdf6cefbf76a24005514187c350fe6a47db8ecc5783cf7434eaf96da",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:86ec7caf-aa9e-41ac-8b1b-e4559ee607fd",
            "event_time": "2023-05-21 15:17:19",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "e04e7139e4147492ddd932aefe527b2a7c04427e542ea5492c572acbaf2acb15": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    while b != 0:\n\n        t = b\n\n        b = a % b\n\n        a = t\n\n    return a",
            "diff_index": 2,
            "id": 2200,
            "person_id": "e04e7139e4147492ddd932aefe527b2a7c04427e542ea5492c572acbaf2acb15",
            "submission_id": "81660228637d7920803dcd90de2e1fef6f970aef9c87ae98ca9b677a4b6d4e78",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:3ca1ece5-6937-4aa0-8625-ca8ed90d5987",
            "event_time": "2023-05-21 15:21:04",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "cf0459fe6a30034497deb6b9429e41e6b9cee56d6ce17a438d7acd7d55453ad5": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    if (a==0):\n\n        return b\n\n    elif (b==0):\n\n        return a\n\n    elif (a==b):\n\n        return a\n\n    else:\n\n        for x in range (min(a,b),0,-1):\n\n            if (a%x==0 and b%x==0):\n\n                return x",
            "diff_index": 2,
            "id": 2201,
            "person_id": "cf0459fe6a30034497deb6b9429e41e6b9cee56d6ce17a438d7acd7d55453ad5",
            "submission_id": "8c0b4d3ce55b4fc7716efbc52551c409ae5a50c7afe215632bd9668c4d8f35e2",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:c587531c-3176-45fb-95c5-d810f3fcb4c6",
            "event_time": "2023-05-21 17:07:05",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "4ecdfb127b80e6b66c2d06b2ad9c3e4fb8bdb245bce811303c87b79d660e1c63": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "\n\ndef gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a==0 or b==0:\n\n      return max(a,b)\n\n    # we just need to check up to the minimum number\n\n    min_range = min(a, b)\n\n\n\n    # default\n\n    j = 1\n\n    for k in range(2,min_range+1):\n\n      if a%k==0 and b%k==0:\n\n        j = k\n\n    return j\n",
            "diff_index": 2,
            "id": 2202,
            "person_id": "4ecdfb127b80e6b66c2d06b2ad9c3e4fb8bdb245bce811303c87b79d660e1c63",
            "submission_id": "bebb0718bd649141ce7e62055d9e7a3c343d92b6b2f28baef0e9eef25b6c656f",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:1ebb6d2d-89d8-4482-a154-8eab7cb1cdde",
            "event_time": "2023-05-21 17:42:38",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "8740f9d2f2c16780ca5b988d310c0fd42c1ecb3a8127d557f4418b9ce3fa1a8b": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a == 0:\n\n        return b\n\n    if b == 0:\n\n        return a\n\n\n\n    num = a\n\n    if a == b:\n\n        return num\n\n    elif b < a:\n\n        num = b\n\n    while(num > 0):\n\n        if a % num == 0 and b % num == 0:\n\n            return num\n\n        num = num - 1\n\n    return num",
            "diff_index": 2,
            "id": 2203,
            "person_id": "8740f9d2f2c16780ca5b988d310c0fd42c1ecb3a8127d557f4418b9ce3fa1a8b",
            "submission_id": "cfe238d642d3f2cbe4435e74475974e229e9dcc35a6fc3ef3e38c6f017a17c50",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:2e74f841-1143-4abb-8d66-2ca35a92368f",
            "event_time": "2023-05-21 18:41:52",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "8b4e99c6f0ef5b8d7cb2b7d04792a109647345798a96c62ab088dd1a0b241adb": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a == 0:\n\n      return b\n\n    if b == 0:\n\n      return a\n\n    a, b = max(a, b), min(a, b)\n\n    if a % b == 0:\n\n      return b\n\n    return gcd(b, a%b)",
            "diff_index": 2,
            "id": 2204,
            "person_id": "8b4e99c6f0ef5b8d7cb2b7d04792a109647345798a96c62ab088dd1a0b241adb",
            "submission_id": "699f3d2bc70579173b91483b221e5b61467a0db7c7c64b46856f09152c6ccfeb",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:3fe2f7a7-527e-487d-a0f2-c334febba929",
            "event_time": "2023-05-21 18:54:57",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "e3175b35e85a352c5f6ef895cfae7ef3c646f1876741f959544b9c6ffe0a6206": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a < b:\n\n        a, b = b, a\n\n    if b == 0:\n\n        return a\n\n\n\n    return gcd(b, a%b)\n",
            "diff_index": 2,
            "id": 2205,
            "person_id": "e3175b35e85a352c5f6ef895cfae7ef3c646f1876741f959544b9c6ffe0a6206",
            "submission_id": "8853e20a381073378e48ed24c367e286bd6d67525e45d1cff12eb748e27b30e4",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:b3e2d395-9f42-4936-9631-0ec0264c274a",
            "event_time": "2023-05-21 20:41:37",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "62edec51d5547fbf55edbf40900066b654259107a00d468c919db438baba82d4": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n  if a > b:\n\n    swap = a \n\n    a = b\n\n    b = swap\n\n  diff= b-a\n\n  if a == 0 or b == 0:\n\n    return diff\n\n  if diff == 0:\n\n    return a\n\n  if a%diff == 0:\n\n    return diff\n\n  rem = b%a\n\n  if rem == 0:\n\n    return a\n\n  if a%rem!=0:\n\n    return 1\n\n  else:\n\n    return rem%a\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    pass",
            "diff_index": 2,
            "id": 2214,
            "person_id": "62edec51d5547fbf55edbf40900066b654259107a00d468c919db438baba82d4",
            "submission_id": "b00ab8635be7ad741021d5bfb0b24675ed8a98d16519b90977003bb742e5fff5",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:22c60a3f-4147-4812-aa68-40133e6eb615",
            "event_time": "2023-05-22 08:05:17",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "374a5796f41694e25c8ad74fd00d9e02d5f1aa10f122c43e39bbd7f3e4021933": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    max_divisor = 0\n\n    if(a>b):\n\n        higher = a\n\n    else:\n\n        higher = b\n\n    for i in range(1, higher+1):\n\n        if(a%i==0 and b%i==0):\n\n            max_divisor = i\n\n    return max_divisor",
            "diff_index": 2,
            "id": 2211,
            "person_id": "374a5796f41694e25c8ad74fd00d9e02d5f1aa10f122c43e39bbd7f3e4021933",
            "submission_id": "34a18b5cd6bf230c178041e7e75003f46830c9e4cdfc2ecbd5b52dac3f919c31",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:9b60ef54-f624-43f0-9206-bb3e57edb1a8",
            "event_time": "2023-05-22 03:15:50",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "f5d9bf79d2512460ca1ec79f48682c05c73494082f64897f1ddbeb0b048a750f": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a == 0:\n\n      return b\n\n    return gcd(b%a, a)\n\n    pass",
            "diff_index": 2,
            "id": 2212,
            "person_id": "f5d9bf79d2512460ca1ec79f48682c05c73494082f64897f1ddbeb0b048a750f",
            "submission_id": "6d236210f7dcb7e7a9a6ff610d49bc0b6e17f1cc5d359c470998e0c997a772e0",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:cec83895-6c60-4f51-901d-b2419648ce40",
            "event_time": "2023-05-22 05:14:24",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "2aa6eb65c9fa2438079521951a3bec70ef95a70a57bf71576e71eda0683518f4": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n  gcd=1\n\n  if a<b:\n\n    n=a\n\n    if a==0:\n\n      gcd=b\n\n  else:\n\n    n=b\n\n    if b==0:\n\n      gcd=a\n\n  for i in range (1,n+1):\n\n    if a%i==0:\n\n      if b%i==0:\n\n        if i>gcd:\n\n          gcd=i\n\n  return gcd\n",
            "diff_index": 2,
            "id": 2215,
            "person_id": "2aa6eb65c9fa2438079521951a3bec70ef95a70a57bf71576e71eda0683518f4",
            "submission_id": "3acafae9f39feff5f427a6ca18b977614db9a9e179a5f730a97183fe5da66d04",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:a6b8a64b-7750-4ea3-ad6b-95c32d69a059",
            "event_time": "2023-05-22 10:07:06",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "a5cc050a02bc05b25cf978e017cd8b322296febfde38485ad627d8e4184a7865": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"    \n\n    if a == 0 or b == 0:\n\n        gcd = b if a == 0 else a\n\n        return gcd\n\n    \n\n    min = a if a<=b else b\n\n        \n\n    for i in range(1, min+1):\n\n        if a%i == 0 and b%i == 0:\n\n            gcd = i\n\n    return gcd",
            "diff_index": 2,
            "id": 2216,
            "person_id": "a5cc050a02bc05b25cf978e017cd8b322296febfde38485ad627d8e4184a7865",
            "submission_id": "c4e83846d19ba77f3bc1707f328b1f63d602aafc1c9dd13d44b4d72eeccd0e42",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:e7332b78-93fe-4ce5-8b72-60c47b53bfed",
            "event_time": "2023-05-22 11:51:16",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "072512eaded8453707caab870344fe324db61b0d87e2c8c16e6470fee66f4923": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if b<a:\n\n        a,b=b,a\n\n    while b!=0:\n\n        a,b=b,a%b\n\n    return a",
            "diff_index": 2,
            "id": 2217,
            "person_id": "072512eaded8453707caab870344fe324db61b0d87e2c8c16e6470fee66f4923",
            "submission_id": "d3fc04cb234a2c9ba429ac8e3e28f7ddadac7d2a0504e5f4849a6798c3eefc0a",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:f6c4d32e-2216-4b77-b274-fa77f0515d16",
            "event_time": "2023-05-22 13:21:48",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "ff6b5e923ebca0eb769bec526de9d6c4a301fffaf30c3a09267babbe5cae5f61": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    \n\n    if b == 0:\n\n      return a\n\n    return gcd(b, a%b)\n\n\n\n    pass",
            "diff_index": 2,
            "id": 2218,
            "person_id": "ff6b5e923ebca0eb769bec526de9d6c4a301fffaf30c3a09267babbe5cae5f61",
            "submission_id": "c9cc8e787eb08ce2e75e6d5402777117118518dcf5aa13d0b5771b84940da988",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:43ec6e89-4f82-4d4c-99fd-5f47e34c1494",
            "event_time": "2023-05-22 14:11:11",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "d202ae94da1a7fa261256e0471ca794ec8b311a65403f01cf5c683fed963201d": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    ans = 1\n\n    for i in range(max(a,b)):\n\n        i = i+1\n\n        if a%i == 0 and b%i == 0:\n\n            ans = i\n\n    return ans",
            "diff_index": 2,
            "id": 2219,
            "person_id": "d202ae94da1a7fa261256e0471ca794ec8b311a65403f01cf5c683fed963201d",
            "submission_id": "af824b85f75a8b074b3f609bb140355037478f12a7ef439ae3000a93367c3eeb",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:41474640-e5ce-4d72-bf10-a2d0fcd0f604",
            "event_time": "2023-05-22 14:22:50",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "fd29b2f257538e5acd2751ff7511cb58cac275011a1aaa98ab1e090fadf1eb66": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    return a if b == 0 else gcd(b, a % b)",
            "diff_index": 2,
            "id": 2221,
            "person_id": "fd29b2f257538e5acd2751ff7511cb58cac275011a1aaa98ab1e090fadf1eb66",
            "submission_id": "c520309d466bf002aadffaf361042ae47e7c711eee3e1342e1fff5904ce8eb5a",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:f1683689-d755-43da-a347-9f1678940553",
            "event_time": "2023-05-22 16:03:08",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "65008cf17265ab6622032f7f3414976086557542bd51c0ff770f2ddfc936bb79": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if a == 0: return b\n\n    if b == 0: return a\n\n    return gcd(b, a%b)",
            "diff_index": 2,
            "id": 2223,
            "person_id": "65008cf17265ab6622032f7f3414976086557542bd51c0ff770f2ddfc936bb79",
            "submission_id": "c6993588fdcba9f320d2df6ad269c6f88ba6ecb6c2705f5985322e69ce048936",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:41b7460c-8df7-4a13-b648-54eb44b2e917",
            "event_time": "2023-05-22 20:04:14",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "c5324c71931c07fa0c65d1feda8a284de2c12b4ecafa63e1e7b7fe83f86406be": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    \n\n    while b != 0:\n\n        a, b = b, a % b\n\n    return a",
            "diff_index": 2,
            "id": 2225,
            "person_id": "c5324c71931c07fa0c65d1feda8a284de2c12b4ecafa63e1e7b7fe83f86406be",
            "submission_id": "2830a1862ebf15bbaf6864b44bba4671aadcd91fe43c5dbcdce0efdf57ca0321",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:94f50530-0ba3-422b-acc1-2205e44381c3",
            "event_time": "2023-05-22 21:31:39",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "5170cab5679bd5da6e8216e24d4434f92a1becd5cbcc1b72dc1a2f50929b8a1c": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    r = a % b\n\n    if (r != 0):\n\n      return gcd(b,r)\n\n    else:\n\n      return b\n\n    pass",
            "diff_index": 2,
            "id": 2226,
            "person_id": "5170cab5679bd5da6e8216e24d4434f92a1becd5cbcc1b72dc1a2f50929b8a1c",
            "submission_id": "25b3f83986ee57149e580da9ec338e0f41a04b86aae1e07b39878f56a2ef0b90",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:a9c82763-ffff-4d3c-904d-4202fd937e48",
            "event_time": "2023-05-22 21:39:12",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "bd2d1bd5242e41af56777b7c4d7422247a3c1ea77aa6222b70fde26153168dd1": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    #gcd=1\n\n    if a==b:\n\n      gcd = a\n\n    if a==0:\n\n      gcd = b\n\n    elif b==0:\n\n      gcd = a\n\n    else:\n\n      for i in range(1,b):\n\n        if a%i == 0 and b%i ==0:\n\n          gcd = i\n\n          #print(i)\n\n    return gcd",
            "diff_index": 2,
            "id": 2229,
            "person_id": "bd2d1bd5242e41af56777b7c4d7422247a3c1ea77aa6222b70fde26153168dd1",
            "submission_id": "6e8be56a4432239375e446835270133da45f32158563673c40a93d328642aae9",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:c2bee43b-ef20-4af0-a2b0-5d1eb68a93ce",
            "event_time": "2023-05-22 23:35:36",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "eb132361504d91ef94cbcdf1c8d86426d9a1fc1b570377befcd33ae4656f6126": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    rem = 1;\n\n    if a==0:\n\n        return b\n\n    if b==0:\n\n        return a\n\n    if a>b:\n\n        while(rem!=0):\n\n            rem = a%b\n\n            if rem != 0:\n\n               a = b\n\n               b = rem\n\n        return b\n\n    else:\n\n        while(rem!=0):\n\n            rem = b%a\n\n            if rem != 0:\n\n               b = a\n\n               a = rem\n\n        return a\n\n           \n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    # pass",
            "diff_index": 2,
            "id": 2230,
            "person_id": "eb132361504d91ef94cbcdf1c8d86426d9a1fc1b570377befcd33ae4656f6126",
            "submission_id": "283b0d5d0118768d6819200d9b774c4af94fdd9dcfa50a7009d028b22fda4cdf",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:3c02fe9c-c8b7-42ec-8257-d657dc365ad9",
            "event_time": "2023-05-23 01:07:14",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "59e681cf2ea9056593501dfa5592cf6fd0e08bc78b9a67cb9c10a8d4f9b75c7e": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    if b > 0:\n\n      return gcd(b, a % b)\n\n    else:\n\n      return a",
            "diff_index": 2,
            "id": 2232,
            "person_id": "59e681cf2ea9056593501dfa5592cf6fd0e08bc78b9a67cb9c10a8d4f9b75c7e",
            "submission_id": "8389b8b42d049f29815946e259b9902853c64e4a8290351a16b45ead3995d927",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:4ae740a0-27ca-48ac-80f8-cc8d81066917",
            "event_time": "2023-05-23 02:28:02",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "209b28e0a036ccad370084151d60241a0e7193980eb45634d90beb2b71f246d3": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    import math\n\n    return math.gcd(a,b)\n\n    pass",
            "diff_index": 2,
            "id": 2235,
            "person_id": "209b28e0a036ccad370084151d60241a0e7193980eb45634d90beb2b71f246d3",
            "submission_id": "bb2e24b62c2eb172e117c6090131a8d2a74e1ba6c6c06679bdfa0da17b90679d",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:e986afd0-b77e-4a03-ba08-8c4dae70d8be",
            "event_time": "2023-05-23 03:04:29",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "0e7ad91c633cf5126e02bcc5a37d746b869fde0d3faef764a8f1e3b9cf060226": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    while b != 0:\n\n        a, b = b, a % b\n\n    return a",
            "diff_index": 2,
            "id": 2239,
            "person_id": "0e7ad91c633cf5126e02bcc5a37d746b869fde0d3faef764a8f1e3b9cf060226",
            "submission_id": "9399c29cdce78db52ebf4fcfcdd1da80a6450a894ebbcb6fdca6c81d4bb17d00",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:72322663-e6d2-4cfa-bab3-32c7c1f8d52c",
            "event_time": "2023-05-23 03:29:16",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        },
        "7604d84f9376ffbcd4327ea4d6d8b8e9791303f9c0c33ea6363405472590acd5": {
            "question": "### Question 1: Computing the greatest common divisor\n\nImplement the function `gcd(a,b)` that takes as input two non-negative integers `a` and `b` (where `a + b > 0`) and outputs their greatest common divisor.",
            "answer": "def gcd(a, b):\n\n    \"\"\"\n\n    Compute the greatest common divisor of two integers.\n\n    \n\n    args:\n\n        a (int) : the first integer\n\n        b (int) : the second integer\n\n    \n\n    return:\n\n        int : the greatest common divisor of a and b.\n\n    \"\"\"\n\n    d = min(a, b)\n\n    if d == 0:\n\n        return max(a, b)\n\n\n\n    while(a%d != 0 or b%d != 0):\n\n        d = d - 1\n\n    return d",
            "diff_index": 2,
            "id": 2240,
            "person_id": "7604d84f9376ffbcd4327ea4d6d8b8e9791303f9c0c33ea6363405472590acd5",
            "submission_id": "736feeedbb7d178913a49afda49931b7790522393ff5ce156bff30f1b980aeef",
            "module_name": "Getting Started",
            "module_slug": "project-learn-getting-st-h6ozxlcn",
            "task_name": "Develop Python solutions using Jupyter Notebook",
            "task_slug": "b31229d9-599f-4846-ba95-6d094b3fca8d",
            "event_id": "urn:id:8780353d-d5a1-48f2-8efa-7c55a00e1f78",
            "event_time": "2023-05-23 03:32:55",
            "module_date_to_activate": "2023-05-16 04:00:01",
            "module_date_to_submit": "2023-05-23 03:59:00",
            "score_obtained": "35.0"
        }
    },
    "Build website backend": {
        "d1e53d3a2824cb135e1452ad8089fcf3ac692aa25f3d0196548d15f531833c4d": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 726,
            "person_id": "d1e53d3a2824cb135e1452ad8089fcf3ac692aa25f3d0196548d15f531833c4d",
            "submission_id": "7cada22301bcefade9ec08c2fe575a9dcef04a5cf41b94008db768980e4d3c4c",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-tr6c35s8",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:d5bf48ec-caf7-43da-8f19-869fec23eaf2",
            "event_time": "2023-01-30 00:41:21",
            "module_date_to_activate": "2023-01-29 05:01:00",
            "module_date_to_submit": "2023-02-05 04:59:59",
            "score_obtained": "30.0"
        },
        "16bc75e33edbc348401f0231489762b5197294504195b20410193cf4d9a0cc78": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        self.recent_rams = []\n\n        self.recent_disk = []\n\n        \n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        # raise NotImplementedError(\"Complete this function!\")\n\n        ram = self.get_from_ram_cache(new_text)\n\n        if ram:\n\n          predicted = self.get_from_ram_cache(new_text)\n\n          self.recent_rams.append((new_text, predicted))\n\n          return predicted\n\n\n\n        disk = self.get_from_disk_cache(new_text)\n\n        if disk:\n\n          predicted = disk\n\n          self.recent_disk.append((new_text, predicted))\n\n          return predicted\n\n\n\n        rating = Cache.get(self,new_text)\n\n        if self.ram_max == self.ram_size():\n\n          if self.disk_max == self.disk_size():\n\n            least_recent_cache = self.recent_disk[0][0]\n\n            self.remove_from_disk_cache(least_recent_cache)\n\n            self.recent_disk.pop(0)\n\n          least_recent_ram = self.recent_rams[0][0]\n\n          least_recent_ram_rating = self.recent_rams[0][1]\n\n          self.remove_from_ram_cache(least_recent_ram)\n\n          self.add_to_disk_cache(least_recent_ram, least_recent_ram_rating)        \n\n          self.recent_rams.pop(0)\n\n\n\n        self.add_to_ram_cache(new_text, rating)\n\n        self.recent_rams.append((new_text, rating))\n\n        self.recent_disk.append((new_text, rating))\n\n\n\n        return rating\n\n\n\n\n\n\n",
            "diff_index": 56,
            "id": 762,
            "person_id": "16bc75e33edbc348401f0231489762b5197294504195b20410193cf4d9a0cc78",
            "submission_id": "4bb5c388588d66c1e41f02e193c53f9495f54f64a246cb51a8f55b20cede2645",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-tr6c35s8",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:fb669af0-2cda-4755-a407-14dbb57986d1",
            "event_time": "2023-02-04 01:50:28",
            "module_date_to_activate": "2023-01-29 05:01:00",
            "module_date_to_submit": "2023-02-05 04:59:59",
            "score_obtained": "95.0"
        },
        "0a9441e8caa84325ce6dececee4b003fc1d2b94676347d8426caefc375784a48": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 765,
            "person_id": "0a9441e8caa84325ce6dececee4b003fc1d2b94676347d8426caefc375784a48",
            "submission_id": "453af2ec95b9fdace4cd26138ac59e35aada83b61c110ec6492615913d8b2ecd",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-tr6c35s8",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:dfd33444-6162-41bf-b5d3-e316b2e544a9",
            "event_time": "2023-02-04 02:45:06",
            "module_date_to_activate": "2023-01-29 05:01:00",
            "module_date_to_submit": "2023-02-05 04:59:59",
            "score_obtained": "65.0"
        },
        "1e766457eb034a06ba8a2b65e5cc55c7ccbc3f51a05f50969ac44e74a2cd36db": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 739,
            "person_id": "1e766457eb034a06ba8a2b65e5cc55c7ccbc3f51a05f50969ac44e74a2cd36db",
            "submission_id": "f1c17c5f02cf80561ab95db4a09fb92864a2e655f35fa056ea72f596c6ecb25d",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-tr6c35s8",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:e02e32ef-3754-4bb1-a4c3-795ece4a9122",
            "event_time": "2023-02-02 04:06:09",
            "module_date_to_activate": "2023-01-29 05:01:00",
            "module_date_to_submit": "2023-02-05 04:59:59",
            "score_obtained": "0.0"
        },
        "b29de73eb4903b487679e2c2831a24bfff7f46fa965b50f997e59e69fd6c070b": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "from collections import OrderedDict\n\nclass MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        # initialize additional fields here\n\n        self.cache_ram = OrderedDict()\n\n\n\n        \n\n    def get(self, new_text):\n\n        rating = self.get_from_ram_cache(new_text)\n\n        if rating:\n\n            self.cache_ram.move_to_end(new_text)\n\n            return rating\n\n        \n\n        rating = self.get_from_disk_cache(new_text)\n\n        if rating:\n\n            self.remove_from_disk_cache(new_text)\n\n            self.add_to_disk_cache(new_text, rating)\n\n            return rating\n\n        \n\n        predicted_rating = predict(new_text)\n\n        if self.ram_size() == self.ram_max:\n\n            if self.disk_size() == self.disk_max:\n\n                with open(self.cache_disk, \"r\") as f:\n\n                    lines = f.readlines()\n\n                with open(self.cache_disk,\"w\") as f:\n\n                    for line in lines[1:]:\n\n                        review_rating_pair = line.replace('\\n', '').split(' ')\n\n                        f.write(line)\n\n            removed_item = self.cache_ram.popitem(False)\n\n            self.add_to_disk_cache(removed_item[0], removed_item[1])\n\n        self.add_to_ram_cache(new_text, predicted_rating)\n\n        return predicted_rating\n\n        # raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 772,
            "person_id": "b29de73eb4903b487679e2c2831a24bfff7f46fa965b50f997e59e69fd6c070b",
            "submission_id": "ac04b115800111bd545e17a1b43b722700a1005c20f0cd69f8768177870a164f",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-tr6c35s8",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:cbbc6dc7-b753-459c-b9f2-11d8df4fe156",
            "event_time": "2023-02-04 19:47:11",
            "module_date_to_activate": "2023-01-29 05:01:00",
            "module_date_to_submit": "2023-02-05 04:59:59",
            "score_obtained": "95.0"
        },
        "717aa2afc8b2093fa507767616743a43abf54d168c3f2f17dd7614de39a115c5": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 744,
            "person_id": "717aa2afc8b2093fa507767616743a43abf54d168c3f2f17dd7614de39a115c5",
            "submission_id": "e6f3fd4faaa5cf4c66a5cb546b0fdb909194cc2014742c2a1042723582a03f9f",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-tr6c35s8",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:e0b622b0-6f02-4c51-968d-349191003310",
            "event_time": "2023-02-03 02:45:08",
            "module_date_to_activate": "2023-01-29 05:01:00",
            "module_date_to_submit": "2023-02-05 04:59:59",
            "score_obtained": "0.0"
        },
        "b477c1c79d053afa4062b01ac3c2520ed2d8146de6fec21b6ebd0ee6df404e81": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 768,
            "person_id": "b477c1c79d053afa4062b01ac3c2520ed2d8146de6fec21b6ebd0ee6df404e81",
            "submission_id": "bfbbe1283138e3a8509ac52d1ddfbbeb1fba60474df91e190ac650cc36047c7c",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-tr6c35s8",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:eff20e09-b776-4af4-8c19-19e3f92f0017",
            "event_time": "2023-02-04 13:47:35",
            "module_date_to_activate": "2023-01-29 05:01:00",
            "module_date_to_submit": "2023-02-05 04:59:59",
            "score_obtained": "0.0"
        },
        "0c2a88db65f0d0d7b081994c940bef45c838764f369623b11803a13b679785d4": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 655,
            "person_id": "0c2a88db65f0d0d7b081994c940bef45c838764f369623b11803a13b679785d4",
            "submission_id": "466b3db4fc9910ed10d3c0f5f34deb02c867b0d2ce6ee3a874457784755693a1",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-tr6c35s8",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:9ae6e05c-0d77-48f8-8f2b-3e41fdf6ef6f",
            "event_time": "2023-02-03 06:29:33",
            "module_date_to_activate": "2023-01-29 05:01:00",
            "module_date_to_submit": "2023-02-05 04:59:59",
            "score_obtained": "20.0"
        },
        "6009c92cf6bb893504abb3a5df60c8fe51da9e1a8a58fcbd6cb4e25838bca31b": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 667,
            "person_id": "6009c92cf6bb893504abb3a5df60c8fe51da9e1a8a58fcbd6cb4e25838bca31b",
            "submission_id": "b5fe4a467a41ee7fd28e86ab2700dd37cb22ae804771130d6d5545cd9902f4f9",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-tr6c35s8",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:952c91b1-bd49-4f9a-861d-81af77e6cf33",
            "event_time": "2023-02-04 00:38:12",
            "module_date_to_activate": "2023-01-29 05:01:00",
            "module_date_to_submit": "2023-02-05 04:59:59",
            "score_obtained": "25.0"
        },
        "ba14245dab5c8159e3a36631debe0b8940f314324a629e70785ca2efdc2e4796": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        res = self.get_from_ram_cache(new_text)\n\n        if res is not None:\n\n            # Renew the cache\n\n            self.remove_from_ram_cache(new_text)\n\n            self.add_to_ram_cache(new_text, res)\n\n            return res\n\n\n\n        res = self.get_from_disk_cache(new_text)\n\n        if res is not None:\n\n            # Renew the disk\n\n            self.remove_from_disk_cache(new_text)\n\n            self.add_to_disk_cache(new_text, res)\n\n            return res\n\n\n\n        res = predict(new_text)\n\n\n\n        # Add to hot\n\n        if self.ram_size() >= self.ram_max:\n\n            old_hot_text = list(self.cache_ram.keys())[0]\n\n            old_hot_value = self.get_from_ram_cache(old_hot_text)\n\n            self.remove_from_ram_cache(old_hot_text)\n\n            \n\n            # Add to cold\n\n            if self.disk_size() >= self.disk_max:\n\n                with open(self.cache_disk, \"r\") as f:\n\n                    lines = f.readlines()\n\n                    lines.pop(0)\n\n                with open(self.cache_disk, \"w\") as f:\n\n                    for line in lines:\n\n                        f.write(line)\n\n            \n\n            self.add_to_disk_cache(old_hot_text, old_hot_value)\n\n        \n\n        self.add_to_ram_cache(new_text, res)\n\n        return res\n\n                ",
            "diff_index": 56,
            "id": 702,
            "person_id": "ba14245dab5c8159e3a36631debe0b8940f314324a629e70785ca2efdc2e4796",
            "submission_id": "5a3837f0f0a5daaf00f4d96070701c971e4c121d0fba638d079f11d8bbf95fb5",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-tr6c35s8",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:a7bf6873-e2d6-444f-860c-727cb46028d5",
            "event_time": "2023-02-05 02:30:27",
            "module_date_to_activate": "2023-01-29 05:01:00",
            "module_date_to_submit": "2023-02-05 04:59:59",
            "score_obtained": "95.0"
        },
        "0f23cdf295d39ac98defc0ee761d7475cebf511054ef56163e1c38fb4b1cf126": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 576,
            "person_id": "0f23cdf295d39ac98defc0ee761d7475cebf511054ef56163e1c38fb4b1cf126",
            "submission_id": "5fba9df4d9387d662ff2bc72fd397da74e1b8549b2716a4fceedd6270224a98f",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-tr6c35s8",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:740fdfdf-754d-4e47-a4a0-8bec1dc4f678",
            "event_time": "2023-02-04 21:51:39",
            "module_date_to_activate": "2023-01-29 05:01:00",
            "module_date_to_submit": "2023-02-05 04:59:59",
            "score_obtained": "10.0"
        },
        "f0229913be5ca8841bf71d4492c0b1f6b36b35ea4d9eab77c1ca079bc8fc219a": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n    def remove_oldest_disk(self):\n\n        with open(self.cache_disk, \"r\") as f:\n\n            lines = f.readlines()\n\n        with open(self.cache_disk, \"w\") as f:\n\n            for i in range(1,len(lines)):\n\n                f.write(lines[i])\n\n    def get(self, new_text):\n\n        res = super().get_from_ram_cache(new_text)\n\n        if res:\n\n            super().remove_from_ram_cache(new_text)\n\n            self.cache_ram[new_text] = res\n\n            return res\n\n        res = super().get_from_disk_cache(new_text)\n\n        if res:\n\n            super().remove_from_disk_cache(new_text)\n\n            super().add_to_disk_cache(new_text, res)\n\n            return res\n\n        res = super().get(new_text)\n\n        if super().ram_size() == self.ram_max:\n\n            if super().disk_size() == self.disk_max:\n\n                text = self.remove_oldest_disk()\n\n            for k,v in self.cache_ram.items():\n\n                text, rating = k, v\n\n                break\n\n            super().add_to_disk_cache(text, rating)\n\n            self.cache_ram.popitem(last=False)\n\n        super().add_to_ram_cache(new_text, res)\n\n        return res\n\n        ",
            "diff_index": 56,
            "id": 778,
            "person_id": "f0229913be5ca8841bf71d4492c0b1f6b36b35ea4d9eab77c1ca079bc8fc219a",
            "submission_id": "8b8c1892aa3dab51cfdb700dfcbf9bfa534f0270d2870d817762f01f9d3f5e94",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-tr6c35s8",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:dc972e69-e094-4ba6-89b6-16854f0520d6",
            "event_time": "2023-02-05 00:26:08",
            "module_date_to_activate": "2023-01-29 05:01:00",
            "module_date_to_submit": "2023-02-05 04:59:59",
            "score_obtained": "0.0"
        },
        "85b6c5d3712a109e5a69d2ac284c702bc93646b2809b48fdf36887129fc306a0": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        self.ram_text_ls = []\n\n        self.disk_text_ls = []\n\n        \n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        if self.get_from_ram_cache(new_text) != None:\n\n            rating = self.get_from_ram_cache(new_text)\n\n            self.remove_from_ram_cache(new_text)\n\n            self.add_to_ram_cache(new_text, rating)\n\n            self.ram_text_ls.remove(new_text)\n\n            self.ram_text_ls.append(new_text)\n\n\n\n        elif self.get_from_disk_cache(new_text) != None:\n\n            rating = self.get_from_disk_cache(new_text)\n\n            self.remove_from_disk_cache(new_text)\n\n            self.add_to_disk_cache(new_text, rating)\n\n            self.disk_text_ls.remove(new_text)\n\n            self.disk_text_ls.append(new_text)\n\n        else:\n\n            rating = predict(new_text)\n\n            if self.ram_size() == self.ram_max:\n\n                if self.disk_size() == self.disk_max:\n\n                    least_common_disk = self.disk_text_ls.pop(0)\n\n                    self.remove_from_disk_cache(least_common_disk)\n\n                least_common_ram = self.ram_text_ls.pop(0)\n\n                least_common_ram_rating = self.get_from_ram_cache(least_common_ram)\n\n                self.remove_from_ram_cache(least_common_ram)\n\n                self.add_to_disk_cache(least_common_ram, least_common_ram_rating)\n\n                self.disk_text_ls.append(least_common_ram)\n\n            self.add_to_ram_cache(new_text, rating)\n\n            self.ram_text_ls.append(new_text)\n\n\n\n        return rating",
            "diff_index": 56,
            "id": 779,
            "person_id": "85b6c5d3712a109e5a69d2ac284c702bc93646b2809b48fdf36887129fc306a0",
            "submission_id": "8b7e22dc993f2eaf7ffd8fd15b1c59d90059b7b12a6da0fa72ba127f70faf14f",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-tr6c35s8",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:d3be451e-fbf5-455c-9966-3e4c2a4ee85b",
            "event_time": "2023-02-05 00:33:54",
            "module_date_to_activate": "2023-01-29 05:01:00",
            "module_date_to_submit": "2023-02-05 04:59:59",
            "score_obtained": "60.0"
        },
        "31ead8de0288b587fd13539e47ab97183201ac499506962b6b3ed3cf30d5a853": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 525,
            "person_id": "31ead8de0288b587fd13539e47ab97183201ac499506962b6b3ed3cf30d5a853",
            "submission_id": "f8762be86ecd113b9f9795b5bafbccf2048c927ad8de19bd88a884db6a134963",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-tr6c35s8",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:80ac8083-0b0a-48d2-be23-f17c1d56808e",
            "event_time": "2023-02-01 19:35:28",
            "module_date_to_activate": "2023-01-29 05:01:00",
            "module_date_to_submit": "2023-02-05 04:59:59",
            "score_obtained": "20.0"
        },
        "7e56eade081fe976526b47d4ddcebb2ed913be568de4cc51522d0c177b56c978": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 751,
            "person_id": "7e56eade081fe976526b47d4ddcebb2ed913be568de4cc51522d0c177b56c978",
            "submission_id": "e83b754fac0bb07ac950d2a4c60146e0695be807c3ddd77862877f740d3cf3b9",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-tr6c35s8",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:d4256433-a4a7-4066-bdb2-0564a9b71e08",
            "event_time": "2023-02-03 09:54:05",
            "module_date_to_activate": "2023-01-29 05:01:00",
            "module_date_to_submit": "2023-02-05 04:59:59",
            "score_obtained": "25.0"
        },
        "c9af2334b06388dbf4c60341c1d5d2dbb63077958e0c8190c3bc47d09d20e6dc": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 803,
            "person_id": "c9af2334b06388dbf4c60341c1d5d2dbb63077958e0c8190c3bc47d09d20e6dc",
            "submission_id": "a6f8ea60a2f1961e55f41712c7524b9b64ab3421de0c25f5dba7863aee6af6fd",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-tr6c35s8",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:dc5c87db-5896-4f1b-bbe4-211c5423fbdd",
            "event_time": "2023-02-20 03:32:27",
            "module_date_to_activate": "2023-01-29 05:01:00",
            "module_date_to_submit": "2023-02-05 04:59:59",
            "score_obtained": "0.0"
        },
        "36d99f41f09b4b933a488723fed464dbffc23bbe7718e857fa09e53580db4980": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 711,
            "person_id": "36d99f41f09b4b933a488723fed464dbffc23bbe7718e857fa09e53580db4980",
            "submission_id": "6c2286ca1c4f5a96ee228a6da14ddbcaace3b8996927272688ec970257b9e06a",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-tr6c35s8",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:8d1f03e1-d304-4d8f-8dd4-df45ac15a7b6",
            "event_time": "2023-02-05 04:52:16",
            "module_date_to_activate": "2023-01-29 05:01:00",
            "module_date_to_submit": "2023-02-05 04:59:59",
            "score_obtained": "25.0"
        },
        "c63974eda3ed8212eff439046e3f7e53326d736e6d927cef213242e7e24520dd": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 793,
            "person_id": "c63974eda3ed8212eff439046e3f7e53326d736e6d927cef213242e7e24520dd",
            "submission_id": "688115f6f75bef161c4f61429392416b371703677aa543e125871ac51733549d",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-tr6c35s8",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:e76d0188-9ebf-49af-ba85-4b3cca0c5b25",
            "event_time": "2023-02-05 20:22:06",
            "module_date_to_activate": "2023-01-29 05:01:00",
            "module_date_to_submit": "2023-02-05 04:59:59",
            "score_obtained": "10.0"
        },
        "bb78b1c162b8d3094c9c534f7e9c1e38e9d6bf9ad17bf22099f59c1d3093fa37": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating\n\n```\n\n\n\n**Notes**:\n\n\n\n- Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n- You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.\n",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n\n\n        # initialize additional fields here\n\n\n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")\n",
            "diff_index": 56,
            "id": 1844,
            "person_id": "bb78b1c162b8d3094c9c534f7e9c1e38e9d6bf9ad17bf22099f59c1d3093fa37",
            "submission_id": "90c3f66b8dc9bc2013cc4502ee21bf171a521814d5658082e28c6995128e8864",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:f9c57686-9cf9-4964-bc8f-426208605513",
            "event_time": "2023-05-23 11:43:36",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "10.0"
        },
        "d6ff356b1314b42034b11f843492415ad8b04fb16c5ab9b11e76a9016280e462": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1846,
            "person_id": "d6ff356b1314b42034b11f843492415ad8b04fb16c5ab9b11e76a9016280e462",
            "submission_id": "0d592fc1900f005ab66b92a527e27fd00b9e1bd3344e9233e9cee6c4881fab53",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:edc6d1ec-f530-4be4-9366-608c6fc21a32",
            "event_time": "2023-05-23 16:05:34",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "50.0"
        },
        "ca9f84a987fe35943e20e74b898acecb263ff8a5b947566ec0700f3e3265275a": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "from collections import OrderedDict\n\nclass MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        self.ram_tracker = collections.OrderedDict()\n\n        self.disk_tracker = collections.OrderedDict()\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n#         print(\"before\".upper())\n\n#         print(f\"self.ram_tracker: {self.ram_tracker}\")\n\n#         print(f\"self.disk_tracker: {self.disk_tracker}\")\n\n#         print()\n\n        \n\n#         print(f\"self.cache_ram: {self.cache_ram}\")\n\n#         print()\n\n        \n\n        if new_text in self.cache_ram:\n\n          if new_text in self.ram_tracker:\n\n            self.ram_tracker.move_to_end(new_text, last = True)\n\n          else:\n\n            self.ram_tracker.update({new_text: self.get_from_ram_cache(new_text)})\n\n          return self.get_from_ram_cache(new_text)\n\n        \n\n        if self.get_from_disk_cache(new_text) is not None:\n\n          if new_text in self.disk_tracker:\n\n            self.disk_tracker.move_to_end(new_text, last = True)\n\n          else:\n\n            self.disk_tracker.update({new_text: self.get_from_disk_cache(new_text)})\n\n          return self.get_from_disk_cache(new_text)\n\n        \n\n        predicted_rating = predict(new_text)\n\n        \n\n        if self.ram_size() == self.ram_max:\n\n          if self.disk_size() == self.disk_max:\n\n            least_recent_in_disk = self.disk_tracker.popitem(last=False)\n\n            self.remove_from_disk_cache(least_recent_in_disk[0])\n\n            \n\n          least_recent_in_ram = self.ram_tracker.popitem(last=False)\n\n          self.remove_from_ram_cache(least_recent_in_ram[0])\n\n\n\n          self.add_to_disk_cache(least_recent_in_ram[0], least_recent_in_ram[1])\n\n          self.disk_tracker.update({least_recent_in_ram[0]: least_recent_in_ram[1]})\n\n            \n\n        self.add_to_ram_cache(new_text, predicted_rating)\n\n        self.ram_tracker.update({new_text: predicted_rating})\n\n        \n\n#         print(\"after\".upper())\n\n#         print(f\"self.ram_tracker: {self.ram_tracker}\")\n\n#         print(f\"self.disk_tracker: {self.disk_tracker}\")\n\n#         print()\n\n        \n\n#         print(f\"self.cache_ram: {self.cache_ram}\")\n\n#         print()        \n\n        \n\n        return predicted_rating\n\n        \n\n#         raise NotImplementedError(\"Complete this function!\")\n\n\n\n# c = MostRecentCache(5, 20)\n\n\n\n# c.get('test' + str())",
            "diff_index": 56,
            "id": 1875,
            "person_id": "ca9f84a987fe35943e20e74b898acecb263ff8a5b947566ec0700f3e3265275a",
            "submission_id": "f85bf6f456674858f795403d5252822ad22ab39ec6f2b5f4e38dd123e1d3ecdd",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:fb879767-4735-4807-a305-10b9dc07abec",
            "event_time": "2023-05-27 09:15:38",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "0.0"
        },
        "bf314980fa0ae5e7e07c9dcf34eed5eb911ad78fd8b42ed81d821cb5747725d8": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1849,
            "person_id": "bf314980fa0ae5e7e07c9dcf34eed5eb911ad78fd8b42ed81d821cb5747725d8",
            "submission_id": "3e697136cbb43aea856bfd55fe12449b852193572a3d73027188aaa9993c11be",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:f6ed3115-60d6-4f4f-8b3a-e36ce5c33093",
            "event_time": "2023-05-24 08:50:42",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "0.0"
        },
        "605dbaccea96c1d538462c8c4ed2da254a3c2150359a8e0e165fa6bd7c85aff5": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1850,
            "person_id": "605dbaccea96c1d538462c8c4ed2da254a3c2150359a8e0e165fa6bd7c85aff5",
            "submission_id": "501dd551c426558107651f274bd48eb8b41bdab6fdf67889d9b356e3daa30f09",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:ede662de-0263-439a-9b48-b0fee1730f46",
            "event_time": "2023-05-24 09:46:24",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "45.0"
        },
        "aad2a5e3be178b75824530286bc11fae13caa902faf741a0554cdb831c5cef6b": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1856,
            "person_id": "aad2a5e3be178b75824530286bc11fae13caa902faf741a0554cdb831c5cef6b",
            "submission_id": "6c91952469f91f968569fe910671607fb412770da13b0c3f19de18e2cda3dbf6",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:f56b8e5c-c96c-4935-8972-7354877c64e2",
            "event_time": "2023-05-25 12:26:26",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "20.0"
        },
        "93921947301e98a0db2a717b4c09d333257dadbc800e2a28a2baf8f83b34fbd3": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        # x = Cache()\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        self.most_recent_element_ram={}\n\n        self.most_recent_element_disk={}\n\n\n\n    def get(self, new_text):\n\n        if new_text in self.cache_ram:\n\n            predicted_rating = self.get_from_ram_cache(new_text)\n\n            self.most_recent_element_ram[new_text] = datetime.now()\n\n            return predicted_rating\n\n        if new_text in self.cache_disk:\n\n            predicted_rating = self.get_from_disk_cache(new_text)\n\n            self.most_recent_element_disk[new_text] = datetime.now()\n\n            return predicted_rating\n\n        else:\n\n            predicted_rating = predict(new_text)\n\n            if self.ram_size()==self.ram_max:\n\n                if self.disk_size() == self.disk_max:\n\n                    # remove least used from disk\n\n                    last_accessed = sorted(self.most_recent_element_disk.items(), key=lambda x:x[1])[0]\n\n                    self.remove_from_disk_cache(last_accessed[0])\n\n                    del self.most_recent_element_disk[last_accessed[0]]\n\n\n\n                # move least used from ram to disk\n\n                # reomve rom ram cache\n\n                last_accessed = sorted(self.most_recent_element_ram.items(), key=lambda x:x[1])[0]\n\n                del self.most_recent_element_ram[last_accessed[0]]\n\n                temp = self.get_from_ram_cache(last_accessed[0])\n\n                self.remove_from_ram_cache(last_accessed[0])\n\n\n\n                # add to disk cache\n\n                self.add_to_disk_cache(last_accessed[0], temp)\n\n                self.most_recent_element_disk[last_accessed[0]] = datetime.now()\n\n\n\n            # add to ram\n\n            self.add_to_ram_cache(new_text, predicted_rating)\n\n            self.most_recent_element_ram[new_text] = datetime.now()\n\n            return predicted_rating",
            "diff_index": 56,
            "id": 1934,
            "person_id": "93921947301e98a0db2a717b4c09d333257dadbc800e2a28a2baf8f83b34fbd3",
            "submission_id": "09fa01473e1e2efee9211d48b00051f222086ad7a0bd64d36d4d83a7b45f4421",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:fd7e1e62-7e41-4ece-ac44-224fa192a6e0",
            "event_time": "2023-05-30 13:30:22",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "50.0"
        },
        "1418a26151858c4666cc2545042cb187265a2b03e8d4124524e3c87b64b9a29d": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        #Queue's to store the most recently accssed and least recently accseesd elements \n\n        self.Ram_queue= deque(maxlen=ram_max) #assume both are empty at first\n\n        self.Disk_queue=deque(maxlen=disk_max)\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n\n\n        #First check if new_text in Ram Cache \n\n        \n\n\n\n\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1676,
            "person_id": "1418a26151858c4666cc2545042cb187265a2b03e8d4124524e3c87b64b9a29d",
            "submission_id": "26b3c99c626681469d745dca582a51e0181b9580eabc9853c6ebf3e2ee0f48f9",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:c1cb5f3b-e9b0-45b5-ad8f-84502f48398b",
            "event_time": "2023-05-27 07:53:20",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "60.0"
        },
        "6f10071b8ad2b3f8d456a8f4ee963f654148c3c34f66c278a108e7672de1a6d7": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "\n\nclass MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        self.mostrecentRAM = {}\n\n        self.mostrecentDISK = {}\n\n\n\n        self.timeRam = 0\n\n        self.timeDisk = 0\n\n\n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n\n\n        ramRes = self.get_from_ram_cache(new_text)\n\n        if ramRes is not None:\n\n          self.timeRam +=1 \n\n          self.mostrecentRAM[new_text] = self.timeRam\n\n          return ramRes\n\n        else:\n\n          diskRes = self.get_from_disk_cache(new_text)\n\n          if diskRes is not None:\n\n            self.timeDisk +=1 \n\n            self.mostrecentDISK[new_text] = self.timeDisk\n\n            return diskRes\n\n          else:\n\n            res = predict(new_text)\n\n            # print(\"did math\", new_text)\n\n            if(self.ram_size() == self.ram_max):\n\n              # print(\"hit lim\", new_text)\n\n              if(self.disk_size() == self.disk_max):\n\n                lastUsed = min(self.mostrecentDISK, key=self.mostrecentDISK.get)\n\n                del self.mostrecentDISK[lastUsed] \n\n                self.remove_from_disk_cache(lastUsed)\n\n                \n\n              lastUsedRam = min(self.mostrecentRAM, key=self.mostrecentRAM.get)\n\n              self.add_to_disk_cache(lastUsedRam, self.get_from_ram_cache(lastUsedRam))\n\n              self.mostrecentDISK[lastUsedRam] = self.mostrecentRAM[lastUsedRam]\n\n                \n\n              # print(\"last ram used\", lastUsedRam)\n\n              del self.mostrecentRAM[lastUsedRam]\n\n              self.remove_from_ram_cache(lastUsedRam)\n\n            self.add_to_ram_cache(new_text, res)\n\n            self.timeRam += 1 \n\n            self.mostrecentRAM[new_text] = self.timeRam\n\n            return res",
            "diff_index": 56,
            "id": 1779,
            "person_id": "6f10071b8ad2b3f8d456a8f4ee963f654148c3c34f66c278a108e7672de1a6d7",
            "submission_id": "8b8d818f5126b47320b09626ec5ad9ca56a979a753c817e39906d421f0faa256",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:e2cf44dc-2c89-44e2-bac3-b26b96260240",
            "event_time": "2023-05-27 22:34:09",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "80.0"
        },
        "f5a4bc8fbd2d10f026e4224acec7d825e657f268f8d23dd25d7711dff1f9769b": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        self.RAM_recent = []\n\n        self.DISK_recent = []\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        a = self.get_from_ram_cache(new_text)\n\n        \n\n        if a != None:\n\n            rating = a\n\n            self.RAM_recent.append((new_text,rating))\n\n            \n\n#             if len(self.RAM_recent) > ram_max:\n\n#                 least_tup = self.RAM_recent.pop(0)\n\n#                 self.remove_from_ram_cache(least_tup[0])\n\n#                 if len(DISK_recent) == disk_max:\n\n#                     least_tup2 = self.DISK_recent.pop(0)\n\n#                     self.add_to_disk_cache(least_tup[0],least_tup[1])\n\n        \n\n            \n\n        hash_value = hash_str(new_text)\n\n        b = self.get_from_disk_cache(hash_value)\n\n        \n\n        if b != None:\n\n            rating = b\n\n            self.DISK_recent.append((hash_value,rating,new_text))\n\n#             if len(self.DISK_recent) > disk_max:\n\n#                 least_tup = self.DISK_recent.pop(0)\n\n#                 self.remove_from_disk_cache(new_text)\n\n                \n\n            \n\n        if a == None and b == None:\n\n            rating = predict(new_text)\n\n            self.add_to_ram_cache(new_text,rating)\n\n            self.RAM_recent.append((new_text,rating))\n\n#             if self.RAM_recent.append((new_text,a))\n\n\n\n        if len(self.RAM_recent) > self.ram_max:\n\n            least_tup = self.RAM_recent.pop(0)\n\n            self.remove_from_ram_cache(least_tup[0])\n\n            self.add_to_disk_cache(least_tup[0],least_tup[1])\n\n            self.DISK_recent.append((hash_str(least_tup[0]),rating,least_tup[0]))\n\n            if len(self.DISK_recent) > self.disk_max:\n\n                least_tup2 = self.DISK_recent.pop(0)\n\n                self.remove_from_disk_cache(least_tup2[2]) \n\n            \n\n        \n\n        \n\n            \n\n        return rating\n\n            \n\n        \n\n            \n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1611,
            "person_id": "f5a4bc8fbd2d10f026e4224acec7d825e657f268f8d23dd25d7711dff1f9769b",
            "submission_id": "b7cc648f3aa23137a2ace97a2e61023724d57f04179c57fa8c4234d2108f4f26",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:bae511eb-bc87-4e77-b5c5-48dd8c23e44f",
            "event_time": "2023-05-29 08:27:43",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "70.0"
        },
        "bdc98b4dec8552d57441cf548036649735e816d78d5b54a928d7b61994ce9697": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1895,
            "person_id": "bdc98b4dec8552d57441cf548036649735e816d78d5b54a928d7b61994ce9697",
            "submission_id": "a7d5fb836f3cbbf6a57976fc203a12fc7487d56efd6d35ba68af10dba5dffe81",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:f4ab88f8-5732-4f1a-918e-4b018e7cb912",
            "event_time": "2023-05-28 14:26:38",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "15.0"
        },
        "532d0da52f174ff17d007c0aa64d1d0bf90c5385d972548554fe7b42245c7891": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1890,
            "person_id": "532d0da52f174ff17d007c0aa64d1d0bf90c5385d972548554fe7b42245c7891",
            "submission_id": "b7a7239a99335212375d63789457e565aa75786d22a37d2cb72afaf1777f41a2",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:fe70bef0-c9a1-46be-861c-0fcf1230c595",
            "event_time": "2023-05-28 06:09:32",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "0.0"
        },
        "4ecdfb127b80e6b66c2d06b2ad9c3e4fb8bdb245bce811303c87b79d660e1c63": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "\n\n# class MostRecentCache(Cache):\n\n#     def __init__(self, ram_max, disk_max):\n\n#         '''\n\n#         Args:\n\n#             ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n#             disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n#         '''\n\n#         super().__init__()\n\n#         self.ram_max = ram_max\n\n#         self.disk_max = disk_max\n\n#         self.ram_order = collections.deque()\n\n#         self.disk_order = collections.deque()\n\n        \n\n#     def get(self, new_text):\n\n        \n\n#         ram_element = super().get_from_ram_cache(new_text)\n\n#         if ram_element:\n\n#           self.ram_order.remove(new_text)\n\n#           self.ram_order.append(new_text)\n\n#           return ram_element\n\n\n\n#         disk_element = super().get_from_disk_cache(new_text)\n\n#         if disk_element:\n\n#           self.disk_order.remove(new_text)\n\n#           self.disk_order.append(new_text)\n\n#           return disk_element\n\n\n\n#         prediction = super().get(new_text)\n\n#         if super().ram_size()==self.ram_max:\n\n#           if super().disk_size()==self.disk_max:\n\n#             disk_last = self.disk_order.popleft()\n\n#             super().remove_from_disk_cache(disk_last)\n\n#           ram_last = self.ram_order.popleft()\n\n#           super().remove_from_ram_cache(ram_last)\n\n#           self.disk_order.append(ram_last)\n\n#           super().add_to_disk_cache(ram_last,prediction)\n\n#         self.ram_order.append(new_text)\n\n#         super().add_to_ram_cache(new_text,prediction)\n\n#         return prediction\n\n       \n\n        ",
            "diff_index": 56,
            "id": 1904,
            "person_id": "4ecdfb127b80e6b66c2d06b2ad9c3e4fb8bdb245bce811303c87b79d660e1c63",
            "submission_id": "71d96e0bad4f1a11908d6b685bc27584b706d80b92c69df83b1b904efcad2f52",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:fabda4ea-e417-49e1-bf76-ca2a974b42d8",
            "event_time": "2023-05-28 21:56:40",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "0.0"
        },
        "0e7ad91c633cf5126e02bcc5a37d746b869fde0d3faef764a8f1e3b9cf060226": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        self.ram_count = 0\n\n        self.disk_count = 0\n\n        self.ram_queue = collections.deque()\n\n        self.disk_queue = collections.deque()\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1933,
            "person_id": "0e7ad91c633cf5126e02bcc5a37d746b869fde0d3faef764a8f1e3b9cf060226",
            "submission_id": "3094545400a49ad212c6dd87c77718543d72586a390bc7a5626b93938dbcb7ad",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:f6f64f0d-5cc9-4eb2-bf66-d93992200261",
            "event_time": "2023-05-30 04:38:44",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "0.0"
        },
        "65008cf17265ab6622032f7f3414976086557542bd51c0ff770f2ddfc936bb79": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        self.most_recent_ram = []\n\n        self.most_recent_disk = []\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n      ram = self.get_from_ram_cache(new_text)\n\n      if ram != None:\n\n        self.most_recent_ram = [(new_text, ram)] + self.most_recent_ram\n\n        return ram\n\n      disk = self.get_from_disk_cache(new_text)\n\n      if disk != None:\n\n        self.most_recent_disk = [(new_text, disk)] + self.most_recent_disk\n\n        return disk\n\n      predicted_rating = predict(new_text)\n\n      \n\n      if self.ram_size() == self.ram_max:\n\n        if self.disk_size() == self.disk_max:\n\n          self.remove_from_disk_cache(self.most_recent_disk[len(self.most_recent_disk)-1][0])\n\n          self.most_recent_disk = self.most_recent_disk[0:len(self.most_recent_disk)-1]\n\n        self.most_recent_disk = [(self.most_recent_ram[len(self.most_recent_ram)-1][0], self.most_recent_ram[len(self.most_recent_ram)-1][1])]+self.most_recent_disk\n\n        self.add_to_disk_cache(self.most_recent_ram[len(self.most_recent_ram)-1][0], self.most_recent_ram[len(self.most_recent_ram)-1][1])\n\n        self.remove_from_ram_cache(self.most_recent_ram[len(self.most_recent_ram)-1][0])\n\n        self.most_recent_ram = self.most_recent_ram[0:len(self.most_recent_ram)-1]\n\n      self.add_to_ram_cache(new_text, predicted_rating)\n\n      self.most_recent_ram = [(new_text, predicted_rating)]+self.most_recent_ram\n\n      return predicted_rating\n\n\n\n\n\n      ",
            "diff_index": 56,
            "id": 1928,
            "person_id": "65008cf17265ab6622032f7f3414976086557542bd51c0ff770f2ddfc936bb79",
            "submission_id": "1265bf36d618e01af9477a4b52100cb0abe38c4118abfae6b0f3bd00515dc21d",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:ecfc5ced-fa71-4c7e-a012-78c1b766d6c0",
            "event_time": "2023-05-29 23:04:56",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "60.0"
        },
        "1ec62d57d2e3261032b1eff2546e5f220cdd1d82b814b8814184506b2a98d82e": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1925,
            "person_id": "1ec62d57d2e3261032b1eff2546e5f220cdd1d82b814b8814184506b2a98d82e",
            "submission_id": "5158da47816aafdb7fb86636745f049ff5810cf772b1861b5a3729a901ae8f55",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:f6af2657-b2cd-4a30-9ad6-ee9fa445b9b3",
            "event_time": "2023-05-29 21:59:48",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "0.0"
        },
        "0b75117573e58bb174e5cc899006dee645208f3267855fe0ae47b03a7104d030": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1938,
            "person_id": "0b75117573e58bb174e5cc899006dee645208f3267855fe0ae47b03a7104d030",
            "submission_id": "490b62a3e2d663aec98c7aa7f79dc361d8c38ef189f89ecc21ef481c23b84e61",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:ec899860-1c28-462b-8f11-a1275add32fe",
            "event_time": "2023-05-30 21:06:43",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "0.0"
        },
        "9558865d3da37aee18bf01448dcfc3675e51c4b0c281fd4988d3ad1bb462577c": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        self.ram_recent = None\n\n        self.disk_recent = None\n\n\n\n    def get(self, text):\n\n        # Check if text is in RAM cache\n\n        if text in self.cache_ram:\n\n            self.ram_recent = text\n\n            return self.cache_ram[text]\n\n\n\n        # Check if hashed value of text is in disk cache\n\n        hashed_text = hash_str(text)\n\n        disk_rating = self.get_from_disk_cache(text)\n\n        if disk_rating is not None:\n\n            self.disk_recent = hashed_text\n\n            return disk_rating\n\n\n\n        # Compute the predicted rating\n\n        predicted_rating = predict(text)\n\n\n\n        # Check if RAM cache is full\n\n        if len(self.cache_ram) == self.ram_max:\n\n            # Check if disk cache is full\n\n            if self.disk_size() == self.disk_max:\n\n                # Remove the least recent element from the disk cache\n\n                self.remove_from_disk_cache(self.disk_recent)\n\n            # Move the least recent element in the RAM cache to the disk cache\n\n            self.add_to_disk_cache(self.ram_recent, self.cache_ram[self.ram_recent])\n\n            self.remove_from_ram_cache(self.ram_recent)\n\n\n\n        # Store the pair (text, predicted_rating) in RAM cache\n\n        self.add_to_ram_cache(text, predicted_rating)\n\n        self.ram_recent = text\n\n\n\n        return predicted_rating\n\n    \n\n    raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1939,
            "person_id": "9558865d3da37aee18bf01448dcfc3675e51c4b0c281fd4988d3ad1bb462577c",
            "submission_id": "6c123c5ae649c276882810a1022c53876c93d8c711a90cf9018ffb48357b518e",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:f3069554-8750-4f17-8a38-5ca457396a78",
            "event_time": "2023-05-31 01:20:01",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "0.0"
        },
        "cc6df0e3a651a204d4156d558777a0c3995ea1ee763a3117cab2b78d12aa08ce": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        self.ram_cache = {}\n\n        self.disk_cache = {}\n\n        self.ram_cache_size = 0\n\n        self.disk_cache_size = 0\n\n        \n\n        \n\n    def get(self, new_text):\n\n        '''\n\n        Compute the predicted rating by using the magical model\n\n        Args:\n\n            new_text  [String] - raw text\n\n        Return:\n\n            Integer - rating\n\n        '''\n\n        # check if the text is in the cache\n\n        if new_text in self.ram_cache:\n\n            # if it is in the cache, move it to the end of the queue\n\n            self.ram_cache.move_to_end(new_text)\n\n            return self.ram_cache[new_text]\n\n        elif new_text in self.disk_cache:\n\n            # if it is in the cache, move it to the end of the queue\n\n            self.disk_cache.move_to_end(new_text)\n\n            return self.disk_cache[new_text]\n\n        else:\n\n            # if it is not in the cache, compute the rating\n\n            rating = super().get(new_text)\n\n            # add the new text to the cache\n\n            self.add(new_text, rating)\n\n            return rating\n\n        ",
            "diff_index": 56,
            "id": 1942,
            "person_id": "cc6df0e3a651a204d4156d558777a0c3995ea1ee763a3117cab2b78d12aa08ce",
            "submission_id": "ba741805c6100ecb5c3e3f5496451fbe4dd752b94af30cbdc465f8d79255299e",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:f5ab99ef-4232-4449-ba22-afdfcec5f427",
            "event_time": "2023-05-31 02:43:56",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "85.0"
        },
        "d7954a735f3c35198e1d53b06469523b8c9bd5de31e54d772206044d6d749f4f": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        self.most_recent_ram = deque()  # least-most recent\n\n        self.most_recent_disk = deque()  # least-most recent\n\n\n\n        \n\n    def get(self, new_text):\n\n        # try caches\n\n        fromram = self.get_from_ram_cache(new_text)\n\n        if fromram is not None:\n\n            self.most_recent_ram.remove(new_text)\n\n            self.most_recent_ram.append(new_text)\n\n            #print(fromram, \"ram\")\n\n            return fromram\n\n        fromdisk = self.get_from_disk_cache(new_text)\n\n        if fromdisk is not None:\n\n            self.most_recent_disk.remove(new_text)\n\n            self.most_recent_disk.append(new_text)\n\n            #print(fromdisk, \"disk\")\n\n            return fromdisk\n\n        # Compute value\n\n        pred_rating = predict(new_text)\n\n        if self.ram_size() == self.ram_max:\n\n            if self.disk_size() == self.disk_max:\n\n                least_recent_disk = self.most_recent_disk.popleft()\n\n                self.remove_from_disk_cache(least_recent_disk)\n\n            least_recent_ram = self.most_recent_ram.popleft()\n\n            least_recent_rating = self.remove_from_ram_cache(least_recent_ram)\n\n            self.add_to_disk_cache(least_recent_ram, least_recent_rating)\n\n            self.most_recent_disk.append(least_recent_ram)\n\n        self.add_to_ram_cache(new_text, pred_rating)\n\n        self.most_recent_ram.append(new_text)\n\n        #print(pred_rating, \"compute\")\n\n        return pred_rating",
            "diff_index": 56,
            "id": 1873,
            "person_id": "d7954a735f3c35198e1d53b06469523b8c9bd5de31e54d772206044d6d749f4f",
            "submission_id": "dac5014244deb8120309d79e76d7459c207379cafe75a68b54f97404fa05a842",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:f34d93df-c839-4e36-99eb-80cdc4703abb",
            "event_time": "2023-05-27 03:59:59",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "95.0"
        },
        "caca2566bff4c788833ee1360ce9fc74d00bcf24e4d37eed018e46ea26dfbcc4": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 916,
            "person_id": "caca2566bff4c788833ee1360ce9fc74d00bcf24e4d37eed018e46ea26dfbcc4",
            "submission_id": "3ae17c7b7120de27ad5c10abf6c74faaef1753d9782dd6b46df9d4602ab1d77b",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:25e7b19a-aecf-4ff4-bfcd-88dd4ba8b474",
            "event_time": "2023-05-24 10:43:35",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "30.0"
        },
        "8673740ea1c42996565a5bfdf21af5b69e8d014adcea037867ee8e587d625575": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n\n\n        # initialize additional fields here\n\n        from collections import OrderedDict\n\n        self.cache_ram = OrderedDict()\n\n    \n\n    def get_from_ram_cache(self, text):\n\n        '''\n\n        Get value from RAM cache. \n\n        Args:\n\n            text - raw text for which predicted value is needed\n\n        Return:\n\n            Integer or None - predicted rating for text or None, \n\n                                if there requested text is not stored in this cache\n\n        '''\n\n        res = self.cache_ram.get(text)\n\n        if res:\n\n            self.cache_ram.move_to_end(text)\n\n        return res\n\n    \n\n    def add_to_ram_cache(self, text, value):\n\n        '''\n\n        Add value to RAM cache. \n\n        Args:\n\n            text [String] - raw text\n\n            rating [Integer] - rating that should be saved\n\n        '''\n\n        poped = None\n\n        if self.ram_size() == self.ram_max:\n\n            poped = self.cache_ram.popitem(0)\n\n        self.cache_ram[text] = value\n\n        self.cache_ram.move_to_end(text)\n\n        return poped\n\n    \n\n    def get_from_disk_cache(self, text):\n\n        '''\n\n        Get value from disk cache. \n\n        Args:\n\n            text [String] - raw text for which predicted value is needed\n\n        Return:\n\n            Integer or None - predicted rating for text or None, \n\n                                if there requested text is not stored in this cache\n\n        '''\n\n        hashed_text = hash_str(text)\n\n        res = None\n\n        with open(self.cache_disk, \"r\") as f:\n\n            for line in f:\n\n                review_rating_pair = line.replace('\\n', '').split(' ')\n\n                if review_rating_pair[0] == hashed_text:\n\n                    res = int(review_rating_pair[1])\n\n                    break\n\n        if res:\n\n            self.remove_from_disk_cache(text)\n\n            self.add_to_disk_cache(text, res)\n\n        return res\n\n\n\n    def add_to_disk_cache(self, text, rating):\n\n        '''\n\n        Add value to disk cache. \n\n        Args:\n\n            text [String] - raw text\n\n            rating [Integer] - rating that should be saved\n\n        '''\n\n        if self.disk_size() == self.disk_max:\n\n            # print(self.disk_size())\n\n            with open(self.cache_disk, \"r\") as f:\n\n                lines = f.readlines()[1:]\n\n            with open(self.cache_disk, \"w\") as f:\n\n                f.writelines(lines)\n\n            # print(self.disk_size())\n\n        key = hash_str(text)\n\n        with open(self.cache_disk, \"a+\") as f:\n\n            f.write(key + \" \" + str(rating) + \"\\n\")\n\n\n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        res = self.get_from_ram_cache(new_text)\n\n        if not res:\n\n            res = self.get_from_disk_cache(new_text)\n\n        if not res:\n\n            res = predict(new_text)\n\n            poped = self.add_to_ram_cache(new_text, res)\n\n            if poped:\n\n                # print(poped)\n\n                (text, rating) = poped\n\n                self.add_to_disk_cache(text, rating)\n\n        \n\n        return res",
            "diff_index": 56,
            "id": 1757,
            "person_id": "8673740ea1c42996565a5bfdf21af5b69e8d014adcea037867ee8e587d625575",
            "submission_id": "16875b80fcd3741b339ef1766ea36baad4b8a398503bf16122326692cf729eef",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:e8b8abd7-fce5-48de-a801-1f2c348b4f60",
            "event_time": "2023-05-25 18:32:58",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "85.0"
        },
        "d40142db22835ef2c018c7bfd40902b524a5a619a019730251afbe39b57aeca8": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 933,
            "person_id": "d40142db22835ef2c018c7bfd40902b524a5a619a019730251afbe39b57aeca8",
            "submission_id": "2037df294154cf0b1734cb1ddfb0fad80a967930d0f048c622e040c4cdfd4c0e",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:229f9703-6fcf-48d4-b0f9-598979867edf",
            "event_time": "2023-05-26 19:03:40",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "10.0"
        },
        "cf0459fe6a30034497deb6b9429e41e6b9cee56d6ce17a438d7acd7d55453ad5": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1770,
            "person_id": "cf0459fe6a30034497deb6b9429e41e6b9cee56d6ce17a438d7acd7d55453ad5",
            "submission_id": "201a67cae96bf5cef617177e6013b739e590bc31309d2545d19fcc6a5fed58fa",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:e2ebc9a9-a005-4400-9bae-638ba05c2b20",
            "event_time": "2023-05-27 07:21:44",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "15.0"
        },
        "2d0feac6abcacffb68be0fe61bebe2f197590907551389d3ce79fa0d51d93e2d": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1886,
            "person_id": "2d0feac6abcacffb68be0fe61bebe2f197590907551389d3ce79fa0d51d93e2d",
            "submission_id": "fb0eb702e318cd9317689a80d32b35eec634424832ad475665280334cff4443b",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:fd823bab-be65-40cd-ac7d-ed97b4ea974e",
            "event_time": "2023-05-27 23:39:05",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "15.0"
        },
        "09a5e978000ed845af1b76ea4bfa5039afe72d48807045281dcb055b9b015121": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        self.text_list = []\n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        if new_text in self.text_list:\n\n            self.text_list.pop(self.text_list.index(new_text))\n\n        self.text_list.append(new_text)\n\n        prediction = self.get_from_ram_cache(new_text)\n\n        if prediction == None:\n\n            ...\n\n        else:\n\n            return prediction\n\n        # raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1576,
            "person_id": "09a5e978000ed845af1b76ea4bfa5039afe72d48807045281dcb055b9b015121",
            "submission_id": "99f4a8280584be13f4e4dd6607ebd6178ca35e922f9203c50152ca9f74b90079",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:beb552af-d9ef-40db-bf44-d6d8a0783fca",
            "event_time": "2023-05-27 22:18:05",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "75.0"
        },
        "fd29b2f257538e5acd2751ff7511cb58cac275011a1aaa98ab1e090fadf1eb66": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1906,
            "person_id": "fd29b2f257538e5acd2751ff7511cb58cac275011a1aaa98ab1e090fadf1eb66",
            "submission_id": "d116ee3be8353fe372a1ad80c93b3583ec2ab90dbcb6566fac3e1fd67f646e6b",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:ef705fdc-1aa8-4a0e-aa47-d65fc8aa9e51",
            "event_time": "2023-05-29 02:31:34",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "30.0"
        },
        "fc1c35ee9dc8ff5e6798d0a009ad11f2d23ee48355c9820151532f976500ba7c": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1832,
            "person_id": "fc1c35ee9dc8ff5e6798d0a009ad11f2d23ee48355c9820151532f976500ba7c",
            "submission_id": "40d921e8a21bbd6ba39989d3854986c6a72b431036488f73dd29d1a2cdcbb4c4",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:de0f4c44-f89a-4df1-8d41-5d2385e20825",
            "event_time": "2023-05-30 03:53:19",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "85.0"
        },
        "2e1656090c058cd84a13f1faa30fc1b29f80cd06eccb59d66872af95669568ad": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n        #These queues will allow us to remove \n\n        self.ram_queue = collections.deque()\n\n        self.disk_queue = collections.deque()\n\n        \n\n    def get(self, new_text):\n\n        ram_result = self.get_from_ram_cache(new_text)\n\n        if ram_result != None:\n\n            self.ram_queue.remove(new_text)\n\n            self.ram_queue.append(new_text)\n\n            return ram_result\n\n        \n\n        disk_result = self.get_from_disk_cache(new_text)\n\n        if disk_result != None:\n\n            self.disk_queue.remove(new_text)\n\n            self.disk_queue.append(new_text)\n\n            return disk_result\n\n        \n\n        #the value is not in cache\n\n        predicted_rating = predict(new_text)\n\n        \n\n        if self.ram_size() == self.ram_max:\n\n            if self.disk_size() == self.disk_max:\n\n                #remove the least recent element from the disk cache\n\n                oldest_disk_elem = self.disk_queue.popleft()\n\n                self.remove_from_disk_cache(oldest_disk_elem)\n\n            \n\n            #Move the least recent element in the RAM cache to the disk cache\n\n            oldest_ram_elem = self.ram_queue.popleft()\n\n            self.add_to_disk_cache(oldest_ram_elem, self.get_from_ram_cache(oldest_ram_elem))\n\n            self.disk_queue.append(oldest_ram_elem)\n\n            \n\n            self.remove_from_ram_cache(oldest_ram_elem)\n\n        \n\n        self.add_to_ram_cache(new_text, predicted_rating)\n\n        self.ram_queue.append(new_text)\n\n        \n\n        return predicted_rating\n\n        ",
            "diff_index": 56,
            "id": 988,
            "person_id": "2e1656090c058cd84a13f1faa30fc1b29f80cd06eccb59d66872af95669568ad",
            "submission_id": "222df894a7ed77cbd8175f5ecf2434023aab7ad78972d85844e99e381976dcf4",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:29146886-8712-4d56-86f2-3f37d033326a",
            "event_time": "2023-05-29 19:43:35",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "95.0"
        },
        "59e681cf2ea9056593501dfa5592cf6fd0e08bc78b9a67cb9c10a8d4f9b75c7e": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    class Node:\n\n        def __init__(self, text, recency):\n\n            self.prev = None\n\n            self.next = None\n\n            self.text = text\n\n\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n\n\n        self.ram_recency_head = None\n\n        self.ram_recency_tail = None\n\n        self.ram_recency_dict = dict()\n\n\n\n        self.disk_recency_head = None\n\n        self.disk_recency_tail = None\n\n        self.disk_recency_dict = dict()\n\n        \n\n        # initialize additional fields here\n\n\n\n    def ram_remove(self, node):\n\n        if node.prev != None:\n\n            node.prev.next = node.next\n\n        if node.next != None:\n\n            node.next.prev = node.prev\n\n        if self.ram_recency_head == node:\n\n            self.ram_recency_head = node.next\n\n        if self.ram_recency_tail == node:\n\n            self.ram_recency_tail = node.prev\n\n    \n\n    def ram_insert(self, node):\n\n        # empty\n\n        if self.ram_recency_head == None:\n\n            self.ram_recency_head = node\n\n            self.ram_recency_tail = node\n\n            node.prev = None\n\n            node.next = None\n\n        # non-empty\n\n        else:\n\n            self.ram_recency_tail.next = node\n\n            node.prev = self.ram_recency_tail\n\n            node.next = None\n\n            self.ram_recency_tail = node\n\n\n\n    def disk_remove(self, node):\n\n        if node.prev != None:\n\n            node.prev.next = node.next\n\n        if node.next != None:\n\n            node.next.prev = node.prev\n\n        if self.disk_recency_head == node:\n\n            self.disk_recency_head = node.next\n\n        if self.disk_recency_tail == node:\n\n            self.disk_recency_tail = node.prev\n\n    \n\n    def disk_insert(self, node):\n\n        # empty\n\n        if self.disk_recency_head == None:\n\n            self.disk_recency_head = node\n\n            self.disk_recency_tail = node\n\n            node.prev = None\n\n            node.next = None\n\n        # non-empty\n\n        else:\n\n            self.disk_recency_tail.next = node\n\n            node.prev = self.disk_recency_tail\n\n            node.next = None\n\n            self.disk_recency_tail = node\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        if new_text in self.ram_recency_dict:\n\n            node = self.ram_recency_dict[new_text]\n\n            self.ram_remove(node)\n\n            self.ram_insert(node)\n\n            return self.get_from_ram_cache(new_text)\n\n        \n\n        if new_text in self.disk_recency_dict:\n\n            node = self.disk_recency_dict[new_text]\n\n            self.disk_remove(node)\n\n            self.disk_insert(node)\n\n            return self.get_from_disk_cache(new_text)\n\n        \n\n        new_rating = predict(new_text)\n\n        if self.ram_size() == self.ram_max:\n\n            ram_node = self.ram_recency_head\n\n            ram_rating = self.get_from_ram_cache(ram_node.text)\n\n            self.ram_remove(ram_node)\n\n            self.ram_recency_dict.pop(ram_node.text)\n\n            self.remove_from_ram_cache(ram_node.text)\n\n\n\n            if self.disk_size() == self.disk_max:\n\n                disk_node = self.disk_recency_head\n\n                self.disk_remove(disk_node)\n\n                self.disk_recency_dict.pop(disk_node.text)\n\n                self.remove_from_disk_cache(disk_node.text)\n\n\n\n            self.disk_insert(ram_node)\n\n            self.disk_recency_dict[ram_node.text] = ram_node\n\n            self.add_to_disk_cache(ram_node.text, ram_rating)\n\n\n\n        new_node = self.Node(new_text, new_rating)\n\n        self.ram_insert(new_node)\n\n        self.ram_recency_dict[new_text] = new_node\n\n        self.add_to_ram_cache(new_text, new_rating)\n\n\n\n        return new_rating",
            "diff_index": 56,
            "id": 1409,
            "person_id": "59e681cf2ea9056593501dfa5592cf6fd0e08bc78b9a67cb9c10a8d4f9b75c7e",
            "submission_id": "795f82c224e32757c054f7386c08856a2623b3ca8482dbf01ef0d51e0c523e31",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:8a0c8ed0-5aed-4012-9d90-fc6d07112aec",
            "event_time": "2023-05-29 20:37:21",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "95.0"
        },
        "b1d9a27b449675fefaa3bb00dfaac7779f4120dc959c4beafbe82d9cd82b27c6": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1845,
            "person_id": "b1d9a27b449675fefaa3bb00dfaac7779f4120dc959c4beafbe82d9cd82b27c6",
            "submission_id": "85013042995217b0885c3a5584a44f0ed7960197c4f8f6bd4b6ce641bf285036",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:f3796e2a-367e-4b64-8d30-aa8525293ee7",
            "event_time": "2023-05-23 13:26:58",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "55.0"
        },
        "58d4962e846c8754e3b0dc975e61d164ad45771252706ee87bc9275658bc323d": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1749,
            "person_id": "58d4962e846c8754e3b0dc975e61d164ad45771252706ee87bc9275658bc323d",
            "submission_id": "a771d21bc2252fe4c2b16e92164d6f567abe7f706ddb10a33e8b249606ad1517",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:e0d410c2-badd-4aee-a9a3-834ae1483860",
            "event_time": "2023-05-24 18:31:38",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "30.0"
        },
        "5170cab5679bd5da6e8216e24d4434f92a1becd5cbcc1b72dc1a2f50929b8a1c": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1458,
            "person_id": "5170cab5679bd5da6e8216e24d4434f92a1becd5cbcc1b72dc1a2f50929b8a1c",
            "submission_id": "70893dc65e2a337d14c3765864650c00be554ab11c16c08ecac1827eceac87d4",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:9d48ca42-55bd-4176-b9fd-f62ad43e008f",
            "event_time": "2023-05-26 21:14:50",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "0.0"
        },
        "f1d3bc01fbbb656bc2a6ab024c8525ff4116bfeedd0d1605f43a3dbc5f2045cd": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n            ram_most_recent (List) - list of most recent elements in RAM cache\n\n            disk_most_recent (List) - list of most recent elements in disk cache\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        self.ram_most_recent = []\n\n        self.disk_most_recent = []\n\n\n\n        \n\n    def get(self, new_text):\n\n        # if the requested text is in RAM cache, return it and mark it as most recent in RAM cache\n\n        if new_text in self.cache_ram:\n\n            self.ram_most_recent.remove(new_text)\n\n            self.ram_most_recent.append(new_text)\n\n            return self.cache_ram[new_text]\n\n        # if the hashed value of the requested text is in disk cache,\n\n        # mark this pair of hashed value and stored rating as most recent in disk cache\n\n        # and return the rating\n\n        if self.get_from_disk_cache(new_text) is not None:\n\n            pred_rating = self.get_from_disk_cache(new_text)\n\n            self.disk_most_recent.remove(new_text)\n\n            self.disk_most_recent.append(new_text)\n\n            return pred_rating\n\n        \n\n        # if neither cases is true, compute the predicted rating\n\n        pred_rating = predict(new_text)\n\n\n\n        if self.ram_size() == self.ram_max:\n\n            if self.disk_size() == self.disk_max:\n\n                # get the least recent element in disk cache\n\n                least_recent_disk = self.disk_most_recent[0]\n\n                # update the queue of most recent elements in disk cache\n\n                self.disk_most_recent.remove(least_recent_disk)\n\n                # remove the least recent element from disk cache\n\n                self.remove_from_disk_cache(least_recent_disk)\n\n            \n\n            least_recent_ram = self.ram_most_recent[0]\n\n            # move the least recent element from RAM cache to disk cache\n\n            rating = self.cache_ram[least_recent_ram]\n\n            self.remove_from_ram_cache(least_recent_ram)\n\n            self.add_to_disk_cache(least_recent_ram, rating)\n\n            # update the queues of most recent elements in RAM cache and disk cache\n\n            self.ram_most_recent.remove(least_recent_ram)\n\n            self.disk_most_recent.append(least_recent_ram)\n\n\n\n        # add the requested text and predicted rating to RAM cache\n\n        self.add_to_ram_cache(new_text, pred_rating)\n\n        # update the queue of most recent elements in RAM cache\n\n        self.ram_most_recent.append(new_text)\n\n        return pred_rating\n\n                \n\n\n",
            "diff_index": 56,
            "id": 1556,
            "person_id": "f1d3bc01fbbb656bc2a6ab024c8525ff4116bfeedd0d1605f43a3dbc5f2045cd",
            "submission_id": "0c0adc72cd77f7a9c57852b48f8d3d9b3233808b47ddd88d789433f5202fd657",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:bccb4414-d67d-46f4-b36b-327ac122c15a",
            "event_time": "2023-05-26 12:01:54",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "95.0"
        },
        "99582505329ebe3f7400613f305e5f9df8432cf712035e01fbb09295132a3e95": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1596,
            "person_id": "99582505329ebe3f7400613f305e5f9df8432cf712035e01fbb09295132a3e95",
            "submission_id": "8f0499bc0476aeed633fa7189ff1db7827fefac31062645fa268d8fd231ea69d",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:b23546a6-4f02-4d32-9a18-2af9e011afd4",
            "event_time": "2023-05-28 12:09:44",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "0.0"
        },
        "b2e07fd5dd8e7ffb2af968625b897ee5ee3b264ade758b5f550702cd091ac1ab": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1921,
            "person_id": "b2e07fd5dd8e7ffb2af968625b897ee5ee3b264ade758b5f550702cd091ac1ab",
            "submission_id": "c6fa1178e89b20ae543d0ea4ff93ac321a67f89d572d409247ee34a24616bdd5",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:eee053e9-d98d-4e55-8d09-5831a40d3824",
            "event_time": "2023-05-29 19:05:46",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "0.0"
        },
        "374a5796f41694e25c8ad74fd00d9e02d5f1aa10f122c43e39bbd7f3e4021933": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n#         self.ram_latest = \"\"\n\n#         self.ram_least = \"\"\n\n#         self.disk_latest = \"\"\n\n#         self.disk_least = \"\"\n\n        \n\n        self.ram_deque = deque()\n\n        self.disk_deque = deque()\n\n        \n\n            \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        \n\n#         val = self.get_from_ram_cache(new_text)\n\n#         if(val is not None):\n\n#             predicted_value = val\n\n#             self.ram_latest = new_text\n\n            \n\n#         else:\n\n#             val2 = self.get_from_disk_cache(new_text)\n\n#             if(val2 is not None):\n\n#                 predicted_value = val\n\n#                 self.disk_latest = new_text\n\n#             else:\n\n#                 predicted_value = predict(new_text)\n\n                \n\n#                 if(self.ram_size() == self.ram_max):\n\n#                     if(self.disk_size() == self.disk_max):\n\n#                         self.remove_from_disk_cache(self.disk_least)\n\n#                     self.add_to_disk_cache(self.ram_least, self.get_from_ram_cache(self.ram_least))\n\n#                     self.disk_latest = self.ram_least\n\n#                     self.remove_from_ram_cache(self.ram_least)\n\n                \n\n#                 self.add_to_ram_cache(new_text, predicted_value)\n\n#                 self.ram_latest = new_text\n\n                \n\n        val1 = self.get_from_ram_cache(new_text)\n\n        if(val1 is not None):\n\n            predicted_value = val1\n\n            self.ram_deque.remove(new_text)\n\n            self.ram_deque.append(new_text)\n\n            \n\n        else:\n\n            val2 = self.get_from_disk_cache(new_text)\n\n            if(val2 is not None):\n\n                predicted_value = val2\n\n                self.disk_deque.remove(new_text)\n\n                self.disk_deque.append(new_text)\n\n            else:\n\n                predicted_value = predict(new_text)\n\n                \n\n                if(self.ram_size() == self.ram_max):\n\n                    if(self.disk_size() == self.disk_max):\n\n                        self.remove_from_disk_cache(self.disk_deque.popleft())\n\n                    \n\n                    ## MOVE FROM RAM TO DISK\n\n                    ram_least_text = self.ram_deque.popleft()\n\n                    ram_least_val = self.get_from_ram_cache(ram_least_text)\n\n                    self.add_to_disk_cache(ram_least_text, ram_least_val)\n\n                    self.disk_deque.append(ram_least_text)\n\n                    self.remove_from_ram_cache(ram_least_text)\n\n                \n\n                self.add_to_ram_cache(new_text, predicted_value)\n\n                self.ram_deque.append(new_text)\n\n                \n\n                \n\n        return predicted_value",
            "diff_index": 56,
            "id": 1929,
            "person_id": "374a5796f41694e25c8ad74fd00d9e02d5f1aa10f122c43e39bbd7f3e4021933",
            "submission_id": "d64a717ba6de1a866a889bed1b2af8cea7033601f21892b1d1542364359a4739",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:ef10e426-0ebe-4314-895e-2f18c82c18b2",
            "event_time": "2023-05-30 00:33:05",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "70.0"
        },
        "d99f9ae3712814404ddd80975f51080e402152ebcc6e1d7e489a059d3820994c": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1834,
            "person_id": "d99f9ae3712814404ddd80975f51080e402152ebcc6e1d7e489a059d3820994c",
            "submission_id": "156206201ee0593c30de9417f91fb9336c1ab4f385a35f3ef7e9aa5a118c3754",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:e51bf491-8958-4732-b2ef-41c6d8ff7ade",
            "event_time": "2023-05-30 08:15:08",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "30.0"
        },
        "c5324c71931c07fa0c65d1feda8a284de2c12b4ecafa63e1e7b7fe83f86406be": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        # should always just be len() == 1\n\n        self.ram_recent = collections.deque()\n\n        self.disk_recent = collections.deque()\n\n        \n\n\n\n        \n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n\n\n        # Check in RAM cache\n\n        rating = super().get_from_ram_cache(new_text)\n\n        if rating is not None:\n\n            if (new_text, rating) in self.ram_recent:\n\n                self.ram_recent.remove(new_text)\n\n\n\n            self.ram_recent.appendleft(new_text)\n\n            return rating\n\n        \n\n        # Check in DISK cache\n\n        rating = super().get_from_disk_cache(new_text)\n\n        if rating is not None:\n\n            if (new_text, rating) in self.disk_recent:\n\n                self.disk_recent.remove(new_text)\n\n            \n\n            self.disk_recent.appendleft(new_text)\n\n            return rating\n\n\n\n        # predict if not in either cache\n\n        predicted_rating = super().get(new_text)\n\n\n\n        if super().ram_size() == self.ram_max:\n\n            if super().disk_size() == self.disk_max:\n\n                #remove least recent text from disk cache when full\n\n                text_remove_disk = self.disk_recent.pop()\n\n                # val = super().get_from_disk_cache(text_remove_disk)\n\n                super().remove_from_disk_cache(text_remove_disk)\n\n\n\n\n\n\n\n            #move least recent text from ram cache to disk\n\n            text_remove_ram = self.ram_recent.pop()\n\n            val_remove_ram = super().get_from_ram_cache(text_remove_ram)\n\n            super().remove_from_ram_cache(text_remove_ram)\n\n            #mark as the most recent in disk cache\n\n            self.disk_recent.appendleft(text_remove_ram)\n\n            #add to disk cache\n\n            super().add_to_disk_cache(text_remove_ram, val_remove_ram)\n\n\n\n            #add new_text to RAM and mark recent\n\n            self.ram_recent.appendleft(new_text)\n\n            super().add_to_ram_cache(new_text, predicted_rating)\n\n\n\n            return predicted_rating\n\n\n\n        # RAM not full\n\n        self.ram_recent.appendleft(new_text)\n\n        super().add_to_ram_cache(new_text, predicted_rating)\n\n\n\n        return predicted_rating\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
            "diff_index": 56,
            "id": 1529,
            "person_id": "c5324c71931c07fa0c65d1feda8a284de2c12b4ecafa63e1e7b7fe83f86406be",
            "submission_id": "6560f9e39e65d455b752578dd9eff29770c189c08f1a03e87c8d12b798e0d77e",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:a2b771d2-a22a-425c-a380-a869bc710c14",
            "event_time": "2023-05-30 20:04:19",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "95.0"
        },
        "6f91bbf822374b6663f7e1615231b0862c07ff5414d7e73fa732cddd64a17b32": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        self.ram_queue = deque()\n\n        \n\n    def get(self, new_text):\n\n        rating = self.get_from_ram_cache(new_text)\n\n        if rating is not None:\n\n            self.ram_queue.remove(new_text)\n\n            self.ram_queue.append(new_text)\n\n            return rating\n\n\n\n        rating = self.get_from_disk_cache(new_text)\n\n        if rating is not None:\n\n            if self.ram_size() == self.ram_max:\n\n                least_recent = self.ram_queue.popleft()\n\n                least_recent_value = self.cache_ram[least_recent]\n\n                self.remove_from_ram_cache(least_recent)\n\n                self.add_to_disk_cache(least_recent, least_recent_value)\n\n            \n\n            self.add_to_ram_cache(new_text, rating)\n\n            self.remove_from_disk_cache(new_text)\n\n            self.ram_queue.append(new_text)\n\n            return rating\n\n\n\n        predicted_rating = predict(new_text)  \n\n        if self.ram_size() == self.ram_max:\n\n            least_recent = self.ram_queue.popleft()\n\n            least_recent_value = self.cache_ram[least_recent]\n\n            self.remove_from_ram_cache(least_recent)\n\n            if self.disk_size() == self.disk_max:\n\n                self.remove_least_recent_from_disk_cache()  # Use a new function to remove least recent from Disk\n\n            self.add_to_disk_cache(least_recent, least_recent_value)\n\n\n\n        self.add_to_ram_cache(new_text, predicted_rating)\n\n        self.ram_queue.append(new_text)\n\n\n\n        return predicted_rating\n\n        raise NotImplementedError(\"Complete this function!\")\n\n    def remove_least_recent_from_disk_cache(self):\n\n        with open(self.cache_disk, \"r\") as f:\n\n            lines = f.readlines()\n\n        with open(self.cache_disk, \"w\") as f:\n\n            f.writelines(lines[1:])",
            "diff_index": 56,
            "id": 1536,
            "person_id": "6f91bbf822374b6663f7e1615231b0862c07ff5414d7e73fa732cddd64a17b32",
            "submission_id": "1fd40bde634680318b0b1db64d7bd721feb77271e8eb71435822df3eab1484e8",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:abc0d49a-d4bc-41cf-bd39-ae8040c69922",
            "event_time": "2023-05-23 23:28:28",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "80.0"
        },
        "1c0b732799b2bc0c8ca987fa3f688d6dbd2a0096229f65272ec081267cc324cd": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1855,
            "person_id": "1c0b732799b2bc0c8ca987fa3f688d6dbd2a0096229f65272ec081267cc324cd",
            "submission_id": "02637864f78e9ca647970f21d3265870980566e792eac86a3b69d0b5cd956205",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:f0185317-5512-4551-b0b9-da13a1071a9a",
            "event_time": "2023-05-25 08:26:32",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "15.0"
        },
        "865e6cd64b2141578cfd795d6400f9f6114426112bc825baef1da87ce9c70aee": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        self.recent_ram_cache= []\n\n        self.recent_disk_cache= []\n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        \"\"\"\n\n        If new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\n        If the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\n\n\n        \"\"\"\n\n        res=self.get_from_ram_cache(new_text)\n\n        if res:\n\n          self.recent_ram_cache.append(res)\n\n          return res\n\n        res=self.get_from_disk_cache(new_text)\n\n        if res:\n\n          self.recent_disk_cache.append(res)\n\n          return res\n\n        \"\"\"\n\n        If the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n            If the RAM cache's size is equal to ram_max:\n\n                If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n                Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n            Store the pair (text, predicted_value) in RAM cache\n\n            Update the most recent element in ram / disk and return predicted_rating \n\n        \"\"\"\n\n        res=predict(new_text)\n\n        if self.ram_size()==self.ram_max:\n\n          item=self.recent_ram_cache.pop(0)\n\n          self.remove_from_ram_cache(item)\n\n          self.add_to_ram_cache(new_text,res)  \n\n          if self.disk_size()==self.disk_max:\n\n            item1=self.recent_disk_cache.pop(0)\n\n            self.remove_from_disk_cache(item1)\n\n            \n\n          self.add_to_disk_cache(item,predict(item))  \n\n          self.recent_disk_cache.append(item)\n\n        self.add_to_ram_cache(new_text,res)  \n\n        self.recent_ram_cache.append(new_text)\n\n        \n\n        return res\n",
            "diff_index": 56,
            "id": 1864,
            "person_id": "865e6cd64b2141578cfd795d6400f9f6114426112bc825baef1da87ce9c70aee",
            "submission_id": "f9c24d36b8fd5b4b8ccc75fbe5a93cd8cf19582d02a20f9b8fd52aea8b146bf6",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:fc922433-d31b-482b-96c4-603b74824142",
            "event_time": "2023-05-26 01:43:38",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "95.0"
        },
        "db9bd564d9c335f9ff8ccdcb8558cc8ecf415a54de48e82b18de3c2c48505fb2": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1354,
            "person_id": "db9bd564d9c335f9ff8ccdcb8558cc8ecf415a54de48e82b18de3c2c48505fb2",
            "submission_id": "c674454844ef8a5391a7a25acafd18e6f3a8544114f8f75b08bfb4b1802ebbc5",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:7f6d89f1-e525-4aa2-9788-e4e38ab1d599",
            "event_time": "2023-05-26 17:24:49",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "0.0"
        },
        "f0add638f6b197f6d85ab03d3b343c471bae80f77fb5e959e02bc55d69c0b9bc": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1862,
            "person_id": "f0add638f6b197f6d85ab03d3b343c471bae80f77fb5e959e02bc55d69c0b9bc",
            "submission_id": "1477bf2df84b0427c5f399d7c66df9b968a49584ec382fc8dadfe39886e0dfc6",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:f65fdbd8-c814-401d-b59f-2b56e35c15cc",
            "event_time": "2023-05-25 21:26:10",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "25.0"
        },
        "608b98bf2688b0972cf99229ad2b6d1d3710ae9c0c162b3b61a9f2aaee48aac8": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        score = self.get_from_ram_cache(new_text)\n\n        if score is not None:\n\n            self.remove_from_ram_cache(new_text)\n\n            self.add_to_ram_cache(new_text, score)\n\n            return score\n\n        score = self.get_from_disk_cache(new_text)\n\n        if score is not None:\n\n            self.remove_from_disk_cache(new_text)\n\n            self.add_to_ram_cache(new_text, score)\n\n            return score\n\n        score = predict(new_text)\n\n        if self.ram_size() == self.ram_max:\n\n            if self.disk_size() == self.disk_max:\n\n                self.remove_first_disk_cache()\n\n            self.add_to_disk_cache(list(self.cache_ram.keys())[0], self.get_from_ram_cache(list(self.cache_ram.keys())[0]))\n\n            self.remove_from_ram_cache(list(self.cache_ram.keys())[0])\n\n        self.add_to_ram_cache(new_text, score)\n\n        return score\n\n\n\n            ",
            "diff_index": 56,
            "id": 1819,
            "person_id": "608b98bf2688b0972cf99229ad2b6d1d3710ae9c0c162b3b61a9f2aaee48aac8",
            "submission_id": "989d6dc67ee301fba17e410a2fffa708aef00abf05138252cb8589a516f2e8e0",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:e0f9d369-6ea1-4308-bf30-ad708b9d1902",
            "event_time": "2023-05-29 19:04:00",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "95.0"
        },
        "0b01bf67e11cd44560363c601f2a683622f1c1b5540c8609e4e59bc1bf83aaa1": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1684,
            "person_id": "0b01bf67e11cd44560363c601f2a683622f1c1b5540c8609e4e59bc1bf83aaa1",
            "submission_id": "d85c4b55601d9366310c1a76c76ad7a05a80c80763569dd17fc0e3e464add4d7",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:ca246e44-e0bb-45e2-9e92-bda8a34a57ff",
            "event_time": "2023-05-27 17:59:20",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "0.0"
        },
        "f5c58761ed0a279bd9633d20ee74484fb85494e409d810b78fa83d39cc34d885": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n\n\n        # initialize additional fields here\n\n        self.ram_count = self.ram_size()\n\n        self.ordered_ram = deque()\n\n        self.disk_count = self.disk_size()\n\n\n\n    def remove_least_recent_entry_from_disk_cache(self):\n\n        '''\n\n        Remove least recent entry from disk cache. \n\n        '''\n\n        with open(self.cache_disk, \"r\") as f:\n\n            lines = f.readlines()\n\n        with open(self.cache_disk, \"w\") as f:\n\n            for idx, line in enumerate(lines):\n\n                if idx==0:\n\n                    continue\n\n                f.write(line)\n\n                    \n\n    def get(self, new_text):\n\n        # 1. First check the RAM cache - O(ram_max)\n\n        rating = self.get_from_ram_cache(new_text)\n\n        if rating:\n\n            self.ordered_ram.remove(new_text)\n\n            self.ordered_ram.append(new_text)\n\n\n\n            return rating\n\n        \n\n        # 2. If not found in the RAM cache, check in the disk cache - O(disk_max)\n\n        rating = self.get_from_disk_cache(new_text)\n\n        if rating:\n\n            self.remove_from_disk_cache(new_text)\n\n            self.add_to_disk_cache(new_text, rating)\n\n            \n\n            return rating\n\n        \n\n        # If not found in 1) or 2), compute the prediction and add it to caches.\n\n        rating = predict(new_text)\n\n        if self.ram_count == self.ram_max:\n\n            removed_text = self.ordered_ram.popleft()\n\n            removed_rating = self.get_from_ram_cache(removed_text)\n\n            self.remove_from_ram_cache(removed_text)\n\n            self.ram_count = self.ram_count - 1\n\n            \n\n            if self.disk_count == self.disk_max:\n\n                self.remove_least_recent_entry_from_disk_cache()\n\n                self.disk_count = self.disk_count - 1\n\n            \n\n            self.add_to_disk_cache(removed_text, removed_rating)\n\n            self.disk_count = self.disk_count + 1\n\n        \n\n        self.add_to_ram_cache(new_text, rating)\n\n        self.ordered_ram.append(new_text)\n\n        self.ram_count = self.ram_count + 1\n\n    \n\n        return rating",
            "diff_index": 56,
            "id": 1876,
            "person_id": "f5c58761ed0a279bd9633d20ee74484fb85494e409d810b78fa83d39cc34d885",
            "submission_id": "85cd85e9b3f4e004c727158af09387ed3f2f9ca3a032bd42b66f9279190c9db3",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:ec76ab76-a873-43dc-b9f3-6bbe9ff409dd",
            "event_time": "2023-05-27 10:08:42",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "95.0"
        },
        "763924b13b6d8bf48fbc77c97d94512d37dd192cfa7ced0ba3a08b86eadf099f": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1829,
            "person_id": "763924b13b6d8bf48fbc77c97d94512d37dd192cfa7ced0ba3a08b86eadf099f",
            "submission_id": "a3510d0d3504afddf98c7d6a462882bb2fdc5d3664411df290093da8d372c33d",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:dc484de5-ef23-4fd6-ad92-299a0bf619ad",
            "event_time": "2023-05-30 00:44:34",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "0.0"
        },
        "2f62b30a336d58eb746cbb7acfbe72d46621d58d0722b697e22867025f4187d8": {
            "question": "### Question 7.2: \"Most recent\" caching strategy (10 points)\n\n\n\nLet's implement the form of caching that is based on temporal locality. We first denote `ram_max` and `disk_max` as the maximum number of elements that can be stored in RAM (hot storage) and in disk (cold storage) respectively. Here each element is a pair of review text and predicted rating. Given a new review text, which we denote as `new_text`, the caching algorithm works as follows:\n\n\n\n```\n\nIf new_text is in the RAM cache, return its stored predicted rating, and mark this pair of (new_text, stored predicted rating) as the most recent element in RAM.\n\nIf the hashed value of new_text is in the disk cache, return its stored predicted rating, and mark this pair of (hashed_new_text, stored predicted rating) as the most recent element in disk.\n\nIf the above cases do not apply, compute the predicted rating of new_text, which we denote as predicted_rating. Then:\n\n    If the RAM cache's size is equal to ram_max:\n\n        If the disk cache's size is equal to disk_max, remove the least recent element from the disk cache.\n\n        Move the least recent element in the RAM cache to the disk cache (i.e., remove it from RAM cache and add it to disk cache).\n\n    Store the pair (text, predicted_value) in RAM cache\n\n    Update the most recent element in ram / disk and return predicted_rating \n\n```\n\n\n\n**Notes**:\n\n* Note that `MostRecentCache` inherits from `Cache`, so you are able to use or overwrite the methods in `Cache`. You are also free to modify the `Cache` class above, although doing so is not required.\n\n* You may need to initialize additional fields in the constructor to hold metadata about the RAM cache and disk cache.",
            "answer": "class MostRecentCache(Cache):\n\n    def __init__(self, ram_max, disk_max):\n\n        '''\n\n        Args:\n\n            ram_max (Integer) - max number of elements that at any moment of time should be in hot storage\n\n            disk_max (Integer) - max number of elements that at any moment of time should be in cold storage\n\n        '''\n\n        super().__init__()\n\n        self.ram_max = ram_max\n\n        self.disk_max = disk_max\n\n        \n\n        # initialize additional fields here\n\n        \n\n    def get(self, new_text):\n\n        # implement the caching algorithm\n\n        raise NotImplementedError(\"Complete this function!\")",
            "diff_index": 56,
            "id": 1852,
            "person_id": "2f62b30a336d58eb746cbb7acfbe72d46621d58d0722b697e22867025f4187d8",
            "submission_id": "7ad15bb3f937b9dcb821e0c5c66cb6090ca9e79ec3aabdd23210bf5b9f9a466b",
            "module_name": "Computer Systems and Data Structures",
            "module_slug": "project-learn-computer-s-xzlhdpgb",
            "task_name": "Build website backend",
            "task_slug": "fe96f377-587b-4a1e-9d73-8325c2abf1d6",
            "event_id": "urn:id:faf19469-0fd8-4878-ad0d-1b40516ecfb8",
            "event_time": "2023-05-24 15:51:12",
            "module_date_to_activate": "2023-05-23 04:00:01",
            "module_date_to_submit": "2023-05-30 03:59:59",
            "score_obtained": "15.0"
        }
    }
}