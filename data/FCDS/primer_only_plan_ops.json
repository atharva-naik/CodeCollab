{
    "1.1. Series": {
        "codes": [
            "s = pd.Series({\"a\" : 10, \"b\" : 20, \"c\" : 30})",
            "s = pd.Series(x**2 for x in range(5, 10))"
        ],
        "path": "1. Series and Dataframes/1.1. Series"
    },
    "1.2. Dataframes": {
        "codes": [
            "pd.DataFrame([[1, 2], [3, 4], [5, 6]])",
            "pd.DataFrame([{\"a\" : 1}, {\"a\" : 2, \"b\" : 3}, {\"c\" : 4}])",
            "pd.DataFrame({\"a\" : [1, 3, 5, 7], \"b\" : range(4), \"c\" : np.ones(4)})",
            "df = pd.DataFrame({\"a\" : [1, 3, 5, 7], \"b\" : range(4), \"c\" : np.ones(4)}, index = [\"x\", \"y\", \"z\", \"h\"])",
            "pd.read_csv('example.csv')",
            "pd.read_csv('example.csv', index_col=False)",
            "pd.read_csv('example.tsv', delimiter='\t')",
            "pd.read_csv('example.tsv', dtype= {'a': np.float64, 'b': np.int32, 'c': 'Int64'})"
        ],
        "path": "1. Series and Dataframes/1.2. Dataframes"
    },
    "1.3. Data Access": {
        "codes": [
            "df.iloc[2,1]",
            "df.iloc[:,1]",
            "df.iloc[1:,:-1]",
            "df.loc[[\"x\"], [\"a\", \"c\"]]",
            "df.loc[\"y\":, :\"c\"]",
            "df.loc[[True, False, True, False], [False, True, False]]",
            "df[\"a\"]",
            "df[[\"b, \"c\"]])",
            "df[[True, False, False, True]]"
        ],
        "path": "1. Series and Dataframes/1.3. Data Access"
    },
    "1.4. Dealing with SettingWithCopyWarning": {
        "codes": [
            "column = df[\"a\"]\n    column[0] = 100",
            "df.loc[0, \"a\"] = 100",
            "column = df[\"a\"].copy()\n    column[0] = 100"
        ],
        "path": "1. Series and Dataframes/1.4. Dealing with SettingWithCopyWarning"
    },
    "convert NumPy matrix to Pandas dataframe": {
        "codes": [
            "df = pd.DataFrame(np.arange(5000).reshape(1000, 5))",
            "s = pd.Series(np.random.randint(low = 0, high = 10, size = 1000))",
            "import string\n# series of random alphabet letters\nnp.random.seed(0)\ns = pd.Series(np.random.choice(list(string.ascii_letters), size = 1000))",
            "df = pd.DataFrame(np.random.randint(0, 10, size = 5000).reshape(1000, 5))"
        ],
        "path": "1. Series and Dataframes/1.5. Pandas and NumPy/convert NumPy matrix to Pandas dataframe"
    },
    "convert Pandas dataframe to Numpy matrix": {
        "codes": [
            "df.values"
        ],
        "path": "1. Series and Dataframes/1.5. Pandas and NumPy/convert Pandas dataframe to Numpy matrix"
    },
    "elementwise operation between multiple series": {
        "codes": [
            "s + s/2 - s**2"
        ],
        "path": "2.1. Series iteration/elementwise operation between multiple series"
    },
    "frequency count for each unique value": {
        "codes": [
            "s.value_counts()"
        ],
        "path": "2.1. Series iteration/frequency count for each unique value"
    },
    "data overview": {
        "codes": [
            "s.describe()"
        ],
        "path": "2.1. Series iteration/data overview"
    },
    "standard numerical operations": {
        "codes": [
            "s.sum()",
            "s.std()",
            "s.mean()",
            "df.sum(axis = 0)",
            "df.sum(axis = 1)",
            "cur_genre_rating['rating'].mean()",
            "genre_df['rating'].mean()",
            "genres_rating_cnt.sum()",
            "for (_, row) in ratings.iterrows():\n    item_id = row['item_id']\n    rating = row['rating']\n    if item_id in id_to_rating:\n        id_to_rating[item_id][0] += rating\n        id_to_rating[item_id][1] += 1\n    else:\n        id_to_rating[item_id] = [rating, 1]",
            "np.mean(nonzero_ratings_i)",
            "np.mean(nonzero_ratings_j)",
            "tmp_mat.mean(axis=1)",
            "tmp_mat.mean(axis=0)"
        ],
        "path": "2.1. Series iteration/standard numerical operations"
    },
    "extract unique values": {
        "codes": [
            "s.unique()",
            "s.nunique()",
            "ratings['item_id'].unique()",
            "ratings['user_id'].nunique()",
            "ratings['item_id'].nunique()"
        ],
        "path": "2.1. Series iteration/extract unique values"
    },
    "convert to lower case": {
        "codes": [
            "s.str.lower()"
        ],
        "path": "2.1. Series iteration/convert to lower case"
    },
    "get string length": {
        "codes": [
            "s.str.len()"
        ],
        "path": "2.1. Series iteration/get string length"
    },
    "lowercase strings and replace": {
        "codes": [
            "s.str.lower().str.replace('s', '*')",
            "s.apply(lambda x: x.lower().replace('s', '*'))"
        ],
        "path": "2.1. Series iteration/lowercase strings and replace"
    },
    "dataframe iteration": {
        "codes": [
            "for col in df.columns:",
            "for index, row in df.iterrows():"
        ],
        "path": "2.2 DataFrame iteration/dataframe iteration"
    },
    "Sum of every column in the dataframe": {
        "codes": [
            "df.sum(axis = 0)"
        ],
        "path": "2.2 DataFrame iteration/Sum of every column in the dataframe"
    },
    "Sum of every row in the dataframe": {
        "codes": [
            "df.sum(axis = 1)"
        ],
        "path": "2.2 DataFrame iteration/Sum of every row in the dataframe"
    },
    "data filtering": {
        "codes": [
            "df.loc[:, (df%2 == 1).sum(axis = 0) > len(df)/2]",
            "df[df.sum(axis = 1) % 3 == 0]",
            "cur_genre = movies.loc[movies[genre] == 1]",
            "rslt_df = movies[movies[genre] == 1]",
            "genre_df = joined_df.loc[joined_df[genre] == 1]",
            "movie_ids = movies[movies[key] == 1].index",
            "m = movies[movies[i] == 1].index.values",
            "movie_by_genre = movies[movies[genre] == 1]",
            "df = df[df['value'] == 1]",
            "movie_genres = movies.loc[movies[genre] == 1]",
            "k = new_movies.loc[new_movies[g] == 1]",
            "movies_long = movies_long[movies_long.is_genre == 1]",
            "genre_df = movies.loc[movies[genre] == 1]",
            "count_df = count_df[filt]",
            "req_movies = movies_year[movies_year['release_year'] >= starting_year]",
            "if release_year < starting_year:\n    continue",
            "yearwise_ratings = yearwise_ratings[yearwise_ratings['release_year'] >= starting_year]",
            "ratings_movies_merged = ratings_movies_merged[ratings_movies_merged['release_year'] >= starting_year]",
            "df_movie_rating = df_movie_rating[df_movie_rating['release_year'] >= starting_year]",
            "monthtime_series = datetime_series.dt.month[yeartime_series >= year]",
            "ratings = ratings[ratings['timestamp'].dt.year == year]",
            "month_integrated_year = month_integrated[month_integrated['year'] == year]",
            "all_ratings = all_ratings.loc[all_ratings['rating', 'count'] > threshold]",
            "df2_robust = df2_robust[df2_robust['count'] > threshold]",
            "ratings_copy = ratings_copy[filt]",
            "df = df[df['counts'] > threshold]",
            "mean_ratings = mean_ratings[mean_ratings.item_id > threshold]",
            "ratings_count_avg = ratings_count_avg[ratings_count_avg['count'] > threshold]",
            "df = df[df['rating_count'] >= 50]",
            "nonzero_ratings_j = ratings_j[ratings_j != 0]",
            "nonzero_ratings_i = ratings_i[ratings_i != 0]"
        ],
        "path": "2.2 DataFrame iteration/data filtering"
    },
    "wide format dataframe": {
        "codes": [
            "df_wide = pd.DataFrame({\n    \"country\" : [\"A\", \"B\", \"C\"],\n    \"population_in_million\" : [100, 200, 120],\n    \"gdp_percapita\" : [2000, 7000, 15000]\n})\ndf_wide\n"
        ],
        "path": "3. Manipulating DataFrames/3.1. Conversion between long and wide formats/wide format dataframe"
    },
    "long format dataframe": {
        "codes": [
            "df_long = pd.DataFrame({\n    \"country\" : [\"A\", \"A\", \"B\", \"B\", \"C\", \"C\"],\n    \"attribute\" : [\"population_in_million\", \"gdp_percapita\"] * 3,\n    \"value\" : [100, 2000, 200, 7000, 120, 15000]\n})\ndf_long"
        ],
        "path": "3. Manipulating DataFrames/3.1. Conversion between long and wide formats/long format dataframe"
    },
    "convert from long to wide": {
        "codes": [
            "df_long.pivot_table(index = \"country\", columns = \"attribute\", values = \"value\")"
        ],
        "path": "3. Manipulating DataFrames/convert from long to wide"
    },
    "convert from wide to long": {
        "codes": [
            "df_wide.melt(id_vars = [\"country\"], value_vars = [\"population_in_million\", \"gdp_percapita\"], var_name = \"attribute\", value_name = \"value\")"
        ],
        "path": "3. Manipulating DataFrames/convert from wide to long"
    },
    "reset dataframe index (not in primer)": {
        "codes": [
            "df.reset_index()",
            "df.reset_index()",
            "by_month.reset_index(inplace=True)",
            "result.reset_index()",
            "df2.reset_index()"
        ],
        "path": "reset dataframe index (not in primer)"
    }
}