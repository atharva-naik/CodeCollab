{
    "User guide and tutorial": {
        "Opinionated defaults and flexible customization": [
            {
                "cell_type": "markdown",
                "nl_original": "# An introduction to seaborn"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Seaborn is a library for making statistical graphics in Python. It builds on top of  and integrates closely with  data structures."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Seaborn helps you explore and understand your data. Its plotting functions operate on dataframes and arrays containing whole datasets and internally perform the necessary semantic mapping and statistical aggregation to produce informative plots. Its dataset-oriented, declarative API lets you focus on what the different elements of your plots mean, rather than on the details of how to draw them."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Here\u2019s an example of what seaborn can do:"
            },
            {
                "cell_type": "code",
                "code": "# Import seaborn\nimport seaborn as sns\n\n# Apply the default theme\nsns.set_theme()\n\n# Load an example dataset\ntips = sns.load_dataset(\"tips\")\n\n# Create a visualization\nsns.relplot(\n    data=tips,\n    x=\"total_bill\", y=\"tip\", col=\"time\",\n    hue=\"smoker\", style=\"smoker\", size=\"size\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A few things have happened here. Let\u2019s go through them one by one:"
            },
            {
                "cell_type": "code",
                "code": "# Import seaborn\nimport seaborn as sns\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Seaborn is the only library we need to import for this simple example. By convention, it is imported with the shorthand sns."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Behind the scenes, seaborn uses matplotlib to draw its plots. For interactive work, it\u2019s recommended to use a Jupyter/IPython interface in , or else you\u2019ll have to call  when you want to see the plot."
            },
            {
                "cell_type": "code",
                "code": "# Apply the default theme\nsns.set_theme()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This uses the matplotlib rcParam system and will affect how all matplotlib plots look, even if you don\u2019t make them with seaborn. Beyond the default theme, there are , and you can independently control the style and scaling of the plot to quickly translate your work between presentation contexts (e.g., making a version of your figure that will have readable fonts when projected during a talk). If you like the matplotlib defaults or prefer a different theme, you can skip this step and still use the seaborn plotting functions."
            },
            {
                "cell_type": "code",
                "code": "# Load an example dataset\ntips = sns.load_dataset(\"tips\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Most code in the docs will use the  function to get quick access to an example dataset. There\u2019s nothing special about these datasets: they are just pandas dataframes, and we could have loaded them with  or built them by hand. Most of the examples in the documentation will specify data using pandas dataframes, but seaborn is very flexible about the  that it accepts."
            },
            {
                "cell_type": "code",
                "code": "# Create a visualization\nsns.relplot(\n    data=tips,\n    x=\"total_bill\", y=\"tip\", col=\"time\",\n    hue=\"smoker\", style=\"smoker\", size=\"size\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This plot shows the relationship between five variables in the tips dataset using a single call to the seaborn function . Notice how we provided only the names of the variables and their roles in the plot. Unlike when using matplotlib directly, it wasn\u2019t necessary to specify attributes of the plot elements in terms of the color values or marker codes. Behind the scenes, seaborn handled the translation from values in the dataframe to arguments that matplotlib understands. This declarative approach lets you stay focused on the questions that you want to answer, rather than on the details of how to control matplotlib."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## A high-level API for statistical graphics"
            },
            {
                "cell_type": "markdown",
                "nl_original": "There is no universally best way to visualize data. Different questions are best answered by different plots. Seaborn makes it easy to switch between different visual representations by using a consistent dataset-oriented API."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The function  is named that way because it is designed to visualize many different statistical <em>relationships</em>. While scatter plots are often effective, relationships where one variable represents a measure of time are better represented by a line. The  function has a convenient kind parameter that lets you easily switch to this alternate representation:"
            },
            {
                "cell_type": "code",
                "code": "dots = sns.load_dataset(\"dots\")\nsns.relplot(\n    data=dots, kind=\"line\",\n    x=\"time\", y=\"firing_rate\", col=\"align\",\n    hue=\"choice\", size=\"coherence\", style=\"choice\",\n    facet_kws=dict(sharex=False),\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Notice how the size and style parameters are used in both the scatter and line plots, but they affect the two visualizations differently: changing the marker area and symbol in the scatter plot vs the line width and dashing in the line plot. We did not need to keep those details in mind, letting us focus on the overall structure of the plot and the information we want it to convey."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Statistical estimation"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Often, we are interested in the <em>average</em> value of one variable as a function of other variables. Many seaborn functions will automatically perform the statistical estimation that is necessary to answer these questions:"
            },
            {
                "cell_type": "code",
                "code": "fmri = sns.load_dataset(\"fmri\")\nsns.relplot(\n    data=fmri, kind=\"line\",\n    x=\"timepoint\", y=\"signal\", col=\"region\",\n    hue=\"event\", style=\"event\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When statistical values are estimated, seaborn will use bootstrapping to compute confidence intervals and draw error bars representing the uncertainty of the estimate."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Statistical estimation in seaborn goes beyond descriptive statistics. For example, it is possible to enhance a scatterplot by including a linear regression model (and its uncertainty) using :"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(data=tips, x=\"total_bill\", y=\"tip\", col=\"time\", hue=\"smoker\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Distributional representations"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Statistical analyses require knowledge about the distribution of variables in your dataset. The seaborn function  supports several approaches to visualizing distributions. These include classic techniques like histograms and computationally-intensive approaches like kernel density estimation:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(data=tips, x=\"total_bill\", col=\"time\", kde=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Seaborn also tries to promote techniques that are powerful but less familiar, such as calculating and plotting the empirical cumulative distribution function of the data:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(data=tips, kind=\"ecdf\", x=\"total_bill\", col=\"time\", hue=\"smoker\", rug=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Plots for categorical data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Several specialized plot types in seaborn are oriented towards visualizing categorical data. They can be accessed through . These plots offer different levels of granularity. At the finest level, you may wish to see every observation by drawing a \u201cswarm\u201d plot: a scatter plot that adjusts the positions of the points along the categorical axis so that they don\u2019t overlap:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=tips, kind=\"swarm\", x=\"day\", y=\"total_bill\", hue=\"smoker\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Alternately, you could use kernel density estimation to represent the underlying distribution that the points are sampled from:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=tips, kind=\"violin\", x=\"day\", y=\"total_bill\", hue=\"smoker\", split=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Or you could show only the mean value and its confidence interval within each nested category:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=tips, kind=\"bar\", x=\"day\", y=\"total_bill\", hue=\"smoker\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Multivariate views on complex datasets"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Some seaborn functions combine multiple kinds of plots to quickly give informative summaries of a dataset. One, , focuses on a single relationship. It plots the joint distribution between two variables along with each variable\u2019s marginal distribution:"
            },
            {
                "cell_type": "code",
                "code": "penguins = sns.load_dataset(\"penguins\")\nsns.jointplot(data=penguins, x=\"flipper_length_mm\", y=\"bill_length_mm\", hue=\"species\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The other, , takes a broader view: it shows joint and marginal distributions for all pairwise relationships and for each variable, respectively:"
            },
            {
                "cell_type": "code",
                "code": "sns.pairplot(data=penguins, hue=\"species\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Lower-level tools for building figures"
            },
            {
                "cell_type": "markdown",
                "nl_original": "These tools work by combining  plotting functions with objects that manage the layout of the figure, linking the structure of a dataset to a . Both elements are part of the public API, and you can use them directly to create complex figures with only a few more lines of code:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.PairGrid(penguins, hue=\"species\", corner=True)\ng.map_lower(sns.kdeplot, hue=None, levels=5, color=\".2\")\ng.map_lower(sns.scatterplot, marker=\"+\")\ng.map_diag(sns.histplot, element=\"step\", linewidth=0, kde=True)\ng.add_legend(frameon=True)\ng.legend.set_bbox_to_anchor((.61, .6))\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Opinionated defaults and flexible customization"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Seaborn creates complete graphics with a single function call: when possible, its functions will automatically add informative axis labels and legends that explain the semantic mappings in the plot."
            },
            {
                "cell_type": "markdown",
                "nl_original": "In many cases, seaborn will also choose default values for its parameters based on characteristics of the data. For example, the  that we have seen so far used distinct hues (blue, orange, and sometimes green) to represent different levels of the categorical variables assigned to hue. When mapping a numeric variable, some functions will switch to a continuous gradient:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=penguins,\n    x=\"bill_length_mm\", y=\"bill_depth_mm\", hue=\"body_mass_g\"\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When you\u2019re ready to share or publish your work, you\u2019ll probably want to polish the figure beyond what the defaults achieve. Seaborn allows for several levels of customization. It defines multiple built-in  that apply to all figures, its functions have standardized parameters that can modify the semantic mappings for each plot, and additional keyword arguments are passed down to the underlying matplotlib artists, allowing even more control. Once you\u2019ve created a plot, its properties can be modified through both the seaborn API and by dropping down to the matplotlib layer for fine-grained tweaking:"
            },
            {
                "cell_type": "code",
                "code": "sns.set_theme(style=\"ticks\", font_scale=1.25)\ng = sns.relplot(\n    data=penguins,\n    x=\"bill_length_mm\", y=\"bill_depth_mm\", hue=\"body_mass_g\",\n    palette=\"crest\", marker=\"x\", s=100,\n)\ng.set_axis_labels(\"Bill length (mm)\", \"Bill depth (mm)\", labelpad=10)\ng.legend.set_title(\"Body mass (g)\")\ng.figure.set_size_inches(6.5, 4.5)\ng.ax.margins(.15)\ng.despine(trim=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Relationship to matplotlib"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Seaborn\u2019s integration with matplotlib allows you to use it across the many environments that matplotlib supports, including exploratory analysis in notebooks, real-time interaction in GUI applications, and archival output in a number of raster and vector formats."
            },
            {
                "cell_type": "markdown",
                "nl_original": "While you can be productive using only seaborn functions, full customization of your graphics will require some knowledge of matplotlib\u2019s concepts and API. One aspect of the learning curve for new users of seaborn will be knowing when dropping down to the matplotlib layer is necessary to achieve a particular customization. On the other hand, users coming from matplotlib will find that much of their knowledge transfers."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Matplotlib has a comprehensive and powerful API; just about any attribute of the figure can be changed to your liking. A combination of seaborn\u2019s high-level interface and matplotlib\u2019s deep customizability will allow you both to quickly explore your data and to create graphics that can be tailored into a  final product."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Next steps"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You have a few options for where to go next. You might first want to learn how to . Once that\u2019s done, you can browse the  to get a broader sense for what kind of graphics seaborn can produce. Or you can read through the rest of the  for a deeper discussion of the different tools and what they are designed to accomplish. If you have a specific plot in mind and want to know how to make it, you could check out the , which documents each function\u2019s parameters and shows many examples to illustrate usage."
            }
        ],
        "Combining multiple views on the data": [
            {
                "cell_type": "markdown",
                "nl_original": "# Overview of seaborn plotting functions"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Most of your interactions with seaborn will happen through a set of plotting functions. Later chapters in the tutorial will explore the specific features offered by each function. This chapter will introduce, at a high-level, the different kinds of functions that you will encounter."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Similar functions for similar tasks"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The seaborn namespace is flat; all of the functionality is accessible at the top level. But the code itself is hierarchically structured, with modules of functions that achieve similar visualization goals through different means. Most of the docs are structured around these modules: you\u2019ll encounter names like \u201crelational\u201d, \u201cdistributional\u201d, and \u201ccategorical\u201d."
            },
            {
                "cell_type": "markdown",
                "nl_original": "For example, the  defines functions that specialize in representing the distribution of datapoints. This includes familiar methods like the histogram:"
            },
            {
                "cell_type": "code",
                "code": "penguins = sns.load_dataset(\"penguins\")\nsns.histplot(data=penguins, x=\"flipper_length_mm\", hue=\"species\", multiple=\"stack\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Along with similar, but perhaps less familiar, options such as kernel density estimation:"
            },
            {
                "cell_type": "code",
                "code": "sns.kdeplot(data=penguins, x=\"flipper_length_mm\", hue=\"species\", multiple=\"stack\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Functions within a module share a lot of underlying code and offer similar features that may not be present in other components of the library (such as multiple=\"stack\" in the examples above). They are designed to facilitate switching between different visual representations as you explore a dataset, because different representations often have complementary strengths and weaknesses."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Figure-level vs. axes-level functions"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In addition to the different modules, there is a cross-cutting classification of seaborn functions as \u201caxes-level\u201d or \u201cfigure-level\u201d. The examples above are axes-level functions. They plot data onto a single matplotlib.pyplot.Axes object, which is the return value of the function."
            },
            {
                "cell_type": "markdown",
                "nl_original": "In contrast, figure-level functions interface with matplotlib through a seaborn object, usually a , that manages the figure. Each module has a single figure-level function, which offers a unitary interface to its various axes-level functions. The organization looks a bit like this:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "For example,  is the figure-level function for the distributions module. Its default behavior is to draw a histogram, using the same code as  behind the scenes:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(data=penguins, x=\"flipper_length_mm\", hue=\"species\", multiple=\"stack\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "To draw a kernel density plot instead, using the same code as , select it using the kind parameter:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(data=penguins, x=\"flipper_length_mm\", hue=\"species\", multiple=\"stack\", kind=\"kde\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You\u2019ll notice that the figure-level plots look mostly like their axes-level counterparts, but there are a few differences. Notably, the legend is placed outside the plot. They also have a slightly different shape (more on that shortly)."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The most useful feature offered by the figure-level functions is that they can easily create figures with multiple subplots. For example, instead of stacking the three distributions for each species of penguins in the same axes, we can \u201cfacet\u201d them by plotting each distribution across the columns of the figure:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(data=penguins, x=\"flipper_length_mm\", hue=\"species\", col=\"species\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The figure-level functions wrap their axes-level counterparts and pass the kind-specific keyword arguments (such as the bin size for a histogram) down to the underlying function. That means they are no less flexible, but there is a downside: the kind-specific parameters don\u2019t appear in the function signature or docstrings. Some of their features might be less discoverable, and you may need to look at two different pages of the documentation before understanding how to achieve a specific goal."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Axes-level functions make self-contained plots"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The axes-level functions are written to act like drop-in replacements for matplotlib functions. While they add axis labels and legends automatically, they don\u2019t modify anything beyond the axes that they are drawn into. That means they can be composed into arbitrarily-complex matplotlib figures with predictable results."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The axes-level functions call  internally, which hooks into the matplotlib state-machine interface so that they draw their plots on the \u201ccurrently-active\u201d axes. But they additionally accept an ax= argument, which integrates with the object-oriented interface and lets you specify exactly where each plot should go:"
            },
            {
                "cell_type": "code",
                "code": "f, axs = plt.subplots(1, 2, figsize=(8, 4), gridspec_kw=dict(width_ratios=[4, 3]))\nsns.scatterplot(data=penguins, x=\"flipper_length_mm\", y=\"bill_length_mm\", hue=\"species\", ax=axs[0])\nsns.histplot(data=penguins, x=\"species\", hue=\"species\", shrink=.8, alpha=.8, legend=False, ax=axs[1])\nf.tight_layout()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Figure-level functions own their figure"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In contrast, figure-level functions cannot (easily) be composed with other plots. By design, they \u201cown\u201d their own figure, including its initialization, so there\u2019s no notion of using a figure-level function to draw a plot onto an existing axes. This constraint allows the figure-level functions to implement features such as putting the legend outside of the plot."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Nevertheless, it is possible to go beyond what the figure-level functions offer by accessing the matplotlib axes on the object that they return and adding other elements to the plot that way:"
            },
            {
                "cell_type": "code",
                "code": "tips = sns.load_dataset(\"tips\")\ng = sns.relplot(data=tips, x=\"total_bill\", y=\"tip\")\ng.ax.axline(xy1=(10, 2), slope=.2, color=\"b\", dashes=(5, 2))\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Customizing plots from a figure-level function"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The figure-level functions return a  instance, which has a few methods for customizing attributes of the plot in a way that is \u201csmart\u201d about the subplot organization. For example, you can change the labels on the external axes using a single line of code:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.relplot(data=penguins, x=\"flipper_length_mm\", y=\"bill_length_mm\", col=\"sex\")\ng.set_axis_labels(\"Flipper length (mm)\", \"Bill length (mm)\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "While convenient, this does add a bit of extra complexity, as you need to remember that this method is not part of the matplotlib API and exists only when using a figure-level function."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Specifying figure sizes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "To increase or decrease the size of a matplotlib plot, you set the width and height of the entire figure, either in the , while setting up the plot (e.g. with the figsize parameter of ), or by calling a method on the figure object (e.g. matplotlib.Figure.set_size_inches()). When using an axes-level function in seaborn, the same rules apply: the size of the plot is determined by the size of the figure it is part of and the axes layout in that figure."
            },
            {
                "cell_type": "markdown",
                "nl_original": "When using a figure-level function, there are several key differences. First, the functions themselves have parameters to control the figure size (although these are actually parameters of the underlying  that manages the figure). Second, these parameters, height and aspect, parameterize the size slightly differently than the width, height parameterization in matplotlib (using the seaborn parameters, width = height * aspect). Most importantly, the parameters correspond to the size of each <em>subplot</em>, rather than the size of the overall figure."
            },
            {
                "cell_type": "markdown",
                "nl_original": "To illustrate the difference between these approaches, here is the default output of  with one subplot:"
            },
            {
                "cell_type": "code",
                "code": "f, ax = plt.subplots()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A figure with multiple columns will have the same overall size, but the axes will be squeezed horizontally to fit in the space:"
            },
            {
                "cell_type": "code",
                "code": "f, ax = plt.subplots(1, 2, sharey=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In contrast, a plot created by a figure-level function will be square. To demonstrate that, let\u2019s set up an empty plot by using  directly. This happens behind the scenes in functions like , , or :"
            },
            {
                "cell_type": "code",
                "code": "g = sns.FacetGrid(penguins)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When additional columns are added, the figure itself will become wider, so that its subplots have the same size and shape:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.FacetGrid(penguins, col=\"sex\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "And you can adjust the size and shape of each subplot without accounting for the total number of rows and columns in the figure:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.FacetGrid(penguins, col=\"sex\", height=3.5, aspect=.75)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The upshot is that you can assign faceting variables without stopping to think about how you\u2019ll need to adjust the total figure size. A downside is that, when you do want to change the figure size, you\u2019ll need to remember that things work a bit differently than they do in matplotlib."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Relative merits of figure-level functions"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Here is a summary of the pros and cons that we have discussed above:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "On balance, the figure-level functions add some additional complexity that can make things more confusing for beginners, but their distinct features give them additional power. The tutorial documentation mostly uses the figure-level functions, because they produce slightly cleaner plots, and we generally recommend their use for most applications. The one situation where they are not a good choice is when you need to make a complex, standalone figure that composes multiple different plot kinds. At this point, it\u2019s recommended to set up the figure using matplotlib directly and to fill in the individual components using axes-level functions."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Combining multiple views on the data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Two important plotting functions in seaborn don\u2019t fit cleanly into the classification scheme discussed above. These functions,  and , employ multiple kinds of plots from different modules to represent multiple aspects of a dataset in a single figure. Both plots are figure-level functions and create figures with multiple subplots by default. But they use different objects to manage the figure:  and , respectively."
            },
            {
                "cell_type": "markdown",
                "nl_original": " plots the relationship or joint distribution of two variables while adding marginal axes that show the univariate distribution of each one separately:"
            },
            {
                "cell_type": "code",
                "code": "sns.jointplot(data=penguins, x=\"flipper_length_mm\", y=\"bill_length_mm\", hue=\"species\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": " is similar \u2014 it combines joint and marginal views \u2014 but rather than focusing on a single relationship, it visualizes every pairwise combination of variables simultaneously:"
            },
            {
                "cell_type": "code",
                "code": "sns.pairplot(data=penguins, hue=\"species\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Behind the scenes, these functions are using axes-level functions that you have already met ( and ), and they also have a kind parameter that lets you quickly swap in a different representation:"
            },
            {
                "cell_type": "code",
                "code": "sns.jointplot(data=penguins, x=\"flipper_length_mm\", y=\"bill_length_mm\", hue=\"species\", kind=\"hist\")\n"
            }
        ],
        "Options for visualizing wide-form data": [
            {
                "cell_type": "markdown",
                "nl_original": "# Data structures accepted by seaborn"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As a data visualization library, seaborn requires that you provide it with data. This chapter explains the various ways to accomplish that task. Seaborn supports several different dataset formats, and most functions accept data represented with objects from the  or  libraries as well as built-in Python types like lists and dictionaries. Understanding the usage patterns associated with these different options will help you quickly create useful visualizations for nearly any dataset."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As of current writing (v0.11.0), the full breadth of options covered here are supported by only a subset of the modules in seaborn (namely, the  and  modules). The other modules offer much of the same flexibility, but have some exceptions (e.g.,  and  are limited to long-form data with named variables). The data-ingest code will be standardized over the next few release cycles, but until that point, be mindful of the specific documentation for each function if it is not doing what you expect with your dataset."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Long-form vs. wide-form data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Most plotting functions in seaborn are oriented towards <em>vectors</em> of data. When plotting x against y, each variable should be a vector. Seaborn accepts data <em>sets</em> that have more than one vector organized in some tabular fashion. There is a fundamental distinction between \u201clong-form\u201d and \u201cwide-form\u201d data tables, and seaborn will treat each differently."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Long-form data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A long-form data table has the following characteristics:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Each variable is a column"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Each observation is a row"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As a simple example, consider the \u201cflights\u201d dataset, which records the number of airline passengers who flew in each month from 1949 to 1960. This dataset has three variables (<em>year</em>, <em>month</em>, and number of <em>passengers</em>):"
            },
            {
                "cell_type": "code",
                "code": "flights = sns.load_dataset(\"flights\")\nflights.head()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "With long-form data, columns in the table are given roles in the plot by explicitly assigning them to one of the variables. For example, making a monthly plot of the number of passengers per year looks like this:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(data=flights, x=\"year\", y=\"passengers\", hue=\"month\", kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The advantage of long-form data is that it lends itself well to this explicit specification of the plot. It can accommodate datasets of arbitrary complexity, so long as the variables and observations can be clearly defined. But this format takes some getting used to, because it is often not the model of the data that one has in their head."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Wide-form data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "For simple datasets, it is often more intuitive to think about data the way it might be viewed in a spreadsheet, where the columns and rows contain <em>levels</em> of different variables. For example, we can convert the flights dataset into a wide-form organization by  \u201cpivoting\u201d it so that each column has each month\u2019s time series over years:"
            },
            {
                "cell_type": "code",
                "code": "flights_wide = flights.pivot(index=\"year\", columns=\"month\", values=\"passengers\")\nflights_wide.head()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Here we have the same three variables, but they are organized differently. The variables in this dataset are linked to the <em>dimensions</em> of the table, rather than to named fields. Each observation is defined by both the value at a cell in the table and the coordinates of that cell with respect to the row and column indices."
            },
            {
                "cell_type": "markdown",
                "nl_original": "With long-form data, we can access variables in the dataset by their name. That is not the case with wide-form data. Nevertheless, because there is a clear association between the dimensions of the table and the variable in the dataset, seaborn is able to assign those variables roles in the plot."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Seaborn treats the argument to data as wide form when neither x nor y are assigned."
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(data=flights_wide, kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This plot looks very  similar to the one before. Seaborn has assigned the index of the dataframe to x, the values of the dataframe to y, and it has drawn a separate line for each month. There is a notable difference between the two plots, however. When the dataset went through the \u201cpivot\u201d operation that converted it from long-form to wide-form, the information about what the values mean was lost. As a result, there is no y axis label. (The lines also have dashes here, because  has mapped the column variable to both the hue and style semantic so that the plot is more accessible. We didn\u2019t do that in the long-form case, but we could have by setting style=\"month\")."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Thus far, we did much less typing while using wide-form data and made nearly the same plot. This seems easier! But a big advantage of long-form data is that, once you have the data in the correct format, you no longer need to think about its <em>structure</em>. You can design your plots by thinking only about the variables contained within it. For example, to draw lines that represent the monthly time series for each year, simply reassign the variables:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(data=flights, x=\"month\", y=\"passengers\", hue=\"year\", kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "To achieve the same remapping with the wide-form dataset, we would need to transpose the table:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(data=flights_wide.transpose(), kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "(This example also illustrates another wrinkle, which is that seaborn currently considers the column variable in a wide-form dataset to be categorical regardless of its datatype, whereas, because the long-form variable is numeric, it is assigned a quantitative color palette and legend. This may change in the future)."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The absence of explicit variable assignments also means that each plot type needs to define a fixed mapping between the dimensions of the wide-form data and the roles in the plot. Because this natural mapping may vary across plot types, the results are less predictable when using wide-form data. For example, the  plots assign the <em>column</em> dimension of the table to x and then aggregate across the rows (ignoring the index):"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=flights_wide, kind=\"box\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When using pandas to represent wide-form data, you are limited to just a few variables (no more than three). This is because seaborn does not make use of multi-index information, which is how pandas represents additional variables in a tabular format. The  project offers labeled N-dimensional array objects, which can be considered a generalization of wide-form data to higher dimensions. At present, seaborn does not directly support objects from xarray, but they can be transformed into a long-form  using the to_pandas method and then plotted in seaborn like any other long-form data set."
            },
            {
                "cell_type": "markdown",
                "nl_original": "In summary, we can think of long-form and wide-form datasets as looking something like this:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Messy data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Many datasets cannot be clearly interpreted using either long-form or wide-form rules. If datasets that are clearly long-form or wide-form are , we might say that these more ambiguous datasets are \u201cmessy\u201d. In a messy dataset, the variables are neither uniquely defined by the keys nor by the dimensions of the table. This often occurs with <em>repeated-measures</em> data, where it is natural to organize a table such that each row corresponds to the <em>unit</em> of data collection. Consider this simple dataset from a psychology experiment in which twenty subjects performed a memory task where they studied anagrams while their attention was either divided or focused:"
            },
            {
                "cell_type": "code",
                "code": "anagrams = sns.load_dataset(\"anagrams\")\nanagrams\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The attention variable is <em>between-subjects</em>, but there is also a <em>within-subjects</em> variable: the number of possible solutions to the anagrams, which varied from 1 to 3. The dependent measure is a score of memory performance. These two variables (number and score) are jointly encoded across several columns. As a result, the whole dataset is neither clearly long-form nor clearly wide-form."
            },
            {
                "cell_type": "markdown",
                "nl_original": "How might we tell seaborn to plot the average score as a function of attention and number of solutions? We\u2019d first need to coerce the data into one of our two structures. Let\u2019s transform it to a tidy long-form table, such that each variable is a column and each row is an observation. We can use the method  to accomplish this task:"
            },
            {
                "cell_type": "code",
                "code": "anagrams_long = anagrams.melt(id_vars=[\"subidr\", \"attnr\"], var_name=\"solutions\", value_name=\"score\")\nanagrams_long.head()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Now we can make the plot that we want:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=anagrams_long, x=\"solutions\", y=\"score\", hue=\"attnr\", kind=\"point\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Further reading and take-home points"
            },
            {
                "cell_type": "markdown",
                "nl_original": "For a longer discussion about tabular data structures, you could read the  paper by Hadley Whickham. Note that seaborn uses a slightly different set of concepts than are defined in the paper. While the paper associates tidyness with long-form structure, we have drawn a distinction between \u201ctidy wide-form\u201d data, where there is a clear mapping between variables in the dataset and the dimensions of the table, and \u201cmessy data\u201d, where no such mapping exists."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The long-form structure has clear advantages. It allows you to create figures by explicitly assigning variables in the dataset to roles in plot, and you can do so with more than three variables. When possible, try to represent your data with a long-form structure when embarking on serious analysis. Most of the examples in the seaborn documentation will use long-form data. But in cases where it is more natural to keep the dataset wide, remember that seaborn can remain useful."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Options for visualizing long-form data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "While long-form data has a precise definition, seaborn is fairly flexible in terms of how it is actually organized across the data structures in memory. The examples in the rest of the documentation will typically use  objects and reference variables in them by assigning names of their columns to the variables in the plot. But it is also possible to store vectors in a Python dictionary or a class that implements that interface:"
            },
            {
                "cell_type": "code",
                "code": "flights_dict = flights.to_dict()\nsns.relplot(data=flights_dict, x=\"year\", y=\"passengers\", hue=\"month\", kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Many pandas operations, such as the split-apply-combine operations of a group-by, will produce a dataframe where information has moved from the columns of the input dataframe to the index of the output. So long as the name is retained, you can still reference the data as normal:"
            },
            {
                "cell_type": "code",
                "code": "flights_avg = flights.groupby(\"year\").mean()\nsns.relplot(data=flights_avg, x=\"year\", y=\"passengers\", kind=\"line\")\n"
            },
            {
                "cell_type": "code",
                "code": "/var/folders/qk/cdrdfhfn5g554pnb30pp4ylr0000gn/T/ipykernel_77263/885836857.py:1: FutureWarning: The default value of numeric_only in DataFrameGroupBy.mean is deprecated. In a future version, numeric_only will default to False. Either specify numeric_only or select only columns which should be valid for the function.\n  flights_avg = flights.groupby(\"year\").mean()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Additionally, it\u2019s possible to pass vectors of data directly as arguments to x, y, and other plotting variables. If these vectors are pandas objects, the name attribute will be used to label the plot:"
            },
            {
                "cell_type": "code",
                "code": "year = flights_avg.index\npassengers = flights_avg[\"passengers\"]\nsns.relplot(x=year, y=passengers, kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Numpy arrays and other objects that implement the Python sequence interface work too, but if they don\u2019t have names, the plot will not be as informative without further tweaking:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(x=year.to_numpy(), y=passengers.to_list(), kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Options for visualizing wide-form data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The options for passing wide-form data are even more flexible. As with long-form data, pandas objects are preferable because the name (and, in some cases, index) information can be used. But in essence, any format that can be viewed as a single vector or a collection of vectors can be passed to data, and a valid plot can usually be constructed."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The example we saw above used a rectangular , which can be thought of as a collection of its columns. A dict or list of pandas objects will also work, but we\u2019ll lose the axis labels:"
            },
            {
                "cell_type": "code",
                "code": "flights_wide_list = [col for _, col in flights_wide.items()]\nsns.relplot(data=flights_wide_list, kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The vectors in a collection do not need to have the same length. If they have an index, it will be used to align them:"
            },
            {
                "cell_type": "code",
                "code": "two_series = [flights_wide.loc[:1955, \"Jan\"], flights_wide.loc[1952:, \"Aug\"]]\nsns.relplot(data=two_series, kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Whereas an ordinal index will be used for numpy arrays or simple Python sequences:"
            },
            {
                "cell_type": "code",
                "code": "two_arrays = [s.to_numpy() for s in two_series]\nsns.relplot(data=two_arrays, kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "But a dictionary of such vectors will at least use the keys:"
            },
            {
                "cell_type": "code",
                "code": "two_arrays_dict = {s.name: s.to_numpy() for s in two_series}\nsns.relplot(data=two_arrays_dict, kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Rectangular numpy arrays are treated just like a dataframe without index information, so they are viewed as a collection of column vectors. Note that this is different from how numpy indexing operations work, where a single indexer will access a row. But it is consistent with how pandas would turn the array into a dataframe or how matplotlib would plot it:"
            },
            {
                "cell_type": "code",
                "code": "flights_array = flights_wide.to_numpy()\nsns.relplot(data=flights_array, kind=\"line\")\n"
            }
        ],
        "Customizing the appearance": [
            {
                "cell_type": "markdown",
                "nl_original": "# The seaborn.objects interface"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The seaborn.objects namespace was introduced in version 0.12 as a completely new interface for making seaborn plots. It offers a more consistent and flexible API, comprising a collection of composable classes for transforming and plotting data. In contrast to the existing seaborn functions, the new interface aims to support end-to-end plot specification and customization without dropping down to matplotlib (although it will remain possible to do so if necessary)."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The objects interface is currently experimental and incomplete. It is stable enough for serious use, but there certainly are some rough edges and missing features."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Specifying a plot and mapping data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The objects interface should be imported with the following convention:"
            },
            {
                "cell_type": "code",
                "code": "import seaborn.objects as so\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The seaborn.objects namespace will provide access to all of the relevant classes. The most important is . You specify plots by instantiating a  object and calling its methods. Let\u2019s see a simple example:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\")\n    .add(so.Dot())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This code, which produces a scatter plot, should look reasonably familiar. Just as when using , we passed a tidy dataframe (penguins) and assigned two of its columns to the x and y coordinates of the plot. But instead of starting with the type of chart and then adding some data assignments, here we started with the data assignments and then added a graphical element."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Setting properties"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  class is an example of a : an object that graphically represents data values. Each mark will have a number of properties that can be set to change its appearance:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\")\n    .add(so.Dot(color=\"g\", pointsize=4))\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Mapping properties"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As with seaborn\u2019s functions, it is also possible to <em>map</em> data values to various graphical properties:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(\n        penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\",\n        color=\"species\", pointsize=\"body_mass_g\",\n    )\n    .add(so.Dot())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "While this basic functionality is not novel, an important difference from the function API is that properties are mapped using the same parameter names that would set them directly (instead of having hue vs. color, etc.). What matters is <em>where</em> the property is defined: passing a value when you initialize  will set it directly, whereas assigning a variable when you set up the  will <em>map</em> the corresponding data."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Beyond this difference, the objects interface also allows a much wider range of mark properties to be mapped:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(\n        penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\",\n        edgecolor=\"sex\", edgewidth=\"body_mass_g\",\n    )\n    .add(so.Dot(color=\".8\"))\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Defining groups"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  mark represents each data point independently, so the assignment of a variable to a property only has the effect of changing each dot\u2019s appearance. For marks that group or connect observations, such as , it also determines the number of distinct graphical elements:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(healthexp, x=\"Year\", y=\"Life_Expectancy\", color=\"Country\")\n    .add(so.Line())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It is also possible to define a grouping without changing any visual properties, by using group:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(healthexp, x=\"Year\", y=\"Life_Expectancy\", group=\"Country\")\n    .add(so.Line())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Transforming data before plotting"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Statistical transformation"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As with many seaborn functions, the objects interface supports statistical transformations. These are performed by  objects, such as :"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"species\", y=\"body_mass_g\")\n    .add(so.Bar(), so.Agg())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In the function interface, statistical transformations are possible with some visual representations (e.g. ) but not others (e.g. ). The objects interface more cleanly separates representation and transformation, allowing you to compose  and  objects:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"species\", y=\"body_mass_g\")\n    .add(so.Dot(pointsize=10), so.Agg())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When forming groups by mapping properties, the  transformation is applied to each group separately:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"species\", y=\"body_mass_g\", color=\"sex\")\n    .add(so.Dot(pointsize=10), so.Agg())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Resolving overplotting"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Some seaborn functions also have mechanisms that automatically resolve overplotting, as when  \u201cdodges\u201d bars once hue is assigned. The objects interface has less complex default behavior. Bars representing multiple groups will overlap by default:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"species\", y=\"body_mass_g\", color=\"sex\")\n    .add(so.Bar(), so.Agg())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Nevertheless, it is possible to compose the  mark with the  stat and a second transformation, implemented by :"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"species\", y=\"body_mass_g\", color=\"sex\")\n    .add(so.Bar(), so.Agg(), so.Dodge())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  class is an example of a  transformation, which is like a  but only adjusts x and y coordinates. The  classes can be applied with any mark, and it\u2019s not necessary to use a  first:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"species\", y=\"body_mass_g\", color=\"sex\")\n    .add(so.Dot(), so.Dodge())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s also possible to apply multiple  operations in sequence:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"species\", y=\"body_mass_g\", color=\"sex\")\n    .add(so.Dot(), so.Dodge(), so.Jitter(.3))\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Creating variables through transformation"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  stat requires both x and y to already be defined, but variables can also be <em>created</em> through statistical transformation. For example, the  stat requires only one of x <em>or</em> y to be defined, and it will create the other by counting observations:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"species\")\n    .add(so.Bar(), so.Hist())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  stat will also create new x values (by binning) when given numeric data:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"flipper_length_mm\")\n    .add(so.Bars(), so.Hist())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Notice how we used , rather than  for the plot with the continuous x axis. These two marks are related, but  has different defaults and works better for continuous histograms. It also produces a different, more efficient matplotlib artist. You will find the pattern of singular/plural marks elsewhere. The plural version is typically optimized for cases with larger numbers of marks."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Some transforms accept both x and y, but add <em>interval</em> data for each coordinate. This is particularly relevant for plotting error bars after aggregating:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"body_mass_g\", y=\"species\", color=\"sex\")\n    .add(so.Range(), so.Est(errorbar=\"sd\"), so.Dodge())\n    .add(so.Dot(), so.Agg(), so.Dodge())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Orienting marks and transforms"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When aggregating, dodging, and drawing a bar, the x and y variables are treated differently. Each operation has the concept of an <em>orientation</em>. The  tries to determine the orientation automatically based on the data types of the variables. For instance, if we flip the assignment of species and body_mass_g, we\u2019ll get the same plot, but oriented horizontally:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"body_mass_g\", y=\"species\", color=\"sex\")\n    .add(so.Bar(), so.Agg(), so.Dodge())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Sometimes, the correct orientation is ambiguous, as when both the x and y variables are numeric. In these cases, you can be explicit by passing the orient parameter to :"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(tips, x=\"total_bill\", y=\"size\", color=\"time\")\n    .add(so.Bar(), so.Agg(), so.Dodge(), orient=\"y\")\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Building and displaying the plot"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Each example thus far has produced a single subplot with a single kind of mark on it. But  does not limit you to this."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Adding multiple layers"
            },
            {
                "cell_type": "markdown",
                "nl_original": "More complex single-subplot graphics can be created by calling  repeatedly. Each time it is called, it defines a <em>layer</em> in the plot. For example, we may want to add a scatterplot (now using ) and then a regression fit:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(tips, x=\"total_bill\", y=\"tip\")\n    .add(so.Dots())\n    .add(so.Line(), so.PolyFit())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Variable mappings that are defined in the  constructor will be used for all layers:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(tips, x=\"total_bill\", y=\"tip\", color=\"time\")\n    .add(so.Dots())\n    .add(so.Line(), so.PolyFit())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Layer-specific mappings"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can also define a mapping such that it is used only in a specific layer. This is accomplished by defining the mapping within the call to  for the relevant layer:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(tips, x=\"total_bill\", y=\"tip\")\n    .add(so.Dots(), color=\"time\")\n    .add(so.Line(color=\".2\"), so.PolyFit())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Alternatively, define the layer for the entire plot, but <em>remove</em> it from a specific layer by setting the variable to None:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(tips, x=\"total_bill\", y=\"tip\", color=\"time\")\n    .add(so.Dots())\n    .add(so.Line(color=\".2\"), so.PolyFit(), color=None)\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "To recap, there are three ways to specify the value of a mark property: (1) by mapping a variable in all layers, (2) by mapping a variable in a specific layer, and (3) by setting the property directy:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Faceting and pairing subplots"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As with seaborn\u2019s figure-level functions (, , etc.), the  interface can also produce figures with multiple \u201cfacets\u201d, or subplots containing subsets of data. This is accomplished with the  method:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"flipper_length_mm\")\n    .facet(\"species\")\n    .add(so.Bars(), so.Hist())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Call  with the variables that should be used to define the columns and/or rows of the plot:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"flipper_length_mm\")\n    .facet(col=\"species\", row=\"sex\")\n    .add(so.Bars(), so.Hist())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can facet using a variable with a larger number of levels by \u201cwrapping\u201d across the other dimension:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(healthexp, x=\"Year\", y=\"Life_Expectancy\")\n    .facet(col=\"Country\", wrap=3)\n    .add(so.Line())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "All layers will be faceted unless you explicitly exclude them, which can\nbe useful for providing additional context on each subplot:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(healthexp, x=\"Year\", y=\"Life_Expectancy\")\n    .facet(\"Country\", wrap=3)\n    .add(so.Line(alpha=.3), group=\"Country\", col=None)\n    .add(so.Line(linewidth=3))\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "An alternate way to produce subplots is . Like , this draws all of the data on each subplot, using different variables for the x and/or y coordinates:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, y=\"body_mass_g\", color=\"species\")\n    .pair(x=[\"bill_length_mm\", \"bill_depth_mm\"])\n    .add(so.Dots())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can combine faceting and pairing so long as the operations add subplots on opposite dimensions:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, y=\"body_mass_g\", color=\"species\")\n    .pair(x=[\"bill_length_mm\", \"bill_depth_mm\"])\n    .facet(row=\"sex\")\n    .add(so.Dots())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Integrating with matplotlib"
            },
            {
                "cell_type": "markdown",
                "nl_original": "There may be cases where you want multiple subplots to appear in a figure with a more complex structure than what  or  can provide. The current solution is to delegate figure setup to matplotlib and to supply the matplotlib object that  should use with the  method. This object can be either a , , or ; the latter is most useful for constructing bespoke subplot layouts:"
            },
            {
                "cell_type": "code",
                "code": "f = mpl.figure.Figure(figsize=(8, 4))\nsf1, sf2 = f.subfigures(1, 2)\n(\n    so.Plot(penguins, x=\"body_mass_g\", y=\"flipper_length_mm\")\n    .add(so.Dots())\n    .on(sf1)\n    .plot()\n)\n(\n    so.Plot(penguins, x=\"body_mass_g\")\n    .facet(row=\"sex\")\n    .add(so.Bars(), so.Hist())\n    .on(sf2)\n    .plot()\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Building and displaying the plot"
            },
            {
                "cell_type": "markdown",
                "nl_original": "An important thing to know is that  methods clone the object they are called on and return that clone instead of updating the object in place. This means that you can define a common plot spec and then produce several variations on it."
            },
            {
                "cell_type": "markdown",
                "nl_original": "So, take this basic specification:"
            },
            {
                "cell_type": "code",
                "code": "p = so.Plot(healthexp, \"Year\", \"Spending_USD\", color=\"Country\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "We could use it to draw a line plot:"
            },
            {
                "cell_type": "code",
                "code": "p.add(so.Line())\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Or perhaps a stacked area plot:"
            },
            {
                "cell_type": "code",
                "code": "p.add(so.Area(), so.Stack())\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  methods are fully declarative. Calling them updates the plot spec, but it doesn\u2019t actually do any plotting. One consequence of this is that methods can be called in any order, and many of them can be called multiple times."
            },
            {
                "cell_type": "markdown",
                "nl_original": "When does the plot actually get rendered?  is optimized for use in notebook environments. The rendering is automatically triggered when the  gets displayed in the Jupyter REPL. That\u2019s why we didn\u2019t see anything in the example above, where we defined a  but assigned it to p rather than letting it return out to the REPL."
            },
            {
                "cell_type": "markdown",
                "nl_original": "To see a plot in a notebook, either return it from the final line of a cell or call Jupyter\u2019s built-in display function on the object. The notebook integration bypasses  entirely, but you can use its figure-display machinery in other contexts by calling ."
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can also save the plot to a file (or buffer) by calling ."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Customizing the appearance"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The new interface aims to support a deep amount of customization through , reducing the need to switch gears and use matplotlib functionality directly. (But please be patient; not all of the features needed to achieve this goal have been implemented!)"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Parameterizing scales"
            },
            {
                "cell_type": "markdown",
                "nl_original": "All of the data-dependent properties are controlled by the concept of a  and the  method. This method accepts several different types of arguments. One possibility, which is closest to the use of scales in matplotlib, is to pass the name of a function that transforms the coordinates:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(diamonds, x=\"carat\", y=\"price\")\n    .add(so.Dots())\n    .scale(y=\"log\")\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": " can also control the mappings for semantic properties like color. You can directly pass it any argument that you would pass to the palette parameter in seaborn\u2019s function interface:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(diamonds, x=\"carat\", y=\"price\", color=\"clarity\")\n    .add(so.Dots())\n    .scale(color=\"flare\")\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Another option is to provide a tuple of (min, max) values, controlling the range that the scale should map into. This works both for numeric properties and for colors:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(diamonds, x=\"carat\", y=\"price\", color=\"clarity\", pointsize=\"carat\")\n    .add(so.Dots())\n    .scale(color=(\"#88c\", \"#555\"), pointsize=(2, 10))\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "For additional control, you can pass a  object. There are several different types of , each with appropriate parameters. For example,  lets you define the input domain (norm), the output range (values), and the function that maps between them (trans), while  allows you to specify an ordering:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(diamonds, x=\"carat\", y=\"price\", color=\"carat\", marker=\"cut\")\n    .add(so.Dots())\n    .scale(\n        color=so.Continuous(\"crest\", norm=(0, 3), trans=\"sqrt\"),\n        marker=so.Nominal([\"o\", \"+\", \"x\"], order=[\"Ideal\", \"Premium\", \"Good\"]),\n    )\n)\n"
            },
            {
                "cell_type": "code",
                "code": "/Users/mwaskom/code/seaborn/seaborn/_core/properties.py:370: RuntimeWarning: invalid value encountered in cast\n  ixs = np.asarray(x, np.intp)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Customizing legends and ticks"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  objects are also how you specify which values should appear as tick labels / in the legend, along with how they appear. For example, the  method lets you control the density or locations of the ticks, and the  method lets you modify the format:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(diamonds, x=\"carat\", y=\"price\", color=\"carat\")\n    .add(so.Dots())\n    .scale(\n        x=so.Continuous().tick(every=0.5),\n        y=so.Continuous().label(like=\"${x:.0f}\"),\n        color=so.Continuous().tick(at=[1, 2, 3, 4]),\n    )\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Customizing limits, labels, and titles"
            },
            {
                "cell_type": "markdown",
                "nl_original": " has a number of methods for simple customization, including , , and :"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"body_mass_g\", y=\"species\", color=\"island\")\n    .facet(col=\"sex\")\n    .add(so.Dot(), so.Jitter(.5))\n    .share(x=False)\n    .limit(y=(2.5, -.5))\n    .label(\n        x=\"Body mass (g)\", y=\"\",\n        color=str.capitalize,\n        title=\"{} penguins\".format,\n    )\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Theme customization"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Finally,  supports data-independent theming through the  method. Currently, this method accepts a dictionary of matplotlib rc parameters. You can set them directly and/or pass a package of parameters from seaborn\u2019s theming functions:"
            },
            {
                "cell_type": "code",
                "code": "from seaborn import axes_style\nso.Plot().theme({**axes_style(\"whitegrid\"), \"grid.linestyle\": \":\"})\n"
            }
        ],
        "Other properties": [
            {
                "cell_type": "markdown",
                "nl_original": "# Properties of Mark objects"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Coordinate properties"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### x, y, xmin, xmax, ymin, ymax"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Coordinate properties determine where a mark is drawn on a plot. Canonically, the x coordinate is the horizontal positon and the y coordinate is the vertical position. Some marks accept a span (i.e., min, max) parameterization for one or both variables. Others may accept x and y but also use a baseline parameter to show a span. The layer\u2019s orient parameter determines how this works."
            },
            {
                "cell_type": "markdown",
                "nl_original": "If a variable does not contain numeric data, its scale will apply a conversion so that data can be drawn on a screen. For instance, Nominal scales assign an integer index to each distinct category, and Temporal scales represent dates as the number of days from a reference \u201cepoch\u201d:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A Continuous scale can also apply a nonlinear transform between data values and spatial positions:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Color properties"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### color, fillcolor, edgecolor"
            },
            {
                "cell_type": "markdown",
                "nl_original": "All marks can be given a color, and many distinguish between the color of the mark\u2019s \u201cedge\u201d and \u201cfill\u201d. Often, simply using color will set both, while the more-specific properties allow further control:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When the color property is mapped, the default palette depends on the type of scale. Nominal scales use discrete, unordered hues, while continuous scales (including temporal ones) use a sequential gradient:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The default continuous scale is subject to change in future releases to improve discriminability."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Color scales are parameterized by the name of a palette, such as 'viridis', 'rocket', or 'deep'. Some palette names can include parameters, including simple gradients (e.g. 'dark:blue') or the cubehelix system (e.g. 'ch:start=.2,rot=-.4`). See the  for guidance on making an appropriate selection."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Continuous scales can also be parameterized by a tuple of colors that the scale should interpolate between. When using a nominal scale, it is possible to provide either the name of the palette (which will be discretely-sampled, if necessary), a list of individual color values, or a dictionary directly mapping data values to colors."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Individual colors may be specified . These include indexed references to the current color cycle ('C0'), single-letter shorthands ('b'), grayscale values ('.4'), RGB hex codes ('#4c72b0'), X11 color names ('seagreen'), and XKCD color survey names ('purpleish'):"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### alpha, fillalpha, edgealpha"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The alpha property determines the mark\u2019s opacity. Lowering the alpha can be helpful for representing density in the case of overplotting:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Mapping the alpha property can also be useful even when marks do not overlap because it conveys a sense of importance and can be combined with a color scale to represent two variables. Moreover, colors with lower alpha appear less saturated, which can improve the appearance of larger filled marks (such as bars)."
            },
            {
                "cell_type": "markdown",
                "nl_original": "As with color, some marks define separate edgealpha and fillalpha properties for additional control."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Style properties"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### fill"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The fill property is relevant to marks with a distinction between the edge and interior and determines whether the interior is visible. It is a boolean state: fill can be set only to True or False:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### marker"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The marker property is relevant for dot marks and some line marks. The API for specifying markers is very flexible, as detailed in the matplotlib API docs: ."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Markers can be specified using a number of simple string codes:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "They can also be programatically generated using a (num_sides, fill_style, angle) tuple:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "See the matplotlib docs for additional formats, including mathtex character codes ('$...$') and arrays of vertices."
            },
            {
                "cell_type": "markdown",
                "nl_original": "A marker property is always mapped with a nominal scale; there is no inherent ordering to the different shapes. If no scale is provided, the plot will programmatically generate a suitably large set of unique markers:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "While this ensures that the shapes are technically distinct, bear in mind that \u2014 in most cases \u2014\u00a0it will be difficult to tell the markers apart if more than a handful are used in a single plot."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The default marker scale is subject to change in future releases to improve discriminability."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### linestyle, edgestyle"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The linestyle property is relevant to line marks, and the edgestyle propety is relevant to a number of marks with \u201cedges. Both properties determine the \u201cdashing\u201d of a line in terms of on-off segments."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Dashes can be specified with a small number of shorthand codes ('-', '--', '-.', and ':') or programatically using (on, off, ...) tuples. In the tuple specification, the unit is equal to the linewidth:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Size properties"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### pointsize"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The pointsize property is relevant to dot marks and to line marks that can show markers at individual data points. The units correspond to the diameter of the mark in points."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The pointsize scales with the square root of the data by default so that magnitude is represented by diameter rather than area:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### linewidth"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The linewidth property is relevant to line marks and determines their thickness. The value should be non-negative and has point units:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### edgewidth"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The edgewidth property is akin to linewidth but applies to marks with an edge/fill rather than to lines. It also has a different default range when used in a scale. The units are the same:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### stroke"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The stroke property is akin to edgewidth but applies when a dot mark is defined by its stroke rather than its fill. It also has a slightly different default scale range, but otherwise behaves similarly:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Text properties"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### halign, valign"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The halign and valign properties control the <em>horizontal</em> and <em>vertical</em> alignment of text marks. The options for horizontal alignment are 'left', 'right', and 'center', while the options for vertical alignment are 'top', 'bottom', 'center', 'baseline', and 'center_baseline'."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### fontsize"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The fontsize property controls the size of textual marks. The value has point units:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### offset"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The offset property controls the spacing between a text mark and its anchor position. It applies when <em>not</em> using center alignment (i.e., when using left/right or top/bottom). The value has point units."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Other properties"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### text"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The text property is used to set the content of a textual mark. It is always used literally (not mapped), and cast to string when necessary."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### group"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The group property is special in that it does not change anything about the mark\u2019s appearance but defines additional data subsets that transforms should operate on independently."
            }
        ],
        "Showing multiple relationships with facets": [
            {
                "cell_type": "markdown",
                "nl_original": "# Visualizing statistical relationships"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Statistical analysis is a process of understanding how variables in a dataset relate to each other and how those relationships depend on other variables. Visualization can be a core component of this process because, when data are visualized properly, the human visual system can see trends and patterns that indicate a relationship."
            },
            {
                "cell_type": "markdown",
                "nl_original": "We will discuss three seaborn functions in this tutorial. The one we will use most is . This is a  for visualizing statistical relationships using two common approaches: scatter plots and line plots.  combines a  with one of two axes-level functions:"
            },
            {
                "cell_type": "markdown",
                "nl_original": " (with kind=\"scatter\"; the default)"
            },
            {
                "cell_type": "markdown",
                "nl_original": " (with kind=\"line\")"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As we will see, these functions can be quite illuminating because they use simple and easily-understood representations of data that can nevertheless represent complex dataset structures. They can do so because they plot two-dimensional graphics that can be enhanced by mapping up to three additional variables using the semantics of hue, size, and style."
            },
            {
                "cell_type": "code",
                "code": "import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_theme(style=\"darkgrid\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Relating variables with scatter plots"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The scatter plot is a mainstay of statistical visualization. It depicts the joint distribution of two variables using a cloud of points, where each point represents an observation in the dataset. This depiction allows the eye to infer a substantial amount of information about whether there is any meaningful relationship between them."
            },
            {
                "cell_type": "markdown",
                "nl_original": "There are several ways to draw a scatter plot in seaborn. The most basic, which should be used when both variables are numeric, is the  function. In the , we will see specialized tools for using scatterplots to visualize categorical data. The  is the default kind in  (it can also be forced by setting kind=\"scatter\"):"
            },
            {
                "cell_type": "code",
                "code": "tips = sns.load_dataset(\"tips\")\nsns.relplot(data=tips, x=\"total_bill\", y=\"tip\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "While the points are plotted in two dimensions, another dimension can be added to the plot by coloring the points according to a third variable. In seaborn, this is referred to as using a \u201chue semantic\u201d, because the color of the point gains meaning:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(data=tips, x=\"total_bill\", y=\"tip\", hue=\"smoker\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "To emphasize the difference between the classes, and to improve accessibility, you can use a different marker style for each class:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=tips,\n    x=\"total_bill\", y=\"tip\", hue=\"smoker\", style=\"smoker\"\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s also possible to represent four variables by changing the hue and style of each point independently. But this should be done carefully, because the eye is much less sensitive to shape than to color:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=tips,\n    x=\"total_bill\", y=\"tip\", hue=\"smoker\", style=\"time\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In the examples above, the hue semantic was categorical, so the default  was applied. If the hue semantic is numeric (specifically, if it can be cast to float), the default coloring switches to a sequential palette:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=tips, x=\"total_bill\", y=\"tip\", hue=\"size\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In both cases, you can customize the color palette. There are many options for doing so. Here, we customize a sequential palette using the string interface to :"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=tips,\n    x=\"total_bill\", y=\"tip\",\n    hue=\"size\", palette=\"ch:r=-.5,l=.75\"\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The third kind of semantic variable changes the size of each point:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(data=tips, x=\"total_bill\", y=\"tip\", size=\"size\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Unlike with , the literal value of the variable is not used to pick the area of the point. Instead, the range of values in data units is normalized into a range in area units. This range can be customized:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=tips, x=\"total_bill\", y=\"tip\",\n    size=\"size\", sizes=(15, 200)\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "More examples for customizing how the different semantics are used to show statistical relationships are shown in the  API examples."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Emphasizing continuity with line plots"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Scatter plots are highly effective, but there is no universally optimal type of visualisation. Instead, the visual representation should be adapted for the specifics of the dataset and to the question you are trying to answer with the plot."
            },
            {
                "cell_type": "markdown",
                "nl_original": "With some datasets, you may want to understand changes in one variable as a function of time, or a similarly continuous variable. In this situation, a good choice is to draw a line plot. In seaborn, this can be accomplished by the  function, either directly or with  by setting kind=\"line\":"
            },
            {
                "cell_type": "code",
                "code": "dowjones = sns.load_dataset(\"dowjones\")\nsns.relplot(data=dowjones, x=\"Date\", y=\"Price\", kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Aggregation and representing uncertainty"
            },
            {
                "cell_type": "markdown",
                "nl_original": "More complex datasets will have multiple measurements for the same value of the x variable. The default behavior in seaborn is to aggregate the multiple measurements at each x value by plotting the mean and the 95% confidence interval around the mean:"
            },
            {
                "cell_type": "code",
                "code": "fmri = sns.load_dataset(\"fmri\")\nsns.relplot(data=fmri, x=\"timepoint\", y=\"signal\", kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The confidence intervals are computed using bootstrapping, which can be time-intensive for larger datasets. It\u2019s therefore possible to disable them:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri, kind=\"line\",\n    x=\"timepoint\", y=\"signal\", errorbar=None,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Another good option, especially with larger data, is to represent the spread of the distribution at each timepoint by plotting the standard deviation instead of a confidence interval:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri, kind=\"line\",\n    x=\"timepoint\", y=\"signal\", errorbar=\"sd\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "To turn off aggregation altogether, set the estimator parameter to None This might produce a strange effect when the data have multiple observations at each point."
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri, kind=\"line\",\n    x=\"timepoint\", y=\"signal\",\n    estimator=None,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Plotting subsets of data with semantic mappings"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  function has the same flexibility as : it can show up to three additional variables by modifying the hue, size, and style of the plot elements. It does so using the same API as , meaning that we don\u2019t need to stop and think about the parameters that control the look of lines vs. points in matplotlib."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Using semantics in  will also determine how the data get aggregated. For example, adding a hue semantic with two levels splits the plot into two lines and error bands, coloring each to indicate which subset of the data they correspond to."
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri, kind=\"line\",\n    x=\"timepoint\", y=\"signal\", hue=\"event\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Adding a style semantic to a line plot changes the pattern of dashes in the line by default:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri, kind=\"line\",\n    x=\"timepoint\", y=\"signal\",\n    hue=\"region\", style=\"event\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "But you can identify subsets by the markers used at each observation, either together with the dashes or instead of them:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri, kind=\"line\",\n    x=\"timepoint\", y=\"signal\", hue=\"region\", style=\"event\",\n    dashes=False, markers=True,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As with scatter plots, be cautious about making line plots using multiple semantics. While sometimes informative, they can also be difficult to parse and interpret. But even when you are only examining changes across one additional variable, it can be useful to alter both the color and style of the lines. This can make the plot more accessible when printed to black-and-white or viewed by someone with color blindness:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri, kind=\"line\",\n    x=\"timepoint\", y=\"signal\", hue=\"event\", style=\"event\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When you are working with repeated measures data (that is, you have units that were sampled multiple times), you can also plot each sampling unit separately without distinguishing them through semantics. This avoids cluttering the legend:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri.query(\"event == 'stim'\"), kind=\"line\",\n    x=\"timepoint\", y=\"signal\", hue=\"region\",\n    units=\"subject\", estimator=None,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The default colormap and handling of the legend in  also depends on whether the hue semantic is categorical or numeric:"
            },
            {
                "cell_type": "code",
                "code": "dots = sns.load_dataset(\"dots\").query(\"align == 'dots'\")\nsns.relplot(\n    data=dots, kind=\"line\",\n    x=\"time\", y=\"firing_rate\",\n    hue=\"coherence\", style=\"choice\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It may happen that, even though the hue variable is numeric, it is poorly represented by a linear color scale. That\u2019s the case here, where the levels of the hue variable are logarithmically scaled. You can provide specific color values for each line by passing a list or dictionary:"
            },
            {
                "cell_type": "code",
                "code": "palette = sns.cubehelix_palette(light=.8, n_colors=6)\nsns.relplot(\n    data=dots, kind=\"line\",\n    x=\"time\", y=\"firing_rate\",\n    hue=\"coherence\", style=\"choice\", palette=palette,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Or you can alter how the colormap is normalized:"
            },
            {
                "cell_type": "code",
                "code": "from matplotlib.colors import LogNorm\npalette = sns.cubehelix_palette(light=.7, n_colors=6)\nsns.relplot(\n    data=dots.query(\"coherence &gt; 0\"), kind=\"line\",\n    x=\"time\", y=\"firing_rate\",\n    hue=\"coherence\", style=\"choice\",\n    hue_norm=LogNorm(),\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The third semantic, size, changes the width of the lines:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=dots, kind=\"line\",\n    x=\"time\", y=\"firing_rate\",\n    size=\"coherence\", style=\"choice\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "While the size variable will typically be numeric, it\u2019s also possible to map a categorical variable with the width of the lines. Be cautious when doing so, because it will be difficult to distinguish much more than \u201cthick\u201d vs \u201cthin\u201d lines. However, dashes can be hard to perceive when lines have high-frequency variability, so using different widths may be more effective in that case:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=dots, kind=\"line\",\n    x=\"time\", y=\"firing_rate\",\n    hue=\"coherence\", size=\"choice\", palette=palette,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Controlling sorting and orientation"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Because  assumes that you are most often trying to draw y as a function of x, the default behavior is to sort the data by the x values before plotting. However, this can be disabled:"
            },
            {
                "cell_type": "code",
                "code": "healthexp = sns.load_dataset(\"healthexp\").sort_values(\"Year\")\nsns.relplot(\n    data=healthexp, kind=\"line\",\n    x=\"Spending_USD\", y=\"Life_Expectancy\", hue=\"Country\",\n    sort=False\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s also possible to sort (and aggregate) along the y axis:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri, kind=\"line\",\n     x=\"signal\", y=\"timepoint\", hue=\"event\",\n    orient=\"y\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Showing multiple relationships with facets"
            },
            {
                "cell_type": "markdown",
                "nl_original": "We\u2019ve emphasized in this tutorial that, while these functions <em>can</em> show several semantic variables at once, it\u2019s not always effective to do so. But what about when you do want to understand how a relationship between two variables depends on more than one other variable?"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The best approach may be to make more than one plot. Because  is based on the , this is easy to do. To show the influence of an additional variable, instead of assigning it to one of the semantic roles in the plot, use it to \u201cfacet\u201d the visualization. This means that you make multiple axes and plot subsets of the data on each of them:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=tips,\n    x=\"total_bill\", y=\"tip\", hue=\"smoker\", col=\"time\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can also show the influence of two variables this way: one by faceting on the columns and one by faceting on the rows. As you start adding more variables to the grid, you may want to decrease the figure size. Remember that the size  is parameterized by the height and aspect ratio of <em>each facet</em>:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri, kind=\"line\",\n    x=\"timepoint\", y=\"signal\", hue=\"subject\",\n    col=\"region\", row=\"event\", height=3,\n    estimator=None\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When you want to examine effects across many levels of a variable, it can be a good idea to facet that variable on the columns and then \u201cwrap\u201d the facets into the rows:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri.query(\"region == 'frontal'\"), kind=\"line\",\n    x=\"timepoint\", y=\"signal\", hue=\"event\", style=\"event\",\n    col=\"subject\", col_wrap=5,\n    height=3, aspect=.75, linewidth=2.5,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "These visualizations, which are sometimes called \u201clattice\u201d plots or \u201csmall-multiples\u201d, are very effective because they present the data in a format that makes it easy for the eye to detect both overall patterns and deviations from those patterns. While you should make use of the flexibility afforded by  and , always try to keep in mind that several simple plots are usually more effective than one complex plot."
            }
        ],
        "Distribution visualization in other settings": [
            {
                "cell_type": "markdown",
                "nl_original": "# Visualizing distributions of data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "An early step in any effort to analyze or model data should be to understand how the variables are distributed. Techniques for distribution visualization can provide quick answers to many important questions. What range do the observations cover? What is their central tendency? Are they heavily skewed in one direction? Is there evidence for bimodality? Are there significant outliers? Do the answers to these questions vary across subsets defined by other variables?"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  contains several functions designed to answer questions such as these. The axes-level functions are , , , and . They are grouped together within the figure-level , , and  functions."
            },
            {
                "cell_type": "markdown",
                "nl_original": "There are several different approaches to visualizing a distribution, and each has its relative advantages and drawbacks. It is important to understand these factors so that you can choose the best approach for your particular aim."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Plotting univariate histograms"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Perhaps the most common approach to visualizing a distribution is the <em>histogram</em>. This is the default approach in , which uses the same underlying code as . A histogram is a bar plot where the axis representing the data variable is divided into a set of discrete bins and the count of observations falling within each bin is shown using the height of the corresponding bar:"
            },
            {
                "cell_type": "code",
                "code": "penguins = sns.load_dataset(\"penguins\")\nsns.displot(penguins, x=\"flipper_length_mm\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This plot immediately affords a few insights about the flipper_length_mm variable. For instance, we can see that the most common flipper length is about 195 mm, but the distribution appears bimodal, so this one number does not represent the data well."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Choosing the bin size"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The size of the bins is an important parameter, and using the wrong bin size can mislead by obscuring important features of the data or by creating apparent features out of random variability. By default, / choose a default bin size based on the variance of the data and the number of observations. But you should not be over-reliant on such automatic approaches, because they depend on particular assumptions about the structure of your data. It is always advisable to check that your impressions of the distribution are consistent across different bin sizes. To choose the size directly, set the binwidth parameter:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", binwidth=3)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In other circumstances, it may make more sense to specify the <em>number</em> of bins, rather than their size:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", bins=20)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "One example of a situation where defaults fail is when the variable takes a relatively small number of integer values. In that case, the default bin width may be too small, creating awkward gaps in the distribution:"
            },
            {
                "cell_type": "code",
                "code": "tips = sns.load_dataset(\"tips\")\nsns.displot(tips, x=\"size\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "One approach would be to specify the precise bin breaks by passing an array to bins:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(tips, x=\"size\", bins=[1, 2, 3, 4, 5, 6, 7])\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This can also be accomplished by setting discrete=True, which chooses bin breaks that represent the unique values in a dataset with bars that are centered on their corresponding value."
            },
            {
                "cell_type": "code",
                "code": "sns.displot(tips, x=\"size\", discrete=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s also possible to visualize the distribution of a categorical variable using the logic of a histogram. Discrete bins are automatically set for categorical variables, but it may also be helpful to \u201cshrink\u201d the bars slightly to emphasize the categorical nature of the axis:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(tips, x=\"day\", shrink=.8)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Conditioning on other variables"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Once you understand the distribution of a variable, the next step is often to ask whether features of that distribution differ across other variables in the dataset. For example, what accounts for the bimodal distribution of flipper lengths that we saw above?  and  provide support for conditional subsetting via the hue semantic. Assigning a variable to hue will draw a separate histogram for each of its unique values and distinguish them by color:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"species\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "By default, the different histograms are \u201clayered\u201d on top of each other and, in some cases, they may be difficult to distinguish. One option is to change the visual representation of the histogram from a bar plot to a \u201cstep\u201d plot:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"species\", element=\"step\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Alternatively, instead of layering each bar, they can be \u201cstacked\u201d, or moved vertically. In this plot, the outline of the full histogram will match the plot with only a single variable:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"species\", multiple=\"stack\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The stacked histogram emphasizes the part-whole relationship between the variables, but it can obscure other features (for example, it is difficult to determine the mode of the Adelie distribution. Another option is \u201cdodge\u201d the bars, which moves them horizontally and reduces their width. This ensures that there are no overlaps and that the bars remain comparable in terms of height. But it only works well when the categorical variable has a small number of levels:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"sex\", multiple=\"dodge\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Because  is a figure-level function and is drawn onto a , it is also possible to draw each individual distribution in a separate subplot by assigning the second variable to col or row rather than (or in addition to) hue. This represents the distribution of each subset well, but it makes it more difficult to draw direct comparisons:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", col=\"sex\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "None of these approaches are perfect, and  we will soon see some alternatives to a histogram that are better-suited to the task of comparison."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Normalized histogram statistics"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Before we do, another point to note is that, when the subsets have unequal numbers of observations, comparing their distributions in terms of counts may not be ideal. One solution is to <em>normalize</em> the counts using the stat parameter:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"species\", stat=\"density\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "By default, however, the normalization is applied to the entire distribution, so this simply rescales the height of the bars. By setting common_norm=False, each subset will be normalized independently:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"species\", stat=\"density\", common_norm=False)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Density normalization scales the bars so that their <em>areas</em> sum to 1. As a result, the density axis is not directly interpretable. Another option is to normalize the bars to that their <em>heights</em> sum to 1. This makes most sense when the variable is discrete, but  it is an option for all histograms:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"species\", stat=\"probability\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Kernel density estimation"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A histogram aims to approximate the underlying probability density function that generated the data by binning and counting observations. Kernel density estimation (KDE) presents a different solution to the same problem. Rather than using discrete bins, a KDE plot smooths the observations with a Gaussian kernel, producing a continuous density estimate:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", kind=\"kde\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Choosing the smoothing bandwidth"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Much like with the bin size in the histogram, the ability of the KDE to accurately represent the data depends on the choice of smoothing bandwidth. An over-smoothed estimate might erase meaningful features, but an under-smoothed estimate can obscure the true shape within random noise. The easiest way to check the robustness of the estimate is to adjust the default bandwidth:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", kind=\"kde\", bw_adjust=.25)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note how the narrow bandwidth makes the bimodality much more apparent, but the curve is much less smooth. In contrast, a larger bandwidth obscures the bimodality almost completely:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", kind=\"kde\", bw_adjust=2)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Conditioning on other variables"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As with histograms, if you assign a hue variable, a separate density estimate will be computed for each level of that variable:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"species\", kind=\"kde\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In many cases, the layered KDE is easier to interpret than the layered histogram, so it is often a good choice for the task of comparison. Many of the same options for resolving multiple distributions apply to the KDE as well, however:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"species\", kind=\"kde\", multiple=\"stack\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note how the stacked plot filled in the area between each curve by default. It is also possible to fill in the curves for single or layered densities, although the default alpha value (opacity) will be different, so that the individual densities are easier to resolve."
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"species\", kind=\"kde\", fill=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Kernel density estimation pitfalls"
            },
            {
                "cell_type": "markdown",
                "nl_original": "KDE plots have many advantages. Important features of the data are easy to discern (central tendency, bimodality, skew), and they afford easy comparisons between subsets. But there are also situations where KDE poorly represents the underlying data. This is because the logic of KDE assumes that the underlying distribution is smooth and unbounded. One way this assumption can fail is when a variable reflects a quantity that is naturally bounded. If there are observations lying close to the bound (for example, small values of a variable that cannot be negative), the KDE curve may extend to unrealistic values:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(tips, x=\"total_bill\", kind=\"kde\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This can be partially avoided with the cut parameter, which specifies how far the curve should extend beyond the extreme datapoints. But this influences only where the curve is drawn; the density estimate will still smooth over the range where no data can exist, causing it to be artificially low at the extremes of the distribution:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(tips, x=\"total_bill\", kind=\"kde\", cut=0)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The KDE approach also fails for discrete data or when data are naturally continuous but specific values are over-represented. The important thing to keep in mind is that the KDE will <em>always show you a smooth curve</em>, even when the data themselves are not smooth. For example, consider this distribution of diamond weights:"
            },
            {
                "cell_type": "code",
                "code": "diamonds = sns.load_dataset(\"diamonds\")\nsns.displot(diamonds, x=\"carat\", kind=\"kde\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "While the KDE suggests that there are peaks around specific values, the histogram reveals a much more jagged distribution:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(diamonds, x=\"carat\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As a compromise, it is possible to combine these two approaches. While in histogram mode,  (as with ) has the option of including the smoothed KDE curve (note kde=True, not kind=\"kde\"):"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(diamonds, x=\"carat\", kde=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Empirical cumulative distributions"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A third option for visualizing distributions computes the \u201cempirical cumulative distribution function\u201d (ECDF). This plot draws a monotonically-increasing curve through each datapoint such that the height of the curve reflects the proportion of observations with a smaller value:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", kind=\"ecdf\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The ECDF plot has two key advantages. Unlike the histogram or KDE, it directly represents each datapoint. That means there is no bin size or smoothing parameter to consider. Additionally, because the curve is monotonically increasing, it is well-suited for comparing multiple distributions:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"species\", kind=\"ecdf\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The major downside to the ECDF plot is that it represents the shape of the distribution less intuitively than a histogram or density curve. Consider how the bimodality of flipper lengths is immediately apparent in the histogram, but to see it in the ECDF plot, you must look for varying slopes. Nevertheless, with practice, you can learn to answer all of the important questions about a distribution by examining the ECDF, and doing so can be a powerful approach."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Visualizing bivariate distributions"
            },
            {
                "cell_type": "markdown",
                "nl_original": "All of the examples so far have considered <em>univariate</em> distributions: distributions of a single variable, perhaps conditional on a second variable assigned to hue. Assigning a second variable to y, however, will plot a <em>bivariate</em> distribution:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A bivariate histogram bins the data within rectangles that tile the plot and then shows the count of observations within each rectangle with the fill color (analogous to a ). Similarly, a bivariate KDE plot smoothes the (x, y) observations with a 2D Gaussian. The default representation then shows the <em>contours</em> of the 2D density:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\", kind=\"kde\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Assigning a hue variable will plot multiple heatmaps or contour sets using different colors. For bivariate histograms, this will only work well if there is minimal overlap between the conditional distributions:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\", hue=\"species\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The contour approach of the bivariate KDE plot lends itself better to evaluating overlap, although a plot with too many contours can get busy:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\", hue=\"species\", kind=\"kde\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Just as with univariate plots, the choice of bin size or smoothing bandwidth will determine how well the plot represents the underlying bivariate distribution. The same parameters apply, but they can be tuned for each variable by passing a pair of values:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\", binwidth=(2, .5))\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "To aid interpretation of the heatmap, add a colorbar to show the mapping between counts and color intensity:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\", binwidth=(2, .5), cbar=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The meaning of the bivariate density contours is less straightforward. Because the density is not directly interpretable, the contours are drawn at <em>iso-proportions</em> of the density, meaning that each curve shows a level set such that some proportion <em>p</em> of the density lies below it. The <em>p</em> values are evenly spaced, with the lowest level contolled by the thresh parameter and the number controlled by levels:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\", kind=\"kde\", thresh=.2, levels=4)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The levels parameter also accepts a list of values, for more control:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\", kind=\"kde\", levels=[.01, .05, .1, .8])\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The bivariate histogram allows one or both variables to be discrete. Plotting one discrete and one continuous variable offers another way to compare conditional univariate distributions:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(diamonds, x=\"price\", y=\"clarity\", log_scale=(True, False))\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In contrast, plotting two discrete variables is an easy to way show the cross-tabulation of the observations:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(diamonds, x=\"color\", y=\"clarity\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Distribution visualization in other settings"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Several other figure-level plotting functions in seaborn make use of the  and  functions."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Plotting joint and marginal distributions"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The first is , which augments a bivariate relatonal or distribution plot with the marginal distributions of the two variables. By default,  represents the bivariate distribution using  and the marginal distributions using :"
            },
            {
                "cell_type": "code",
                "code": "sns.jointplot(data=penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Similar to , setting a different kind=\"kde\" in  will change both the joint and marginal plots the use :"
            },
            {
                "cell_type": "code",
                "code": "sns.jointplot(\n    data=penguins,\n    x=\"bill_length_mm\", y=\"bill_depth_mm\", hue=\"species\",\n    kind=\"kde\"\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": " is a convenient interface to the  class, which offeres more flexibility when used directly:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.JointGrid(data=penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\")\ng.plot_joint(sns.histplot)\ng.plot_marginals(sns.boxplot)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A less-obtrusive way to show marginal distributions uses a \u201crug\u201d plot, which adds a small tick on the edge of the plot to represent each individual observation. This is built into :"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(\n    penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\",\n    kind=\"kde\", rug=True\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "And the axes-level  function can be used to add rugs on the side of any other kind of plot:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(data=penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\")\nsns.rugplot(data=penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Plotting many distributions"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  function offers a similar blend of joint and marginal distributions. Rather than focusing on a single relationship, however,  uses a \u201csmall-multiple\u201d approach to visualize the univariate distribution of all variables in a dataset along with all of their pairwise relationships:"
            },
            {
                "cell_type": "code",
                "code": "sns.pairplot(penguins)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As with /, using the underlying  directly will afford more flexibility with only a bit more typing:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.PairGrid(penguins)\ng.map_upper(sns.histplot)\ng.map_lower(sns.kdeplot, fill=True)\ng.map_diag(sns.histplot, kde=True)\n"
            }
        ],
        "Showing additional dimensions": [
            {
                "cell_type": "markdown",
                "nl_original": "# Visualizing categorical data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In the  we saw how to use different visual representations to show the relationship between multiple variables in a dataset. In the examples, we focused on cases where the main relationship was between two numerical variables. If one of the main variables is \u201ccategorical\u201d (divided into discrete groups) it may be helpful to use a more specialized approach to visualization."
            },
            {
                "cell_type": "markdown",
                "nl_original": "In seaborn, there are several different ways to visualize a relationship involving categorical data. Similar to the relationship between  and either  or , there are two ways to make these plots. There are a number of axes-level functions for plotting categorical data in different ways and a figure-level interface, , that gives unified higher-level access to them."
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s helpful to think of the different categorical plot kinds as belonging to three different families, which we\u2019ll discuss in detail below. They are:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Categorical scatterplots:"
            },
            {
                "cell_type": "markdown",
                "nl_original": " (with kind=\"strip\"; the default)"
            },
            {
                "cell_type": "markdown",
                "nl_original": " (with kind=\"swarm\")"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Categorical distribution plots:"
            },
            {
                "cell_type": "markdown",
                "nl_original": " (with kind=\"box\")"
            },
            {
                "cell_type": "markdown",
                "nl_original": " (with kind=\"violin\")"
            },
            {
                "cell_type": "markdown",
                "nl_original": " (with kind=\"boxen\")"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Categorical estimate plots:"
            },
            {
                "cell_type": "markdown",
                "nl_original": " (with kind=\"point\")"
            },
            {
                "cell_type": "markdown",
                "nl_original": " (with kind=\"bar\")"
            },
            {
                "cell_type": "markdown",
                "nl_original": " (with kind=\"count\")"
            },
            {
                "cell_type": "markdown",
                "nl_original": "These families represent the data using different levels of granularity. When deciding which to use, you\u2019ll have to think about the question that you want to answer. The unified API makes it easy to switch between different kinds and see your data from several perspectives."
            },
            {
                "cell_type": "markdown",
                "nl_original": "In this tutorial, we\u2019ll mostly focus on the figure-level interface, . Remember that this function is a higher-level interface each of the functions above, so we\u2019ll reference them when we show each kind of plot, keeping the more verbose kind-specific API documentation at hand."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Categorical scatterplots"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The default representation of the data in  uses a scatterplot. There are actually two different categorical scatter plots in seaborn. They take different approaches to resolving the main challenge in representing categorical data with a scatter plot, which is that all of the points belonging to one category would fall on the same position along the axis corresponding to the categorical variable. The approach used by , which is the default \u201ckind\u201d in  is to adjust the positions of points on the categorical axis with a small amount of random \u201cjitter\u201d:"
            },
            {
                "cell_type": "code",
                "code": "tips = sns.load_dataset(\"tips\")\nsns.catplot(data=tips, x=\"day\", y=\"total_bill\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The jitter parameter controls the magnitude of jitter or disables it altogether:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=tips, x=\"day\", y=\"total_bill\", jitter=False)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The second approach adjusts the points along the categorical axis using an algorithm that prevents them from overlapping. It can give a better representation of the distribution of observations, although it only works well for relatively small datasets. This kind of plot is sometimes called a \u201cbeeswarm\u201d and is drawn in seaborn by , which is activated by setting kind=\"swarm\" in :"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=tips, x=\"day\", y=\"total_bill\", kind=\"swarm\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Similar to the relational plots, it\u2019s possible to add another dimension to a categorical plot by using a hue semantic. (The categorical plots do not currently support size or style semantics). Each different categorical plotting function handles the hue semantic differently. For the scatter plots, it is only necessary to change the color of the points:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=tips, x=\"day\", y=\"total_bill\", hue=\"sex\", kind=\"swarm\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Unlike with numerical data, it is not always obvious how to order the levels of the categorical variable along its axis. In general, the seaborn categorical plotting functions try to infer the order of categories from the data. If your data have a pandas Categorical datatype, then the default order of the categories can be set there. If the variable passed to the categorical axis looks numerical, the levels will be sorted. But the data are still treated as categorical and drawn at ordinal positions on the categorical axes (specifically, at 0, 1, \u2026) even when numbers are used to label them:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=tips.query(\"size != 3\"), x=\"size\", y=\"total_bill\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The other option for choosing a default ordering is to take the levels of the category as they appear in the dataset. The ordering can also be controlled on a plot-specific basis using the order parameter. This can be important when drawing multiple categorical plots in the same figure, which we\u2019ll see more of below:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=tips, x=\"smoker\", y=\"tip\", order=[\"No\", \"Yes\"])\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "We\u2019ve referred to the idea of \u201ccategorical axis\u201d. In these examples, that\u2019s always corresponded to the horizontal axis. But it\u2019s often helpful to put the categorical variable on the vertical axis (particularly when the category names are relatively long or there are many categories). To do this, swap the assignment of variables to axes:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=tips, x=\"total_bill\", y=\"day\", hue=\"time\", kind=\"swarm\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Comparing distributions"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As the size of the dataset grows, categorical scatter plots become limited in the information they can provide about the distribution of values within each category. When this happens, there are several approaches for summarizing the distributional information in ways that facilitate easy comparisons across the category levels."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Boxplots"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The first is the familiar . This kind of plot shows the three quartile values of the distribution along with extreme values. The \u201cwhiskers\u201d extend to points that lie within 1.5 IQRs of the lower and upper quartile, and then observations that fall outside this range are displayed independently. This means that each value in the boxplot corresponds to an actual observation in the data."
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=tips, x=\"day\", y=\"total_bill\", kind=\"box\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When adding a hue semantic, the box for each level of the semantic variable is moved along the categorical axis so they don\u2019t overlap:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=tips, x=\"day\", y=\"total_bill\", hue=\"smoker\", kind=\"box\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This behavior is called \u201cdodging\u201d and is turned on by default because it is assumed that the semantic variable is nested within the main categorical variable. If that\u2019s not the case, you can disable the dodging:"
            },
            {
                "cell_type": "code",
                "code": "tips[\"weekend\"] = tips[\"day\"].isin([\"Sat\", \"Sun\"])\nsns.catplot(\n    data=tips, x=\"day\", y=\"total_bill\", hue=\"weekend\",\n    kind=\"box\", dodge=False,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A related function, , draws a plot that is similar to a box plot but optimized for showing more information about the shape of the distribution. It is best suited for larger datasets:"
            },
            {
                "cell_type": "code",
                "code": "diamonds = sns.load_dataset(\"diamonds\")\nsns.catplot(\n    data=diamonds.sort_values(\"color\"),\n    x=\"color\", y=\"price\", kind=\"boxen\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Violinplots"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A different approach is a , which combines a boxplot with the kernel density estimation procedure described in the  tutorial:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(\n    data=tips, x=\"total_bill\", y=\"day\", hue=\"sex\", kind=\"violin\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This approach uses the kernel density estimate to provide a richer description of the distribution of values. Additionally, the quartile and whisker values from the boxplot are shown inside the violin. The downside is that, because the violinplot uses a KDE, there are some other parameters that may need tweaking, adding some complexity relative to the straightforward boxplot:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(\n    data=tips, x=\"total_bill\", y=\"day\", hue=\"sex\",\n    kind=\"violin\", bw=.15, cut=0,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s also possible to \u201csplit\u201d the violins when the hue parameter has only two levels, which can allow for a more efficient use of space:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(\n    data=tips, x=\"day\", y=\"total_bill\", hue=\"sex\",\n    kind=\"violin\", split=True,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Finally, there are several options for the plot that is drawn on the interior of the violins, including ways to show each individual observation instead of the summary boxplot values:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(\n    data=tips, x=\"day\", y=\"total_bill\", hue=\"sex\",\n    kind=\"violin\", inner=\"stick\", split=True, palette=\"pastel\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It can also be useful to combine  or  with a box plot or violin plot to show each observation along with a summary of the distribution:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.catplot(data=tips, x=\"day\", y=\"total_bill\", kind=\"violin\", inner=None)\nsns.swarmplot(data=tips, x=\"day\", y=\"total_bill\", color=\"k\", size=3, ax=g.ax)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Estimating central tendency"
            },
            {
                "cell_type": "markdown",
                "nl_original": "For other applications, rather than showing the distribution within each category, you might want to show an estimate of the central tendency of the values. Seaborn has two main ways to show this information. Importantly, the basic API for these functions is identical to that for the ones discussed above."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Bar plots"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A familiar style of plot that accomplishes this goal is a bar plot. In seaborn, the  function operates on a full dataset and applies a function to obtain the estimate (taking the mean by default). When there are multiple observations in each category, it also uses bootstrapping to compute a confidence interval around the estimate, which is plotted using error bars:"
            },
            {
                "cell_type": "code",
                "code": "titanic = sns.load_dataset(\"titanic\")\nsns.catplot(data=titanic, x=\"sex\", y=\"survived\", hue=\"class\", kind=\"bar\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The default error bars show 95% confidence intervals, but (starting in\nv0.12), it is possible to select from a number of other representations:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=titanic, x=\"age\", y=\"deck\", errorbar=(\"pi\", 95), kind=\"bar\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A special case for the bar plot is when you want to show the number of observations in each category rather than computing a statistic for a second variable. This is similar to a histogram over a categorical, rather than quantitative, variable. In seaborn, it\u2019s easy to do so with the  function:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=titanic, x=\"deck\", kind=\"count\", palette=\"ch:.25\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Both  and  can be invoked with all of the options discussed above, along with others that are demonstrated in the detailed documentation for each function:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(\n    data=titanic, y=\"deck\", hue=\"class\", kind=\"count\",\n    palette=\"pastel\", edgecolor=\".6\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Point plots"
            },
            {
                "cell_type": "markdown",
                "nl_original": "An alternative style for visualizing the same information is offered by the  function. This function also encodes the value of the estimate with height on the other axis, but rather than showing a full bar, it plots the point estimate and confidence interval. Additionally,  connects points from the same hue category. This makes it easy to see how the main relationship is changing as a function of the hue semantic, because your eyes are quite good at picking up on differences of slopes:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=titanic, x=\"sex\", y=\"survived\", hue=\"class\", kind=\"point\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "While the categorical functions lack the style semantic of the relational functions, it can still be a good idea to vary the marker and/or linestyle along with the hue to make figures that are maximally accessible and reproduce well in black and white:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(\n    data=titanic, x=\"class\", y=\"survived\", hue=\"sex\",\n    palette={\"male\": \"g\", \"female\": \"m\"},\n    markers=[\"^\", \"o\"], linestyles=[\"-\", \"--\"],\n    kind=\"point\"\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Showing additional dimensions"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Just like , the fact that  is built on a  means that it is easy to add faceting variables to visualize higher-dimensional relationships:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(\n    data=tips, x=\"day\", y=\"total_bill\", hue=\"smoker\",\n    kind=\"swarm\", col=\"time\", aspect=.7,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "For further customization of the plot, you can use the methods on the  object that it returns:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.catplot(\n    data=titanic,\n    x=\"fare\", y=\"embark_town\", row=\"class\",\n    kind=\"box\", orient=\"h\",\n    sharex=False, margin_titles=True,\n    height=1.5, aspect=4,\n)\ng.set(xlabel=\"Fare\", ylabel=\"\")\ng.set_titles(row_template=\"{row_name} class\")\nfor ax in g.axes.flat:\n    ax.xaxis.set_major_formatter('${x:.0f}')\n"
            }
        ],
        "Are error bars enough?": [
            {
                "cell_type": "markdown",
                "nl_original": "# Statistical estimation and error bars"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Data visualization sometimes involves a step of aggregation or estimation, where multiple data points are reduced to a summary statistic such as the mean or median. When showing a summary statistic, it is usually appropriate to add <em>error bars</em>, which provide a visual cue about how well the summary represents the underlying data points."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Several seaborn functions will automatically calculate both summary statistics and the error bars when given a full dataset. This chapter explains how you can control what the error bars show and why you might choose each of the options that seaborn affords."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The error bars around an estimate of central tendency can show one of two general things: either the range of uncertainty about the estimate or the spread of the underlying data around it. These measures are related: given the same sample size, estimates will be more uncertain when data has a broader spread. But uncertainty will decrease as sample sizes grow, whereas spread will not."
            },
            {
                "cell_type": "markdown",
                "nl_original": "In seaborn, there are two approaches for constructing each kind of error bar. One approach is parametric, using a formula that relies on assumptions about the shape of the distribution. The other approach is nonparametric, using only the data that you provide."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Your choice is made with the errorbar parameter, which exists for each function that does estimation as part of plotting. This parameter accepts the name of the method to use and, optionally, a parameter that controls the size of the interval. The choices can be defined in a 2D taxonomy that depends on what is shown and how it is constructed:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You will note that the size parameter is defined differently for the parametric and nonparametric approaches. For parametric error bars, it is a scalar factor that is multiplied by the statistic defining the error (standard error or standard deviation). For nonparametric error bars, it is a percentile width. This is explained further for each specific approach below."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The errorbar API described here was introduced in seaborn v0.12. In prior versions, the only options were to show a bootstrap confidence interval or a standard deviation, with the choice controlled by the ci parameter (i.e., ci=&lt;size&gt; or ci=\"sd\")."
            },
            {
                "cell_type": "markdown",
                "nl_original": "To compare the different parameterizations, we\u2019ll use the following helper function:"
            },
            {
                "cell_type": "code",
                "code": "def plot_errorbars(arg, **kws):\n    np.random.seed(sum(map(ord, \"error_bars\")))\n    x = np.random.normal(0, 1, 100)\n    f, axs = plt.subplots(2, figsize=(7, 2), sharex=True, layout=\"tight\")\n    sns.pointplot(x=x, errorbar=arg, **kws, capsize=.3, ax=axs[0])\n    sns.stripplot(x=x, jitter=.3, ax=axs[1])\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Measures of data spread"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Error bars that represent data spread present a compact display of the distribution, using three numbers where  would use 5 or more and  would use a complicated algorithm."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Standard deviation error bars"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Standard deviation error bars are the simplest to explain, because the standard deviation is a familiar statistic. It is the average distance from each data point to the sample mean. By default, errorbar=\"sd\" will draw error bars at +/- 1 sd around the estimate, but the range can be increased by passing a scaling size parameter. Note that, assuming normally-distributed data, ~68% of the data will lie within one standard deviation, ~95% will lie within two, and ~99.7% will lie within three:"
            },
            {
                "cell_type": "code",
                "code": "plot_errorbars(\"sd\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Percentile interval error bars"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Percentile intervals also represent the range where some amount of the data fall, but they do so by\ncomputing those percentiles directly from your sample. By default, errorbar=\"pi\" will show a 95% interval, ranging from the 2.5 to the 97.5 percentiles. You can choose a different range by passing a size parameter, e.g., to show the inter-quartile range:"
            },
            {
                "cell_type": "code",
                "code": "plot_errorbars((\"pi\", 50))\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The standard deviation error bars will always be symmetrical around the estimate. This can be a problem when the data are skewed, especially if there are natural bounds (e.g., if the data represent a quantity that can only be positive). In some cases, standard deviation error bars may extend to \u201cimpossible\u201d values. The nonparametric approach does not have this problem, because it can account for asymmetrical spread and will never extend beyond the range of the data."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Measures of estimate uncertainty"
            },
            {
                "cell_type": "markdown",
                "nl_original": "If your data are a random sample from a larger population, then the mean (or other estimate) will be an imperfect measure of the true population average. Error bars that show estimate uncertainty try to represent the range of likely values for the true parameter."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Standard error bars"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The standard error statistic is related to the standard deviation: in fact it is just the standard deviation divided by the square root of the sample size. The default, with errorbar=\"se\", draws an interval +/-1 standard error from the mean:"
            },
            {
                "cell_type": "code",
                "code": "plot_errorbars(\"se\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Confidence interval error bars"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The nonparametric approach to representing uncertainty uses <em>bootstrapping</em>: a procedure where the dataset is randomly resampled with replacement a number of times, and the estimate is recalculated from each resample. This procedure creates a distribution of statistics approximating the distribution of values that you could have gotten for your estimate if you had a different sample."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The confidence interval is constructed by taking a percentile interval of the <em>bootstrap distribution</em>. By default errorbar=\"ci\" draws a 95% confidence interval:"
            },
            {
                "cell_type": "code",
                "code": "plot_errorbars(\"ci\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The seaborn terminology is somewhat specific, because a confidence interval in statistics can be parametric or nonparametric. To draw a parametric confidence interval, you scale the standard error, using a formula similar to the one mentioned above. For example, an approximate 95% confidence interval can be constructed by taking the mean +/- two standard errors:"
            },
            {
                "cell_type": "code",
                "code": "plot_errorbars((\"se\", 2))\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The nonparametric bootstrap has advantages similar to those of the percentile interval: it will naturally adapt to skewed and bounded data in a way that a standard error interval cannot. It is also more general. While the standard error formula is specific to the mean, error bars can be computed using the bootstrap for any estimator:"
            },
            {
                "cell_type": "code",
                "code": "plot_errorbars(\"ci\", estimator=\"median\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Bootstrapping involves randomness, and the error bars will appear slightly different each time you run the code that creates them. A few parameters control this. One sets the number of iterations (n_boot): with more iterations, the resulting intervals will be more stable. The other sets the seed for the random number generator, which will ensure identical results:"
            },
            {
                "cell_type": "code",
                "code": "plot_errorbars(\"ci\", n_boot=5000, seed=10)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Because of its iterative process, bootstrap intervals can be expensive to compute, especially for large datasets. But because uncertainty decreases with sample size, it may be more informative in that case to use an error bar that represents data spread."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Custom error bars"
            },
            {
                "cell_type": "markdown",
                "nl_original": "If these recipes are not sufficient, it is also possible to pass a generic function to the errorbar parameter. This function should take a vector and produce a pair of values representing the minimum and maximum points of the interval:"
            },
            {
                "cell_type": "code",
                "code": "plot_errorbars(lambda x: (x.min(), x.max()))\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "(In practice, you could show the full range of the data with errorbar=(\"pi\", 100) rather than the custom function shown above)."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note that seaborn functions cannot currently draw error bars from values that have been calculated externally, although matplotlib functions can be used to add such error bars to seaborn plots."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Error bars on regression fits"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The preceding discussion has focused on error bars shown around parameter estimates for aggregate data. Error bars also arise in seaborn when estimating regression models to visualize relationships. Here, the error bars will be represented by a \u201cband\u201d around the regression line:"
            },
            {
                "cell_type": "code",
                "code": "x = np.random.normal(0, 1, 50)\ny = x * 2 + np.random.normal(0, 2, size=x.size)\nsns.regplot(x=x, y=y)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Currently, the error bars on a regression estimate are less flexible, only showing a confidence interval with a size set through ci=. This may change in the future."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Are error bars enough?"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You should always ask yourself whether it\u2019s best to use a plot that displays only a summary statistic and error bar. In many cases, it isn\u2019t."
            },
            {
                "cell_type": "markdown",
                "nl_original": "If you are interested in questions about summaries (such as whether the mean value differs between groups or increases over time), aggregation reduces the complexity of the plot and makes those inferences easier. But in doing so, it obscures valuable information about the underlying data points, such as the shape of the distributions and the presence of outliers."
            },
            {
                "cell_type": "markdown",
                "nl_original": "When analyzing your own data, don\u2019t be satisfied with summary statistics. Always look at the underlying distributions too. Sometimes, it can be helpful to combine both perspectives into the same figure. Many seaborn functions can help with this task, especially those discussed in the ."
            }
        ],
        "Plotting a regression in other contexts": [
            {
                "cell_type": "markdown",
                "nl_original": "# Estimating regression fits"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Many datasets contain multiple quantitative variables, and the goal of an analysis is often to relate those variables to each other. We  functions that can accomplish this by showing the joint distribution of two variables. It can be very helpful, though, to use statistical models to estimate a simple relationship between two noisy sets of observations. The functions discussed in this chapter will do so through the common framework of linear regression."
            },
            {
                "cell_type": "markdown",
                "nl_original": "In the spirit of Tukey, the regression plots in seaborn are primarily intended to add a visual guide that helps to emphasize patterns in a dataset during exploratory data analyses. That is to say that seaborn is not itself a package for statistical analysis. To obtain quantitative measures related to the fit of regression models, you should use . The goal of seaborn, however, is to make exploring a dataset through visualization quick and easy, as doing so is just as (if not more) important than exploring a dataset through tables of statistics."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Functions for drawing linear regression models"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The two functions that can be used to visualize a linear fit are  and ."
            },
            {
                "cell_type": "markdown",
                "nl_original": "In the simplest invocation, both functions draw a scatterplot of two variables, x and y, and then fit the regression model y ~ x and plot the resulting regression line and a 95% confidence interval for that regression:"
            },
            {
                "cell_type": "code",
                "code": "tips = sns.load_dataset(\"tips\")\nsns.regplot(x=\"total_bill\", y=\"tip\", data=tips);\n"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"total_bill\", y=\"tip\", data=tips);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "These functions draw similar plots, but  is an , and  is a figure-level function. Additionally,  accepts the x and y variables in a variety of formats including simple numpy arrays,  objects, or as references to variables in a  object passed to data. In contrast,  has data as a required parameter and the x and y variables must be specified as strings. Finally, only  has hue as a parameter."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The core functionality is otherwise similar, though, so this tutorial will focus on :."
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s possible to fit a linear regression when one of the variables takes discrete values, however, the simple scatterplot produced by this kind of dataset is often not optimal:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"size\", y=\"tip\", data=tips);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "One option is to add some random noise (\u201cjitter\u201d) to the discrete values to make the distribution of those values more clear. Note that jitter is applied only to the scatterplot data and does not influence the regression line fit itself:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"size\", y=\"tip\", data=tips, x_jitter=.05);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A second option is to collapse over the observations in each discrete bin to plot an estimate of central tendency along with a confidence interval:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"size\", y=\"tip\", data=tips, x_estimator=np.mean);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Fitting different kinds of models"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The simple linear regression model used above is very simple to fit, however, it is not appropriate for some kinds of datasets. The  dataset shows a few examples where simple linear regression provides an identical estimate of a relationship where simple visual inspection clearly shows differences. For example, in the first case, the linear regression is a good model:"
            },
            {
                "cell_type": "code",
                "code": "anscombe = sns.load_dataset(\"anscombe\")\n"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"x\", y=\"y\", data=anscombe.query(\"dataset == 'I'\"),\n           ci=None, scatter_kws={\"s\": 80});\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The linear relationship in the second dataset is the same, but the plot clearly shows that this is not a good model:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"x\", y=\"y\", data=anscombe.query(\"dataset == 'II'\"),\n           ci=None, scatter_kws={\"s\": 80});\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In the presence of these kind of higher-order relationships,  and  can fit a polynomial regression model to explore simple kinds of nonlinear trends in the dataset:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"x\", y=\"y\", data=anscombe.query(\"dataset == 'II'\"),\n           order=2, ci=None, scatter_kws={\"s\": 80});\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A different problem is posed by \u201coutlier\u201d observations that deviate for some reason other than the main relationship under study:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"x\", y=\"y\", data=anscombe.query(\"dataset == 'III'\"),\n           ci=None, scatter_kws={\"s\": 80});\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In the presence of outliers, it can be useful to fit a robust regression, which uses a different loss function to downweight relatively large residuals:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"x\", y=\"y\", data=anscombe.query(\"dataset == 'III'\"),\n           robust=True, ci=None, scatter_kws={\"s\": 80});\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When the y variable is binary, simple linear regression also \u201cworks\u201d but provides implausible predictions:"
            },
            {
                "cell_type": "code",
                "code": "tips[\"big_tip\"] = (tips.tip / tips.total_bill) &gt; .15\nsns.lmplot(x=\"total_bill\", y=\"big_tip\", data=tips,\n           y_jitter=.03);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The solution in this case is to fit a logistic regression, such that the regression line shows the estimated probability of y = 1 for a given value of x:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"total_bill\", y=\"big_tip\", data=tips,\n           logistic=True, y_jitter=.03);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note that the logistic regression estimate is considerably more computationally intensive (this is true of robust regression as well). As the confidence interval around the regression line is computed using a bootstrap procedure, you may wish to turn this off for faster iteration (using ci=None)."
            },
            {
                "cell_type": "markdown",
                "nl_original": "An altogether different approach is to fit a nonparametric regression using a . This approach has the fewest assumptions, although it is computationally intensive and so currently confidence intervals are not computed at all:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"total_bill\", y=\"tip\", data=tips,\n           lowess=True, line_kws={\"color\": \"C1\"});\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  function can be a useful tool for checking whether the simple regression model is appropriate for a dataset. It fits and removes a simple linear regression and then plots the residual values for each observation. Ideally, these values should be randomly scattered around y = 0:"
            },
            {
                "cell_type": "code",
                "code": "sns.residplot(x=\"x\", y=\"y\", data=anscombe.query(\"dataset == 'I'\"),\n              scatter_kws={\"s\": 80});\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "If there is structure in the residuals, it suggests that simple linear regression is not appropriate:"
            },
            {
                "cell_type": "code",
                "code": "sns.residplot(x=\"x\", y=\"y\", data=anscombe.query(\"dataset == 'II'\"),\n              scatter_kws={\"s\": 80});\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Conditioning on other variables"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The plots above show many ways to explore the relationship between a pair of variables. Often, however, a more interesting question is \u201chow does the relationship between these two variables change as a function of a third variable?\u201d This is where the main differences between  and  appear. While  always shows a single relationship,  combines  with  to show multiple fits using hue mapping or faceting."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The best way to separate out a relationship is to plot both levels on the same axes and to use color to distinguish them:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"total_bill\", y=\"tip\", hue=\"smoker\", data=tips);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Unlike , it\u2019s not possible to map a distinct variable to the style properties of the scatter plot, but you can redundantly code the hue variable with marker shape:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"total_bill\", y=\"tip\", hue=\"smoker\", data=tips,\n           markers=[\"o\", \"x\"], palette=\"Set1\");\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "To add another variable, you can draw multiple \u201cfacets\u201d with each level of the variable appearing in the rows or columns of the grid:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"total_bill\", y=\"tip\", hue=\"smoker\", col=\"time\", data=tips);\n"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"total_bill\", y=\"tip\", hue=\"smoker\",\n           col=\"time\", row=\"sex\", data=tips, height=3);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Plotting a regression in other contexts"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A few other seaborn functions use  in the context of a larger, more complex plot. The first is the  function that we introduced in the . In addition to the plot styles previously discussed,  can use  to show the linear regression fit on the joint axes by passing kind=\"reg\":"
            },
            {
                "cell_type": "code",
                "code": "sns.jointplot(x=\"total_bill\", y=\"tip\", data=tips, kind=\"reg\");\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Using the  function with kind=\"reg\" combines  and  to show the linear relationship between variables in a dataset. Take care to note how this is different from . In the figure below, the two axes don\u2019t show the same relationship conditioned on two levels of a third variable; rather,  is used to show multiple relationships between different pairings of the variables in a dataset:"
            },
            {
                "cell_type": "code",
                "code": "sns.pairplot(tips, x_vars=[\"total_bill\", \"size\"], y_vars=[\"tip\"],\n             height=5, aspect=.8, kind=\"reg\");\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Conditioning on an additional categorical variable is built into both of these functions using the hue parameter:"
            },
            {
                "cell_type": "code",
                "code": "sns.pairplot(tips, x_vars=[\"total_bill\", \"size\"], y_vars=[\"tip\"],\n             hue=\"smoker\", height=5, aspect=.8, kind=\"reg\");\n"
            }
        ],
        "Plotting pairwise data relationships": [
            {
                "cell_type": "markdown",
                "nl_original": "# Building structured multi-plot grids"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When exploring multi-dimensional data, a useful approach is to draw multiple instances of the same plot on different subsets of your dataset. This technique is sometimes called either \u201clattice\u201d or \u201ctrellis\u201d plotting, and it is related to the idea of . It allows a viewer to quickly extract a large amount of information about a complex dataset. Matplotlib offers good support for making figures with multiple axes; seaborn builds on top of this to directly link the structure of the plot to the structure of your dataset."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  functions are built on top of the objects discussed in this chapter of the tutorial. In most cases, you will want to work with those functions. They take care of some important bookkeeping that synchronizes the multiple plots in each grid. This chapter explains how the underlying objects work, which may be useful for advanced applications."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Conditional small multiples"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  class is useful when you want to visualize the distribution of a variable or the relationship between multiple variables separately within subsets of your dataset. A  can be drawn with up to three dimensions: row, col, and hue. The first two have obvious correspondence with the resulting array of axes; think of the hue variable as a third dimension along a depth axis, where different levels are plotted with different colors."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Each of , , , and  use this object internally, and they return the object when they are finished so that it can be used for further tweaking."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The class is used by initializing a  object with a dataframe and the names of the variables that will form the row, column, or hue dimensions of the grid. These variables should be categorical or discrete, and then the data at each level of the variable will be used for a facet along that axis. For example, say we wanted to examine differences between lunch and dinner in the tips dataset:"
            },
            {
                "cell_type": "code",
                "code": "tips = sns.load_dataset(\"tips\")\ng = sns.FacetGrid(tips, col=\"time\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Initializing the grid like this sets up the matplotlib figure and axes, but doesn\u2019t draw anything on them."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The main approach for visualizing data on this grid is with the  method. Provide it with a plotting function and the name(s) of variable(s) in the dataframe to plot. Let\u2019s look at the distribution of tips in each of these subsets, using a histogram:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.FacetGrid(tips, col=\"time\")\ng.map(sns.histplot, \"tip\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This function will draw the figure and annotate the axes, hopefully producing a finished plot in one step. To make a relational plot, just pass multiple variable names. You can also provide keyword arguments, which will be passed to the plotting function:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.FacetGrid(tips, col=\"sex\", hue=\"smoker\")\ng.map(sns.scatterplot, \"total_bill\", \"tip\", alpha=.7)\ng.add_legend()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "There are several options for controlling the look of the grid that can be passed to the class constructor."
            },
            {
                "cell_type": "code",
                "code": "g = sns.FacetGrid(tips, row=\"smoker\", col=\"time\", margin_titles=True)\ng.map(sns.regplot, \"size\", \"total_bill\", color=\".3\", fit_reg=False, x_jitter=.1)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note that margin_titles isn\u2019t formally supported by the matplotlib API, and may not work well in all cases. In particular, it currently can\u2019t be used with a legend that lies outside of the plot."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The size of the figure is set by providing the height of <em>each</em> facet, along with the aspect ratio:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.FacetGrid(tips, col=\"day\", height=4, aspect=.5)\ng.map(sns.barplot, \"sex\", \"total_bill\", order=[\"Male\", \"Female\"])\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The default ordering of the facets is derived from the information in the DataFrame. If the variable used to define facets has a categorical type, then the order of the categories is used. Otherwise, the facets will be in the order of appearance of the category levels. It is possible, however, to specify an ordering of any facet dimension with the appropriate *_order parameter:"
            },
            {
                "cell_type": "code",
                "code": "ordered_days = tips.day.value_counts().index\ng = sns.FacetGrid(tips, row=\"day\", row_order=ordered_days,\n                  height=1.7, aspect=4,)\ng.map(sns.kdeplot, \"total_bill\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Any seaborn color palette (i.e., something that can be passed to ) can be provided. You can also use a dictionary that maps the names of values in the hue variable to valid matplotlib colors:"
            },
            {
                "cell_type": "code",
                "code": "pal = dict(Lunch=\"seagreen\", Dinner=\".7\")\ng = sns.FacetGrid(tips, hue=\"time\", palette=pal, height=5)\ng.map(sns.scatterplot, \"total_bill\", \"tip\", s=100, alpha=.5)\ng.add_legend()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "If you have many levels of one variable, you can plot it along the columns but \u201cwrap\u201d them so that they span multiple rows. When doing this, you cannot use a row variable."
            },
            {
                "cell_type": "code",
                "code": "attend = sns.load_dataset(\"attention\").query(\"subject &lt;= 12\")\ng = sns.FacetGrid(attend, col=\"subject\", col_wrap=4, height=2, ylim=(0, 10))\ng.map(sns.pointplot, \"solutions\", \"score\", order=[1, 2, 3], color=\".3\", errorbar=None)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Once you\u2019ve drawn a plot using  (which can be called multiple times), you may want to adjust some aspects of the plot. There are also a number of methods on the  object for manipulating the figure at a higher level of abstraction. The most general is , and there are other more specialized methods like , which respects the fact that interior facets do not have axis labels. For example:"
            },
            {
                "cell_type": "code",
                "code": "with sns.axes_style(\"white\"):\n    g = sns.FacetGrid(tips, row=\"sex\", col=\"smoker\", margin_titles=True, height=2.5)\ng.map(sns.scatterplot, \"total_bill\", \"tip\", color=\"#334488\")\ng.set_axis_labels(\"Total bill (US Dollars)\", \"Tip\")\ng.set(xticks=[10, 30, 50], yticks=[2, 6, 10])\ng.figure.subplots_adjust(wspace=.02, hspace=.02)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "For even more customization, you can  work directly with the underling matplotlib Figure and Axes objects, which are stored as member attributes at figure and axes_dict, respectively. When making a figure without row or column faceting, you can also use the ax attribute to directly access the single axes."
            },
            {
                "cell_type": "code",
                "code": "g = sns.FacetGrid(tips, col=\"smoker\", margin_titles=True, height=4)\ng.map(plt.scatter, \"total_bill\", \"tip\", color=\"#338844\", edgecolor=\"white\", s=50, lw=1)\nfor ax in g.axes_dict.values():\n    ax.axline((0, 0), slope=.2, c=\".2\", ls=\"--\", zorder=0)\ng.set(xlim=(0, 60), ylim=(0, 14))\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Using custom functions"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You\u2019re not limited to existing matplotlib and seaborn functions when using . However, to work properly, any function you use must follow a few rules:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It must plot onto the \u201ccurrently active\u201d matplotlib Axes. This will be true of functions in the matplotlib.pyplot namespace, and you can call  to get a reference to the current Axes if you want to work directly with its methods."
            },
            {
                "cell_type": "markdown",
                "nl_original": "It must accept the data that it plots in positional arguments. Internally,  will pass a Series of data for each of the named positional arguments passed to ."
            },
            {
                "cell_type": "markdown",
                "nl_original": "It must be able to accept color and label keyword arguments, and, ideally, it will do something useful with them. In most cases, it\u2019s easiest to catch a generic dictionary of **kwargs and pass it along to the underlying plotting function."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Let\u2019s look at minimal example of a function you can plot with. This function will just take a single vector of data for each facet:"
            },
            {
                "cell_type": "code",
                "code": "from scipy import stats\ndef quantile_plot(x, **kwargs):\n    quantiles, xr = stats.probplot(x, fit=False)\n    plt.scatter(xr, quantiles, **kwargs)\n\ng = sns.FacetGrid(tips, col=\"sex\", height=4)\ng.map(quantile_plot, \"total_bill\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "If we want to make a bivariate plot, you should write the function so that it accepts the x-axis variable first and the y-axis variable second:"
            },
            {
                "cell_type": "code",
                "code": "def qqplot(x, y, **kwargs):\n    _, xr = stats.probplot(x, fit=False)\n    _, yr = stats.probplot(y, fit=False)\n    plt.scatter(xr, yr, **kwargs)\n\ng = sns.FacetGrid(tips, col=\"smoker\", height=4)\ng.map(qqplot, \"total_bill\", \"tip\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Because  accepts color and label keyword arguments and does the right thing with them, we can add a hue facet without any difficulty:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.FacetGrid(tips, hue=\"time\", col=\"sex\", height=4)\ng.map(qqplot, \"total_bill\", \"tip\")\ng.add_legend()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Sometimes, though, you\u2019ll want to map a function that doesn\u2019t work the way you expect with the color and label keyword arguments. In this case, you\u2019ll want to explicitly catch them and handle them in the logic of your custom function. For example, this approach will allow use to map , which otherwise does not play well with the  API:"
            },
            {
                "cell_type": "code",
                "code": "def hexbin(x, y, color, **kwargs):\n    cmap = sns.light_palette(color, as_cmap=True)\n    plt.hexbin(x, y, gridsize=15, cmap=cmap, **kwargs)\n\nwith sns.axes_style(\"dark\"):\n    g = sns.FacetGrid(tips, hue=\"time\", col=\"time\", height=4)\ng.map(hexbin, \"total_bill\", \"tip\", extent=[0, 50, 0, 10]);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Plotting pairwise data relationships"
            },
            {
                "cell_type": "markdown",
                "nl_original": " also allows you to quickly draw a grid of small subplots using the same plot type to visualize data in each. In a , each row and column is assigned to a different variable, so the resulting plot shows each pairwise relationship in the dataset. This style of plot is sometimes called a \u201cscatterplot matrix\u201d, as this is the most common way to show each relationship, but  is not limited to scatterplots."
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s important to understand the differences between a  and a . In the former, each facet shows the same relationship conditioned on different levels of other variables. In the latter, each plot shows a different relationship (although the upper and lower triangles will have mirrored plots). Using  can give you a very quick, very high-level summary of interesting relationships in your dataset."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The basic usage of the class is very similar to . First you initialize the grid, then you pass plotting function to a map method and it will be called on each subplot. There is also a companion function,  that trades off some flexibility for faster plotting."
            },
            {
                "cell_type": "code",
                "code": "iris = sns.load_dataset(\"iris\")\ng = sns.PairGrid(iris)\ng.map(sns.scatterplot)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s possible to plot a different function on the diagonal to show the univariate distribution of the variable in each column. Note that the axis ticks won\u2019t correspond to the count or density axis of this plot, though."
            },
            {
                "cell_type": "code",
                "code": "g = sns.PairGrid(iris)\ng.map_diag(sns.histplot)\ng.map_offdiag(sns.scatterplot)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A very common way to use this plot colors the observations by a separate categorical variable. For example, the iris dataset has four measurements for each of three different species of iris flowers so you can see how they differ."
            },
            {
                "cell_type": "code",
                "code": "g = sns.PairGrid(iris, hue=\"species\")\ng.map_diag(sns.histplot)\ng.map_offdiag(sns.scatterplot)\ng.add_legend()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "By default every numeric column in the dataset is used, but you can focus on particular relationships if you want."
            },
            {
                "cell_type": "code",
                "code": "g = sns.PairGrid(iris, vars=[\"sepal_length\", \"sepal_width\"], hue=\"species\")\ng.map(sns.scatterplot)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s also possible to use a different function in the upper and lower triangles to emphasize different aspects of the relationship."
            },
            {
                "cell_type": "code",
                "code": "g = sns.PairGrid(iris)\ng.map_upper(sns.scatterplot)\ng.map_lower(sns.kdeplot)\ng.map_diag(sns.kdeplot, lw=3, legend=False)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The square grid with identity relationships on the diagonal is actually just a special case, and you can plot with different variables in the rows and columns."
            },
            {
                "cell_type": "code",
                "code": "g = sns.PairGrid(tips, y_vars=[\"tip\"], x_vars=[\"total_bill\", \"size\"], height=4)\ng.map(sns.regplot, color=\".3\")\ng.set(ylim=(-1, 11), yticks=[0, 5, 10])\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Of course, the aesthetic attributes are configurable. For instance, you can use a different palette (say, to show an ordering of the hue variable) and pass keyword arguments into the plotting functions."
            },
            {
                "cell_type": "code",
                "code": "g = sns.PairGrid(tips, hue=\"size\", palette=\"GnBu_d\")\ng.map(plt.scatter, s=50, edgecolor=\"white\")\ng.add_legend()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": " is flexible, but to take a quick look at a dataset, it can be easier to use . This function uses scatterplots and histograms by default, although a few other kinds will be added (currently, you can also plot regression plots on the off-diagonals and KDEs on the diagonal)."
            },
            {
                "cell_type": "code",
                "code": "sns.pairplot(iris, hue=\"species\", height=2.5)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can also control the aesthetics of the plot with keyword arguments, and it returns the  instance for further tweaking."
            },
            {
                "cell_type": "code",
                "code": "g = sns.pairplot(iris, hue=\"species\", palette=\"Set2\", diag_kind=\"kde\", height=2.5)\n"
            }
        ],
        "Scaling plot elements": [
            {
                "cell_type": "markdown",
                "nl_original": "# Controlling figure aesthetics"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Drawing attractive figures is important. When making figures for yourself, as you explore a dataset, it\u2019s nice to have plots that are pleasant to look at. Visualizations are also central to communicating quantitative insights to an audience, and in that setting it\u2019s even more necessary to have figures that catch the attention and draw a viewer in."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Matplotlib is highly customizable, but it can be hard to know what settings to tweak to achieve an attractive plot. Seaborn comes with a number of customized themes and a high-level interface for controlling the look of matplotlib figures."
            },
            {
                "cell_type": "code",
                "code": "import numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Let\u2019s define a simple function to plot some offset sine waves, which will help us see the different stylistic parameters we can tweak."
            },
            {
                "cell_type": "code",
                "code": "def sinplot(n=10, flip=1):\n    x = np.linspace(0, 14, 100)\n    for i in range(1, n + 1):\n        plt.plot(x, np.sin(x + i * .5) * (n + 2 - i) * flip)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This is what the plot looks like with matplotlib defaults:"
            },
            {
                "cell_type": "code",
                "code": "sinplot()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "To switch to seaborn defaults, simply call the  function."
            },
            {
                "cell_type": "code",
                "code": "sns.set_theme()\nsinplot()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "(Note that in versions of seaborn prior to 0.8,  was called on import. On later versions, it must be explicitly invoked)."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Seaborn splits matplotlib parameters into two independent groups. The first group sets the aesthetic style of the plot, and the second scales various elements of the figure so that it can be easily incorporated into different contexts."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The interface for manipulating these parameters are two pairs of functions. To control the style, use the  and  functions. To scale the plot, use the  and  functions. In both cases, the first function returns a dictionary of parameters and the second sets the matplotlib defaults."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Seaborn figure styles"
            },
            {
                "cell_type": "markdown",
                "nl_original": "There are five preset seaborn themes: darkgrid, whitegrid, dark, white, and ticks. They are each suited to different applications and personal preferences. The default theme is darkgrid. As mentioned above, the grid helps the plot serve as a lookup table for quantitative information, and the white-on grey helps to keep the grid from competing with lines that represent data. The whitegrid theme is similar, but it is better suited to plots with heavy data elements:"
            },
            {
                "cell_type": "code",
                "code": "sns.set_style(\"whitegrid\")\ndata = np.random.normal(size=(20, 6)) + np.arange(6) / 2\nsns.boxplot(data=data);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "For many plots, (especially for settings like talks, where you primarily want to use figures to provide impressions of patterns in the data), the grid is less necessary."
            },
            {
                "cell_type": "code",
                "code": "sns.set_style(\"dark\")\nsinplot()\n"
            },
            {
                "cell_type": "code",
                "code": "sns.set_style(\"white\")\nsinplot()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Sometimes you might want to give a little extra structure to the plots, which is where ticks come in handy:"
            },
            {
                "cell_type": "code",
                "code": "sns.set_style(\"ticks\")\nsinplot()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Removing axes spines"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Both the white and ticks styles can benefit from removing the top and right axes spines, which are not needed. The seaborn function  can be called to remove them:"
            },
            {
                "cell_type": "code",
                "code": "sinplot()\nsns.despine()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Some plots benefit from offsetting the spines away from the data, which can also be done when calling . When the ticks don\u2019t cover the whole range of the axis, the trim parameter will limit the range of the surviving spines."
            },
            {
                "cell_type": "code",
                "code": "f, ax = plt.subplots()\nsns.violinplot(data=data)\nsns.despine(offset=10, trim=True);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can also control which spines are removed with additional arguments to :"
            },
            {
                "cell_type": "code",
                "code": "sns.set_style(\"whitegrid\")\nsns.boxplot(data=data, palette=\"deep\")\nsns.despine(left=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Temporarily setting figure style"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Although it\u2019s easy to switch back and forth, you can also use the  function in a with statement to temporarily set plot parameters. This also allows you to make figures with differently-styled axes:"
            },
            {
                "cell_type": "code",
                "code": "f = plt.figure(figsize=(6, 6))\ngs = f.add_gridspec(2, 2)\n\nwith sns.axes_style(\"darkgrid\"):\n    ax = f.add_subplot(gs[0, 0])\n    sinplot(6)\n\nwith sns.axes_style(\"white\"):\n    ax = f.add_subplot(gs[0, 1])\n    sinplot(6)\n\nwith sns.axes_style(\"ticks\"):\n    ax = f.add_subplot(gs[1, 0])\n    sinplot(6)\n\nwith sns.axes_style(\"whitegrid\"):\n    ax = f.add_subplot(gs[1, 1])\n    sinplot(6)\n\nf.tight_layout()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Overriding elements of the seaborn styles"
            },
            {
                "cell_type": "markdown",
                "nl_original": "If you want to customize the seaborn styles, you can pass a dictionary of parameters to the rc argument of  and . Note that you can only override the parameters that are part of the style definition through this method. (However, the higher-level  function takes a dictionary of any matplotlib parameters)."
            },
            {
                "cell_type": "markdown",
                "nl_original": "If you want to see what parameters are included, you can just call the function with no arguments, which will return the current settings:"
            },
            {
                "cell_type": "code",
                "code": "sns.axes_style()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can then set different versions of these parameters:"
            },
            {
                "cell_type": "code",
                "code": "sns.set_style(\"darkgrid\", {\"axes.facecolor\": \".9\"})\nsinplot()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Scaling plot elements"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A separate set of parameters control the scale of plot elements, which should let you use the same code to make plots that are suited for use in settings where larger or smaller plots are appropriate."
            },
            {
                "cell_type": "markdown",
                "nl_original": "First let\u2019s reset the default parameters by calling :"
            },
            {
                "cell_type": "code",
                "code": "sns.set_theme()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The four preset contexts, in order of relative size, are paper, notebook, talk, and poster. The notebook style is the default, and was used in the plots above."
            },
            {
                "cell_type": "code",
                "code": "sns.set_context(\"paper\")\nsinplot()\n"
            },
            {
                "cell_type": "code",
                "code": "sns.set_context(\"talk\")\nsinplot()\n"
            },
            {
                "cell_type": "code",
                "code": "sns.set_context(\"poster\")\nsinplot()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Most of what you now know about the style functions should transfer to the context functions."
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can call  with one of these names to set the parameters, and you can override the parameters by providing a dictionary of parameter values."
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can also independently scale the size of the font elements when changing the context. (This option is also available through the top-level  function)."
            },
            {
                "cell_type": "code",
                "code": "sns.set_context(\"notebook\", font_scale=1.5, rc={\"lines.linewidth\": 2.5})\nsinplot()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Similarly, you can temporarily control the scale of figures nested under a with statement."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Both the style and the context can be quickly configured with the  function. This function also sets the default color palette, but that will be covered in more detail in the  of the tutorial."
            }
        ],
        "Diverging color palettes": [
            {
                "cell_type": "markdown",
                "nl_original": "# Choosing color palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Seaborn makes it easy to use colors that are well-suited to the characteristics of your data and your visualization goals. This chapter discusses both the general principles that should guide your choices and the tools in seaborn that help you quickly find the best solution for a given application."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## General principles for using color in plots"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Components of color"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Because of the way our eyes work, a particular color can be defined using three components. We usually program colors in a computer by specifying their RGB values, which set the intensity of the red, green, and blue channels in a display. But for analyzing the perceptual attributes of a color, it\u2019s better to think in terms of <em>hue</em>, <em>saturation</em>, and <em>luminance</em> channels."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Hue is the component that distinguishes \u201cdifferent colors\u201d in a non-technical sense. It\u2019s property of color that leads to first-order names like \u201cred\u201d and \u201cblue\u201d:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Saturation (or chroma) is the <em>colorfulness</em>. Two colors with different hues will look more distinct when they have more saturation:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "And lightness corresponds to how much light is emitted (or reflected, for printed colors), ranging from black to white:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Vary hue to distinguish categories"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When you want to represent multiple categories in a plot, you typically should vary the color of the elements. Consider this simple example: in which of these two plots is it easier to count the number of triangular points?"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In the plot on the right, the orange triangles \u201cpop out\u201d, making it easy to distinguish them from the circles. This pop-out effect happens because our visual system prioritizes color differences."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The blue and orange colors differ mostly in terms of their hue. Hue is useful for representing categories: most people can distinguish a moderate number of hues relatively easily, and points that have different hues but similar brightness or intensity seem equally important. It also makes plots easier to talk about. Consider this example:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Most people would be able to quickly ascertain that there are five distinct categories in the plot on the left and, if asked to characterize the \u201cblue\u201d points, would be able to do so."
            },
            {
                "cell_type": "markdown",
                "nl_original": "With the plot on the right, where the points are all blue but vary in their luminance and saturation, it\u2019s harder to say how many unique categories are present. And how would we talk about a particular category? \u201cThe fairly-but-not-too-blue points?\u201d What\u2019s more, the gray dots seem to fade into the background, de-emphasizing them relative to the more intense blue dots. If the categories are equally important, this is a poor representation."
            },
            {
                "cell_type": "markdown",
                "nl_original": "So as a general rule, use hue variation to represent categories. With that said, here are few notes of caution. If you have more than a handful of colors in your plot, it can become difficult to keep in mind what each one means, unless there are pre-existing associations between the categories and the colors used to represent them. This makes your plot harder to interpret: rather than focusing on the data, a viewer will have to continually refer to the legend to make sense of what is shown. So you should strive not to make plots that are too complex. And be mindful that not everyone sees colors the same way. Varying both shape (or some other attribute) and color can help people with anomalous color vision understand your plots, and it can keep them (somewhat) interpretable if they are printed to black-and-white."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Vary luminance to represent numbers"
            },
            {
                "cell_type": "markdown",
                "nl_original": "On the other hand, hue variations are not well suited to representing numeric data. Consider this example, where we need colors to represent the counts in a bivariate histogram. On the left, we use a circular colormap, where gradual changes in the number of observation within each bin correspond to gradual changes in hue. On the right, we use a palette that uses brighter colors to represent bins with larger counts:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "With the hue-based palette, it\u2019s quite difficult to ascertain the shape of the bivariate distribution. In contrast, the luminance palette makes it much more clear that there are two prominent peaks."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Varying luminance helps you see structure in data, and changes in luminance are more intuitively processed as changes in importance. But the plot on the right does not use a grayscale colormap. Its colorfulness makes it more interesting, and the subtle hue variation increases the perceptual distance between two values. As a result, small differences slightly easier to resolve."
            },
            {
                "cell_type": "markdown",
                "nl_original": "These examples show that color palette choices are about more than aesthetics: the colors you choose can reveal patterns in your data if used effectively or hide them if used poorly. There is not one optimal palette, but there are palettes that are better or worse for particular datasets and visualization approaches."
            },
            {
                "cell_type": "markdown",
                "nl_original": "And aesthetics do matter: the more that people want to look at your figures, the greater the chance that they will learn something from them. This is true even when you are making plots for yourself. During exploratory data analysis, you may generate many similar figures. Varying the color palettes will add a sense of novelty, which keeps you engaged and prepared to notice interesting features of your data."
            },
            {
                "cell_type": "markdown",
                "nl_original": "So how can you choose color palettes that both represent your data well and look attractive?"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Tools for choosing color palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The most important function for working with color palettes is, aptly, . This function provides an interface to most of the possible ways that one can generate color palettes in seaborn. And it\u2019s used internally by any function that has a palette argument."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The primary argument to  is usually a string: either the name of a specific palette or the name of a family and additional arguments to select a specific member. In the latter case,  will delegate to more specific function, such as . It\u2019s also possible to pass a list of colors specified any way that matplotlib accepts (an RGB tuple, a hex code, or a name in the X11 table). The return value is an object that wraps a list of RGB tuples with a few useful methods, such as conversion to hex codes and a rich HTML representation."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Calling  with no arguments will return the current default color palette that matplotlib (and most seaborn functions) will use if colors are not otherwise specified. This default palette can be set with the corresponding  function, which calls  internally and accepts the same arguments."
            },
            {
                "cell_type": "markdown",
                "nl_original": "To motivate the different options that  provides, it will be useful to introduce a classification scheme for color palettes. Broadly, palettes fall into one of three categories:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "qualitative palettes, good for representing categorical data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "sequential palettes, good for representing numeric data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "diverging palettes, good for representing numeric data with a categorical boundary"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Qualitative color palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Qualitative palettes are well-suited to representing categorical data because most of their variation is in the hue component. The default color palette in seaborn is a qualitative palette with ten distinct hues:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "These colors have the same ordering as the default matplotlib color palette, \"tab10\", but they are a bit less intense. Compare:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"tab10\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Seaborn in fact has six variations of matplotlib\u2019s palette, called deep, muted, pastel, bright, dark, and colorblind. These span a range of average luminance and saturation values:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Many people find the moderated hues of the default \"deep\" palette to be aesthetically pleasing, but they are also less distinct. As a result, they may be more difficult to discriminate in some contexts, which is something to keep in mind when making publication graphics.  can be helpful for estimating how the seaborn color palettes perform when simulating different forms of colorblindess."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Using circular color systems"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When you have an arbitrary number of categories, the easiest approach to finding unique hues is to draw evenly-spaced colors in a circular color space (one where the hue changes while keeping the brightness and saturation constant). This is what most seaborn functions default to when they need to use more colors than are currently set in the default color cycle."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The most common way to do this uses the hls color space, which is a simple transformation of RGB values. We saw this color palette before as a counterexample for how to plot a histogram:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"hls\", 8)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Because of the way the human visual system works, colors that have the same luminance and saturation in terms of their RGB values won\u2019t necessarily look equally intense To remedy this, seaborn provides an interface to the  system (since renamed to HSLuv), which achieves less intensity variation as you rotate around the color wheel:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"husl\", 8)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When seaborn needs a categorical palette with more colors than are available in the current default, it will use this approach."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Using categorical Color Brewer palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Another source of visually pleasing categorical palettes comes from the  tool (which also has sequential and diverging palettes, as we\u2019ll see below)."
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"Set2\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Be aware that the qualitative Color Brewer palettes have different lengths, and the default behavior of  is to give you the full list:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"Paired\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Sequential color palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The second major class of color palettes is called \u201csequential\u201d. This kind of mapping is appropriate when data range from relatively low or uninteresting values to relatively high or interesting values (or vice versa). As we saw above, the primary dimension of variation in a sequential palette is luminance. Some seaborn functions will default to a sequential palette when you are mapping numeric data. (For historical reasons, both categorical and numeric mappings are specified with the hue parameter in functions like  or , even though numeric mappings use color palettes with relatively little hue variation)."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Perceptually uniform palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Because they are intended to represent numeric values, the best sequential palettes will be <em>perceptually uniform</em>, meaning that the relative discriminability of two colors is proportional to the difference between the corresponding data values. Seaborn includes four perceptually uniform sequential colormaps: \"rocket\", \"mako\", \"flare\", and \"crest\". The first two have a very wide luminance range and are well suited for applications such as heatmaps, where colors fill the space they are plotted into:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"rocket\", as_cmap=True)\n"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"mako\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Because the extreme values of these colormaps approach white, they are not well-suited for coloring elements such as lines or points: it will be difficult to discriminate important values against a white or gray background. The \u201cflare\u201d and \u201ccrest\u201d colormaps are a better choice for such plots. They have a more restricted range of luminance variations, which they compensate for with a slightly more pronounced variation in hue. The default direction of the luminance ramp is also reversed, so that smaller values have lighter colors:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"flare\", as_cmap=True)\n"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"crest\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It is also possible to use the perceptually uniform colormaps provided by matplotlib, such as \"magma\" and \"viridis\":"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"magma\", as_cmap=True)\n"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"viridis\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As with the convention in matplotlib, every continuous colormap has a reversed version, which has the suffix \"_r\":"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"rocket_r\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Discrete vs. continuous mapping"
            },
            {
                "cell_type": "markdown",
                "nl_original": "One thing to be aware of is that seaborn can generate discrete values from sequential colormaps and, when doing so, it will not use the most extreme values. Compare the discrete version of \"rocket\" against the continuous version shown above:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"rocket\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Internally, seaborn uses the discrete version for categorical data and the continuous version when in numeric mapping mode. Discrete sequential colormaps can be well-suited for visualizing categorical data with an intrinsic ordering, especially if there is some hue variation."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Sequential \u201ccubehelix\u201d palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The perceptually uniform colormaps are difficult to programmatically generate, because they are not based on the RGB color space. The  system offers an RGB-based compromise: it generates sequential palettes with a linear increase or decrease in brightness and some continuous variation in hue. While not perfectly perceptually uniform, the resulting colormaps have many good properties. Importantly, many aspects of the design process are parameterizable."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Matplotlib has the default cubehelix version built into it:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"cubehelix\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The default palette returned by the seaborn  function is a bit different from the matplotlib default in that it does not rotate as far around the hue wheel or cover as wide a range of intensities. It also reverses the luminance ramp:"
            },
            {
                "cell_type": "code",
                "code": "sns.cubehelix_palette(as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Other arguments to  control how the palette looks. The two main things you\u2019ll change are the start (a value between 0 and 3) and rot, or number of rotations (an arbitrary value, but usually between -1 and 1)"
            },
            {
                "cell_type": "code",
                "code": "sns.cubehelix_palette(start=.5, rot=-.5, as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The more you rotate, the more hue variation you will see:"
            },
            {
                "cell_type": "code",
                "code": "sns.cubehelix_palette(start=.5, rot=-.75, as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can control both how dark and light the endpoints are and their order:"
            },
            {
                "cell_type": "code",
                "code": "sns.cubehelix_palette(start=2, rot=0, dark=0, light=.95, reverse=True, as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  accepts a string code, starting with \"ch:\", for generating an arbitrary cubehelix palette. You can passs the names of parameters in the string:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"ch:start=.2,rot=-.3\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "And for compactness, each parameter can be specified with its first letter:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"ch:s=-.2,r=.6\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Custom sequential palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "For a simpler interface to custom sequential palettes, you can use  or , which are both seeded with a single color and produce a palette that ramps either from light or dark desaturated values to that color:"
            },
            {
                "cell_type": "code",
                "code": "sns.light_palette(\"seagreen\", as_cmap=True)\n"
            },
            {
                "cell_type": "code",
                "code": "sns.dark_palette(\"#69d\", reverse=True, as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As with cubehelix palettes, you can also specify light or dark palettes through  or anywhere palette is accepted:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"light:b\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Reverse the colormap by adding \"_r\":"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"dark:salmon_r\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Sequential Color Brewer palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The Color Brewer library also has some good options for sequential palettes. They include palettes with one primary hue:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"Blues\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Along with multi-hue options:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"YlOrBr\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Diverging color palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The third class of color palettes is called \u201cdiverging\u201d. These are used for data where both large low and high values are interesting and span a midpoint value (often 0) that should be demphasized. The rules for choosing good diverging palettes are similar to good sequential palettes, except now there should be two dominant hues in the colormap, one at (or near) each pole. It\u2019s also important that the starting values are of similar brightness and saturation."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Perceptually uniform diverging palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Seaborn includes two perceptually uniform diverging palettes: \"vlag\" and \"icefire\". They both use blue and red at their poles, which many intuitively processes as \u201ccold\u201d and \u201chot\u201d:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"vlag\", as_cmap=True)\n"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"icefire\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Custom diverging palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can also use the seaborn function  to create a custom colormap for diverging data. This function makes diverging palettes using the husl color system. You pass it two hues (in degrees) and, optionally, the lightness and saturation values for the extremes. Using husl means that the extreme values, and the resulting ramps to the midpoint, while not perfectly perceptually uniform, will be well-balanced:"
            },
            {
                "cell_type": "code",
                "code": "sns.diverging_palette(220, 20, as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This is convenient when you want to stray from the boring confines of cold-hot approaches:"
            },
            {
                "cell_type": "code",
                "code": "sns.diverging_palette(145, 300, s=60, as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s also possible to make a palette where the midpoint is dark rather than light:"
            },
            {
                "cell_type": "code",
                "code": "sns.diverging_palette(250, 30, l=65, center=\"dark\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s important to emphasize here that using red and green, while intuitive, ."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Other diverging palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "There are a few other good diverging palettes built into matplotlib, including Color Brewer palettes:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"Spectral\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "And the coolwarm palette, which has less contrast between the middle values and the extremes:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"coolwarm\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As you can see, there are many options for using color in your visualizations. Seaborn tries both to use good defaults and to offer a lot of flexibility."
            },
            {
                "cell_type": "markdown",
                "nl_original": "This discussion is only the beginning, and there are a number of good resources for learning more about techniques for using color in visualizations. One great example is this  from the NASA Earth Observatory. The matplotlib docs also have a  that illustrates some of the perceptual properties of their colormaps."
            }
        ]
    },
    "API Overview": {
        "Combining multiple views on the data": [
            {
                "cell_type": "markdown",
                "nl_original": "# Overview of seaborn plotting functions"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Most of your interactions with seaborn will happen through a set of plotting functions. Later chapters in the tutorial will explore the specific features offered by each function. This chapter will introduce, at a high-level, the different kinds of functions that you will encounter."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Similar functions for similar tasks"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The seaborn namespace is flat; all of the functionality is accessible at the top level. But the code itself is hierarchically structured, with modules of functions that achieve similar visualization goals through different means. Most of the docs are structured around these modules: you\u2019ll encounter names like \u201crelational\u201d, \u201cdistributional\u201d, and \u201ccategorical\u201d."
            },
            {
                "cell_type": "markdown",
                "nl_original": "For example, the  defines functions that specialize in representing the distribution of datapoints. This includes familiar methods like the histogram:"
            },
            {
                "cell_type": "code",
                "code": "penguins = sns.load_dataset(\"penguins\")\nsns.histplot(data=penguins, x=\"flipper_length_mm\", hue=\"species\", multiple=\"stack\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Along with similar, but perhaps less familiar, options such as kernel density estimation:"
            },
            {
                "cell_type": "code",
                "code": "sns.kdeplot(data=penguins, x=\"flipper_length_mm\", hue=\"species\", multiple=\"stack\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Functions within a module share a lot of underlying code and offer similar features that may not be present in other components of the library (such as multiple=\"stack\" in the examples above). They are designed to facilitate switching between different visual representations as you explore a dataset, because different representations often have complementary strengths and weaknesses."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Figure-level vs. axes-level functions"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In addition to the different modules, there is a cross-cutting classification of seaborn functions as \u201caxes-level\u201d or \u201cfigure-level\u201d. The examples above are axes-level functions. They plot data onto a single matplotlib.pyplot.Axes object, which is the return value of the function."
            },
            {
                "cell_type": "markdown",
                "nl_original": "In contrast, figure-level functions interface with matplotlib through a seaborn object, usually a , that manages the figure. Each module has a single figure-level function, which offers a unitary interface to its various axes-level functions. The organization looks a bit like this:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "For example,  is the figure-level function for the distributions module. Its default behavior is to draw a histogram, using the same code as  behind the scenes:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(data=penguins, x=\"flipper_length_mm\", hue=\"species\", multiple=\"stack\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "To draw a kernel density plot instead, using the same code as , select it using the kind parameter:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(data=penguins, x=\"flipper_length_mm\", hue=\"species\", multiple=\"stack\", kind=\"kde\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You\u2019ll notice that the figure-level plots look mostly like their axes-level counterparts, but there are a few differences. Notably, the legend is placed outside the plot. They also have a slightly different shape (more on that shortly)."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The most useful feature offered by the figure-level functions is that they can easily create figures with multiple subplots. For example, instead of stacking the three distributions for each species of penguins in the same axes, we can \u201cfacet\u201d them by plotting each distribution across the columns of the figure:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(data=penguins, x=\"flipper_length_mm\", hue=\"species\", col=\"species\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The figure-level functions wrap their axes-level counterparts and pass the kind-specific keyword arguments (such as the bin size for a histogram) down to the underlying function. That means they are no less flexible, but there is a downside: the kind-specific parameters don\u2019t appear in the function signature or docstrings. Some of their features might be less discoverable, and you may need to look at two different pages of the documentation before understanding how to achieve a specific goal."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Axes-level functions make self-contained plots"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The axes-level functions are written to act like drop-in replacements for matplotlib functions. While they add axis labels and legends automatically, they don\u2019t modify anything beyond the axes that they are drawn into. That means they can be composed into arbitrarily-complex matplotlib figures with predictable results."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The axes-level functions call  internally, which hooks into the matplotlib state-machine interface so that they draw their plots on the \u201ccurrently-active\u201d axes. But they additionally accept an ax= argument, which integrates with the object-oriented interface and lets you specify exactly where each plot should go:"
            },
            {
                "cell_type": "code",
                "code": "f, axs = plt.subplots(1, 2, figsize=(8, 4), gridspec_kw=dict(width_ratios=[4, 3]))\nsns.scatterplot(data=penguins, x=\"flipper_length_mm\", y=\"bill_length_mm\", hue=\"species\", ax=axs[0])\nsns.histplot(data=penguins, x=\"species\", hue=\"species\", shrink=.8, alpha=.8, legend=False, ax=axs[1])\nf.tight_layout()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Figure-level functions own their figure"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In contrast, figure-level functions cannot (easily) be composed with other plots. By design, they \u201cown\u201d their own figure, including its initialization, so there\u2019s no notion of using a figure-level function to draw a plot onto an existing axes. This constraint allows the figure-level functions to implement features such as putting the legend outside of the plot."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Nevertheless, it is possible to go beyond what the figure-level functions offer by accessing the matplotlib axes on the object that they return and adding other elements to the plot that way:"
            },
            {
                "cell_type": "code",
                "code": "tips = sns.load_dataset(\"tips\")\ng = sns.relplot(data=tips, x=\"total_bill\", y=\"tip\")\ng.ax.axline(xy1=(10, 2), slope=.2, color=\"b\", dashes=(5, 2))\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Customizing plots from a figure-level function"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The figure-level functions return a  instance, which has a few methods for customizing attributes of the plot in a way that is \u201csmart\u201d about the subplot organization. For example, you can change the labels on the external axes using a single line of code:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.relplot(data=penguins, x=\"flipper_length_mm\", y=\"bill_length_mm\", col=\"sex\")\ng.set_axis_labels(\"Flipper length (mm)\", \"Bill length (mm)\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "While convenient, this does add a bit of extra complexity, as you need to remember that this method is not part of the matplotlib API and exists only when using a figure-level function."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Specifying figure sizes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "To increase or decrease the size of a matplotlib plot, you set the width and height of the entire figure, either in the , while setting up the plot (e.g. with the figsize parameter of ), or by calling a method on the figure object (e.g. matplotlib.Figure.set_size_inches()). When using an axes-level function in seaborn, the same rules apply: the size of the plot is determined by the size of the figure it is part of and the axes layout in that figure."
            },
            {
                "cell_type": "markdown",
                "nl_original": "When using a figure-level function, there are several key differences. First, the functions themselves have parameters to control the figure size (although these are actually parameters of the underlying  that manages the figure). Second, these parameters, height and aspect, parameterize the size slightly differently than the width, height parameterization in matplotlib (using the seaborn parameters, width = height * aspect). Most importantly, the parameters correspond to the size of each <em>subplot</em>, rather than the size of the overall figure."
            },
            {
                "cell_type": "markdown",
                "nl_original": "To illustrate the difference between these approaches, here is the default output of  with one subplot:"
            },
            {
                "cell_type": "code",
                "code": "f, ax = plt.subplots()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A figure with multiple columns will have the same overall size, but the axes will be squeezed horizontally to fit in the space:"
            },
            {
                "cell_type": "code",
                "code": "f, ax = plt.subplots(1, 2, sharey=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In contrast, a plot created by a figure-level function will be square. To demonstrate that, let\u2019s set up an empty plot by using  directly. This happens behind the scenes in functions like , , or :"
            },
            {
                "cell_type": "code",
                "code": "g = sns.FacetGrid(penguins)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When additional columns are added, the figure itself will become wider, so that its subplots have the same size and shape:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.FacetGrid(penguins, col=\"sex\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "And you can adjust the size and shape of each subplot without accounting for the total number of rows and columns in the figure:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.FacetGrid(penguins, col=\"sex\", height=3.5, aspect=.75)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The upshot is that you can assign faceting variables without stopping to think about how you\u2019ll need to adjust the total figure size. A downside is that, when you do want to change the figure size, you\u2019ll need to remember that things work a bit differently than they do in matplotlib."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Relative merits of figure-level functions"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Here is a summary of the pros and cons that we have discussed above:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "On balance, the figure-level functions add some additional complexity that can make things more confusing for beginners, but their distinct features give them additional power. The tutorial documentation mostly uses the figure-level functions, because they produce slightly cleaner plots, and we generally recommend their use for most applications. The one situation where they are not a good choice is when you need to make a complex, standalone figure that composes multiple different plot kinds. At this point, it\u2019s recommended to set up the figure using matplotlib directly and to fill in the individual components using axes-level functions."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Combining multiple views on the data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Two important plotting functions in seaborn don\u2019t fit cleanly into the classification scheme discussed above. These functions,  and , employ multiple kinds of plots from different modules to represent multiple aspects of a dataset in a single figure. Both plots are figure-level functions and create figures with multiple subplots by default. But they use different objects to manage the figure:  and , respectively."
            },
            {
                "cell_type": "markdown",
                "nl_original": " plots the relationship or joint distribution of two variables while adding marginal axes that show the univariate distribution of each one separately:"
            },
            {
                "cell_type": "code",
                "code": "sns.jointplot(data=penguins, x=\"flipper_length_mm\", y=\"bill_length_mm\", hue=\"species\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": " is similar \u2014 it combines joint and marginal views \u2014 but rather than focusing on a single relationship, it visualizes every pairwise combination of variables simultaneously:"
            },
            {
                "cell_type": "code",
                "code": "sns.pairplot(data=penguins, hue=\"species\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Behind the scenes, these functions are using axes-level functions that you have already met ( and ), and they also have a kind parameter that lets you quickly swap in a different representation:"
            },
            {
                "cell_type": "code",
                "code": "sns.jointplot(data=penguins, x=\"flipper_length_mm\", y=\"bill_length_mm\", hue=\"species\", kind=\"hist\")\n"
            }
        ],
        "Options for visualizing wide-form data": [
            {
                "cell_type": "markdown",
                "nl_original": "# Data structures accepted by seaborn"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As a data visualization library, seaborn requires that you provide it with data. This chapter explains the various ways to accomplish that task. Seaborn supports several different dataset formats, and most functions accept data represented with objects from the  or  libraries as well as built-in Python types like lists and dictionaries. Understanding the usage patterns associated with these different options will help you quickly create useful visualizations for nearly any dataset."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As of current writing (v0.11.0), the full breadth of options covered here are supported by only a subset of the modules in seaborn (namely, the  and  modules). The other modules offer much of the same flexibility, but have some exceptions (e.g.,  and  are limited to long-form data with named variables). The data-ingest code will be standardized over the next few release cycles, but until that point, be mindful of the specific documentation for each function if it is not doing what you expect with your dataset."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Long-form vs. wide-form data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Most plotting functions in seaborn are oriented towards <em>vectors</em> of data. When plotting x against y, each variable should be a vector. Seaborn accepts data <em>sets</em> that have more than one vector organized in some tabular fashion. There is a fundamental distinction between \u201clong-form\u201d and \u201cwide-form\u201d data tables, and seaborn will treat each differently."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Long-form data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A long-form data table has the following characteristics:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Each variable is a column"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Each observation is a row"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As a simple example, consider the \u201cflights\u201d dataset, which records the number of airline passengers who flew in each month from 1949 to 1960. This dataset has three variables (<em>year</em>, <em>month</em>, and number of <em>passengers</em>):"
            },
            {
                "cell_type": "code",
                "code": "flights = sns.load_dataset(\"flights\")\nflights.head()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "With long-form data, columns in the table are given roles in the plot by explicitly assigning them to one of the variables. For example, making a monthly plot of the number of passengers per year looks like this:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(data=flights, x=\"year\", y=\"passengers\", hue=\"month\", kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The advantage of long-form data is that it lends itself well to this explicit specification of the plot. It can accommodate datasets of arbitrary complexity, so long as the variables and observations can be clearly defined. But this format takes some getting used to, because it is often not the model of the data that one has in their head."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Wide-form data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "For simple datasets, it is often more intuitive to think about data the way it might be viewed in a spreadsheet, where the columns and rows contain <em>levels</em> of different variables. For example, we can convert the flights dataset into a wide-form organization by  \u201cpivoting\u201d it so that each column has each month\u2019s time series over years:"
            },
            {
                "cell_type": "code",
                "code": "flights_wide = flights.pivot(index=\"year\", columns=\"month\", values=\"passengers\")\nflights_wide.head()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Here we have the same three variables, but they are organized differently. The variables in this dataset are linked to the <em>dimensions</em> of the table, rather than to named fields. Each observation is defined by both the value at a cell in the table and the coordinates of that cell with respect to the row and column indices."
            },
            {
                "cell_type": "markdown",
                "nl_original": "With long-form data, we can access variables in the dataset by their name. That is not the case with wide-form data. Nevertheless, because there is a clear association between the dimensions of the table and the variable in the dataset, seaborn is able to assign those variables roles in the plot."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Seaborn treats the argument to data as wide form when neither x nor y are assigned."
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(data=flights_wide, kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This plot looks very  similar to the one before. Seaborn has assigned the index of the dataframe to x, the values of the dataframe to y, and it has drawn a separate line for each month. There is a notable difference between the two plots, however. When the dataset went through the \u201cpivot\u201d operation that converted it from long-form to wide-form, the information about what the values mean was lost. As a result, there is no y axis label. (The lines also have dashes here, because  has mapped the column variable to both the hue and style semantic so that the plot is more accessible. We didn\u2019t do that in the long-form case, but we could have by setting style=\"month\")."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Thus far, we did much less typing while using wide-form data and made nearly the same plot. This seems easier! But a big advantage of long-form data is that, once you have the data in the correct format, you no longer need to think about its <em>structure</em>. You can design your plots by thinking only about the variables contained within it. For example, to draw lines that represent the monthly time series for each year, simply reassign the variables:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(data=flights, x=\"month\", y=\"passengers\", hue=\"year\", kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "To achieve the same remapping with the wide-form dataset, we would need to transpose the table:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(data=flights_wide.transpose(), kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "(This example also illustrates another wrinkle, which is that seaborn currently considers the column variable in a wide-form dataset to be categorical regardless of its datatype, whereas, because the long-form variable is numeric, it is assigned a quantitative color palette and legend. This may change in the future)."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The absence of explicit variable assignments also means that each plot type needs to define a fixed mapping between the dimensions of the wide-form data and the roles in the plot. Because this natural mapping may vary across plot types, the results are less predictable when using wide-form data. For example, the  plots assign the <em>column</em> dimension of the table to x and then aggregate across the rows (ignoring the index):"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=flights_wide, kind=\"box\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When using pandas to represent wide-form data, you are limited to just a few variables (no more than three). This is because seaborn does not make use of multi-index information, which is how pandas represents additional variables in a tabular format. The  project offers labeled N-dimensional array objects, which can be considered a generalization of wide-form data to higher dimensions. At present, seaborn does not directly support objects from xarray, but they can be transformed into a long-form  using the to_pandas method and then plotted in seaborn like any other long-form data set."
            },
            {
                "cell_type": "markdown",
                "nl_original": "In summary, we can think of long-form and wide-form datasets as looking something like this:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Messy data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Many datasets cannot be clearly interpreted using either long-form or wide-form rules. If datasets that are clearly long-form or wide-form are , we might say that these more ambiguous datasets are \u201cmessy\u201d. In a messy dataset, the variables are neither uniquely defined by the keys nor by the dimensions of the table. This often occurs with <em>repeated-measures</em> data, where it is natural to organize a table such that each row corresponds to the <em>unit</em> of data collection. Consider this simple dataset from a psychology experiment in which twenty subjects performed a memory task where they studied anagrams while their attention was either divided or focused:"
            },
            {
                "cell_type": "code",
                "code": "anagrams = sns.load_dataset(\"anagrams\")\nanagrams\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The attention variable is <em>between-subjects</em>, but there is also a <em>within-subjects</em> variable: the number of possible solutions to the anagrams, which varied from 1 to 3. The dependent measure is a score of memory performance. These two variables (number and score) are jointly encoded across several columns. As a result, the whole dataset is neither clearly long-form nor clearly wide-form."
            },
            {
                "cell_type": "markdown",
                "nl_original": "How might we tell seaborn to plot the average score as a function of attention and number of solutions? We\u2019d first need to coerce the data into one of our two structures. Let\u2019s transform it to a tidy long-form table, such that each variable is a column and each row is an observation. We can use the method  to accomplish this task:"
            },
            {
                "cell_type": "code",
                "code": "anagrams_long = anagrams.melt(id_vars=[\"subidr\", \"attnr\"], var_name=\"solutions\", value_name=\"score\")\nanagrams_long.head()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Now we can make the plot that we want:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=anagrams_long, x=\"solutions\", y=\"score\", hue=\"attnr\", kind=\"point\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Further reading and take-home points"
            },
            {
                "cell_type": "markdown",
                "nl_original": "For a longer discussion about tabular data structures, you could read the  paper by Hadley Whickham. Note that seaborn uses a slightly different set of concepts than are defined in the paper. While the paper associates tidyness with long-form structure, we have drawn a distinction between \u201ctidy wide-form\u201d data, where there is a clear mapping between variables in the dataset and the dimensions of the table, and \u201cmessy data\u201d, where no such mapping exists."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The long-form structure has clear advantages. It allows you to create figures by explicitly assigning variables in the dataset to roles in plot, and you can do so with more than three variables. When possible, try to represent your data with a long-form structure when embarking on serious analysis. Most of the examples in the seaborn documentation will use long-form data. But in cases where it is more natural to keep the dataset wide, remember that seaborn can remain useful."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Options for visualizing long-form data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "While long-form data has a precise definition, seaborn is fairly flexible in terms of how it is actually organized across the data structures in memory. The examples in the rest of the documentation will typically use  objects and reference variables in them by assigning names of their columns to the variables in the plot. But it is also possible to store vectors in a Python dictionary or a class that implements that interface:"
            },
            {
                "cell_type": "code",
                "code": "flights_dict = flights.to_dict()\nsns.relplot(data=flights_dict, x=\"year\", y=\"passengers\", hue=\"month\", kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Many pandas operations, such as the split-apply-combine operations of a group-by, will produce a dataframe where information has moved from the columns of the input dataframe to the index of the output. So long as the name is retained, you can still reference the data as normal:"
            },
            {
                "cell_type": "code",
                "code": "flights_avg = flights.groupby(\"year\").mean()\nsns.relplot(data=flights_avg, x=\"year\", y=\"passengers\", kind=\"line\")\n"
            },
            {
                "cell_type": "code",
                "code": "/var/folders/qk/cdrdfhfn5g554pnb30pp4ylr0000gn/T/ipykernel_77263/885836857.py:1: FutureWarning: The default value of numeric_only in DataFrameGroupBy.mean is deprecated. In a future version, numeric_only will default to False. Either specify numeric_only or select only columns which should be valid for the function.\n  flights_avg = flights.groupby(\"year\").mean()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Additionally, it\u2019s possible to pass vectors of data directly as arguments to x, y, and other plotting variables. If these vectors are pandas objects, the name attribute will be used to label the plot:"
            },
            {
                "cell_type": "code",
                "code": "year = flights_avg.index\npassengers = flights_avg[\"passengers\"]\nsns.relplot(x=year, y=passengers, kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Numpy arrays and other objects that implement the Python sequence interface work too, but if they don\u2019t have names, the plot will not be as informative without further tweaking:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(x=year.to_numpy(), y=passengers.to_list(), kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Options for visualizing wide-form data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The options for passing wide-form data are even more flexible. As with long-form data, pandas objects are preferable because the name (and, in some cases, index) information can be used. But in essence, any format that can be viewed as a single vector or a collection of vectors can be passed to data, and a valid plot can usually be constructed."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The example we saw above used a rectangular , which can be thought of as a collection of its columns. A dict or list of pandas objects will also work, but we\u2019ll lose the axis labels:"
            },
            {
                "cell_type": "code",
                "code": "flights_wide_list = [col for _, col in flights_wide.items()]\nsns.relplot(data=flights_wide_list, kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The vectors in a collection do not need to have the same length. If they have an index, it will be used to align them:"
            },
            {
                "cell_type": "code",
                "code": "two_series = [flights_wide.loc[:1955, \"Jan\"], flights_wide.loc[1952:, \"Aug\"]]\nsns.relplot(data=two_series, kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Whereas an ordinal index will be used for numpy arrays or simple Python sequences:"
            },
            {
                "cell_type": "code",
                "code": "two_arrays = [s.to_numpy() for s in two_series]\nsns.relplot(data=two_arrays, kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "But a dictionary of such vectors will at least use the keys:"
            },
            {
                "cell_type": "code",
                "code": "two_arrays_dict = {s.name: s.to_numpy() for s in two_series}\nsns.relplot(data=two_arrays_dict, kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Rectangular numpy arrays are treated just like a dataframe without index information, so they are viewed as a collection of column vectors. Note that this is different from how numpy indexing operations work, where a single indexer will access a row. But it is consistent with how pandas would turn the array into a dataframe or how matplotlib would plot it:"
            },
            {
                "cell_type": "code",
                "code": "flights_array = flights_wide.to_numpy()\nsns.relplot(data=flights_array, kind=\"line\")\n"
            }
        ]
    },
    "Objects interface": {
        "Customizing the appearance": [
            {
                "cell_type": "markdown",
                "nl_original": "# The seaborn.objects interface"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The seaborn.objects namespace was introduced in version 0.12 as a completely new interface for making seaborn plots. It offers a more consistent and flexible API, comprising a collection of composable classes for transforming and plotting data. In contrast to the existing seaborn functions, the new interface aims to support end-to-end plot specification and customization without dropping down to matplotlib (although it will remain possible to do so if necessary)."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The objects interface is currently experimental and incomplete. It is stable enough for serious use, but there certainly are some rough edges and missing features."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Specifying a plot and mapping data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The objects interface should be imported with the following convention:"
            },
            {
                "cell_type": "code",
                "code": "import seaborn.objects as so\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The seaborn.objects namespace will provide access to all of the relevant classes. The most important is . You specify plots by instantiating a  object and calling its methods. Let\u2019s see a simple example:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\")\n    .add(so.Dot())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This code, which produces a scatter plot, should look reasonably familiar. Just as when using , we passed a tidy dataframe (penguins) and assigned two of its columns to the x and y coordinates of the plot. But instead of starting with the type of chart and then adding some data assignments, here we started with the data assignments and then added a graphical element."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Setting properties"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  class is an example of a : an object that graphically represents data values. Each mark will have a number of properties that can be set to change its appearance:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\")\n    .add(so.Dot(color=\"g\", pointsize=4))\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Mapping properties"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As with seaborn\u2019s functions, it is also possible to <em>map</em> data values to various graphical properties:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(\n        penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\",\n        color=\"species\", pointsize=\"body_mass_g\",\n    )\n    .add(so.Dot())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "While this basic functionality is not novel, an important difference from the function API is that properties are mapped using the same parameter names that would set them directly (instead of having hue vs. color, etc.). What matters is <em>where</em> the property is defined: passing a value when you initialize  will set it directly, whereas assigning a variable when you set up the  will <em>map</em> the corresponding data."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Beyond this difference, the objects interface also allows a much wider range of mark properties to be mapped:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(\n        penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\",\n        edgecolor=\"sex\", edgewidth=\"body_mass_g\",\n    )\n    .add(so.Dot(color=\".8\"))\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Defining groups"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  mark represents each data point independently, so the assignment of a variable to a property only has the effect of changing each dot\u2019s appearance. For marks that group or connect observations, such as , it also determines the number of distinct graphical elements:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(healthexp, x=\"Year\", y=\"Life_Expectancy\", color=\"Country\")\n    .add(so.Line())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It is also possible to define a grouping without changing any visual properties, by using group:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(healthexp, x=\"Year\", y=\"Life_Expectancy\", group=\"Country\")\n    .add(so.Line())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Transforming data before plotting"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Statistical transformation"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As with many seaborn functions, the objects interface supports statistical transformations. These are performed by  objects, such as :"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"species\", y=\"body_mass_g\")\n    .add(so.Bar(), so.Agg())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In the function interface, statistical transformations are possible with some visual representations (e.g. ) but not others (e.g. ). The objects interface more cleanly separates representation and transformation, allowing you to compose  and  objects:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"species\", y=\"body_mass_g\")\n    .add(so.Dot(pointsize=10), so.Agg())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When forming groups by mapping properties, the  transformation is applied to each group separately:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"species\", y=\"body_mass_g\", color=\"sex\")\n    .add(so.Dot(pointsize=10), so.Agg())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Resolving overplotting"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Some seaborn functions also have mechanisms that automatically resolve overplotting, as when  \u201cdodges\u201d bars once hue is assigned. The objects interface has less complex default behavior. Bars representing multiple groups will overlap by default:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"species\", y=\"body_mass_g\", color=\"sex\")\n    .add(so.Bar(), so.Agg())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Nevertheless, it is possible to compose the  mark with the  stat and a second transformation, implemented by :"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"species\", y=\"body_mass_g\", color=\"sex\")\n    .add(so.Bar(), so.Agg(), so.Dodge())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  class is an example of a  transformation, which is like a  but only adjusts x and y coordinates. The  classes can be applied with any mark, and it\u2019s not necessary to use a  first:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"species\", y=\"body_mass_g\", color=\"sex\")\n    .add(so.Dot(), so.Dodge())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s also possible to apply multiple  operations in sequence:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"species\", y=\"body_mass_g\", color=\"sex\")\n    .add(so.Dot(), so.Dodge(), so.Jitter(.3))\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Creating variables through transformation"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  stat requires both x and y to already be defined, but variables can also be <em>created</em> through statistical transformation. For example, the  stat requires only one of x <em>or</em> y to be defined, and it will create the other by counting observations:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"species\")\n    .add(so.Bar(), so.Hist())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  stat will also create new x values (by binning) when given numeric data:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"flipper_length_mm\")\n    .add(so.Bars(), so.Hist())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Notice how we used , rather than  for the plot with the continuous x axis. These two marks are related, but  has different defaults and works better for continuous histograms. It also produces a different, more efficient matplotlib artist. You will find the pattern of singular/plural marks elsewhere. The plural version is typically optimized for cases with larger numbers of marks."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Some transforms accept both x and y, but add <em>interval</em> data for each coordinate. This is particularly relevant for plotting error bars after aggregating:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"body_mass_g\", y=\"species\", color=\"sex\")\n    .add(so.Range(), so.Est(errorbar=\"sd\"), so.Dodge())\n    .add(so.Dot(), so.Agg(), so.Dodge())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Orienting marks and transforms"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When aggregating, dodging, and drawing a bar, the x and y variables are treated differently. Each operation has the concept of an <em>orientation</em>. The  tries to determine the orientation automatically based on the data types of the variables. For instance, if we flip the assignment of species and body_mass_g, we\u2019ll get the same plot, but oriented horizontally:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"body_mass_g\", y=\"species\", color=\"sex\")\n    .add(so.Bar(), so.Agg(), so.Dodge())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Sometimes, the correct orientation is ambiguous, as when both the x and y variables are numeric. In these cases, you can be explicit by passing the orient parameter to :"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(tips, x=\"total_bill\", y=\"size\", color=\"time\")\n    .add(so.Bar(), so.Agg(), so.Dodge(), orient=\"y\")\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Building and displaying the plot"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Each example thus far has produced a single subplot with a single kind of mark on it. But  does not limit you to this."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Adding multiple layers"
            },
            {
                "cell_type": "markdown",
                "nl_original": "More complex single-subplot graphics can be created by calling  repeatedly. Each time it is called, it defines a <em>layer</em> in the plot. For example, we may want to add a scatterplot (now using ) and then a regression fit:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(tips, x=\"total_bill\", y=\"tip\")\n    .add(so.Dots())\n    .add(so.Line(), so.PolyFit())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Variable mappings that are defined in the  constructor will be used for all layers:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(tips, x=\"total_bill\", y=\"tip\", color=\"time\")\n    .add(so.Dots())\n    .add(so.Line(), so.PolyFit())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Layer-specific mappings"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can also define a mapping such that it is used only in a specific layer. This is accomplished by defining the mapping within the call to  for the relevant layer:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(tips, x=\"total_bill\", y=\"tip\")\n    .add(so.Dots(), color=\"time\")\n    .add(so.Line(color=\".2\"), so.PolyFit())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Alternatively, define the layer for the entire plot, but <em>remove</em> it from a specific layer by setting the variable to None:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(tips, x=\"total_bill\", y=\"tip\", color=\"time\")\n    .add(so.Dots())\n    .add(so.Line(color=\".2\"), so.PolyFit(), color=None)\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "To recap, there are three ways to specify the value of a mark property: (1) by mapping a variable in all layers, (2) by mapping a variable in a specific layer, and (3) by setting the property directy:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Faceting and pairing subplots"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As with seaborn\u2019s figure-level functions (, , etc.), the  interface can also produce figures with multiple \u201cfacets\u201d, or subplots containing subsets of data. This is accomplished with the  method:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"flipper_length_mm\")\n    .facet(\"species\")\n    .add(so.Bars(), so.Hist())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Call  with the variables that should be used to define the columns and/or rows of the plot:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"flipper_length_mm\")\n    .facet(col=\"species\", row=\"sex\")\n    .add(so.Bars(), so.Hist())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can facet using a variable with a larger number of levels by \u201cwrapping\u201d across the other dimension:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(healthexp, x=\"Year\", y=\"Life_Expectancy\")\n    .facet(col=\"Country\", wrap=3)\n    .add(so.Line())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "All layers will be faceted unless you explicitly exclude them, which can\nbe useful for providing additional context on each subplot:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(healthexp, x=\"Year\", y=\"Life_Expectancy\")\n    .facet(\"Country\", wrap=3)\n    .add(so.Line(alpha=.3), group=\"Country\", col=None)\n    .add(so.Line(linewidth=3))\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "An alternate way to produce subplots is . Like , this draws all of the data on each subplot, using different variables for the x and/or y coordinates:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, y=\"body_mass_g\", color=\"species\")\n    .pair(x=[\"bill_length_mm\", \"bill_depth_mm\"])\n    .add(so.Dots())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can combine faceting and pairing so long as the operations add subplots on opposite dimensions:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, y=\"body_mass_g\", color=\"species\")\n    .pair(x=[\"bill_length_mm\", \"bill_depth_mm\"])\n    .facet(row=\"sex\")\n    .add(so.Dots())\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Integrating with matplotlib"
            },
            {
                "cell_type": "markdown",
                "nl_original": "There may be cases where you want multiple subplots to appear in a figure with a more complex structure than what  or  can provide. The current solution is to delegate figure setup to matplotlib and to supply the matplotlib object that  should use with the  method. This object can be either a , , or ; the latter is most useful for constructing bespoke subplot layouts:"
            },
            {
                "cell_type": "code",
                "code": "f = mpl.figure.Figure(figsize=(8, 4))\nsf1, sf2 = f.subfigures(1, 2)\n(\n    so.Plot(penguins, x=\"body_mass_g\", y=\"flipper_length_mm\")\n    .add(so.Dots())\n    .on(sf1)\n    .plot()\n)\n(\n    so.Plot(penguins, x=\"body_mass_g\")\n    .facet(row=\"sex\")\n    .add(so.Bars(), so.Hist())\n    .on(sf2)\n    .plot()\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Building and displaying the plot"
            },
            {
                "cell_type": "markdown",
                "nl_original": "An important thing to know is that  methods clone the object they are called on and return that clone instead of updating the object in place. This means that you can define a common plot spec and then produce several variations on it."
            },
            {
                "cell_type": "markdown",
                "nl_original": "So, take this basic specification:"
            },
            {
                "cell_type": "code",
                "code": "p = so.Plot(healthexp, \"Year\", \"Spending_USD\", color=\"Country\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "We could use it to draw a line plot:"
            },
            {
                "cell_type": "code",
                "code": "p.add(so.Line())\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Or perhaps a stacked area plot:"
            },
            {
                "cell_type": "code",
                "code": "p.add(so.Area(), so.Stack())\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  methods are fully declarative. Calling them updates the plot spec, but it doesn\u2019t actually do any plotting. One consequence of this is that methods can be called in any order, and many of them can be called multiple times."
            },
            {
                "cell_type": "markdown",
                "nl_original": "When does the plot actually get rendered?  is optimized for use in notebook environments. The rendering is automatically triggered when the  gets displayed in the Jupyter REPL. That\u2019s why we didn\u2019t see anything in the example above, where we defined a  but assigned it to p rather than letting it return out to the REPL."
            },
            {
                "cell_type": "markdown",
                "nl_original": "To see a plot in a notebook, either return it from the final line of a cell or call Jupyter\u2019s built-in display function on the object. The notebook integration bypasses  entirely, but you can use its figure-display machinery in other contexts by calling ."
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can also save the plot to a file (or buffer) by calling ."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Customizing the appearance"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The new interface aims to support a deep amount of customization through , reducing the need to switch gears and use matplotlib functionality directly. (But please be patient; not all of the features needed to achieve this goal have been implemented!)"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Parameterizing scales"
            },
            {
                "cell_type": "markdown",
                "nl_original": "All of the data-dependent properties are controlled by the concept of a  and the  method. This method accepts several different types of arguments. One possibility, which is closest to the use of scales in matplotlib, is to pass the name of a function that transforms the coordinates:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(diamonds, x=\"carat\", y=\"price\")\n    .add(so.Dots())\n    .scale(y=\"log\")\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": " can also control the mappings for semantic properties like color. You can directly pass it any argument that you would pass to the palette parameter in seaborn\u2019s function interface:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(diamonds, x=\"carat\", y=\"price\", color=\"clarity\")\n    .add(so.Dots())\n    .scale(color=\"flare\")\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Another option is to provide a tuple of (min, max) values, controlling the range that the scale should map into. This works both for numeric properties and for colors:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(diamonds, x=\"carat\", y=\"price\", color=\"clarity\", pointsize=\"carat\")\n    .add(so.Dots())\n    .scale(color=(\"#88c\", \"#555\"), pointsize=(2, 10))\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "For additional control, you can pass a  object. There are several different types of , each with appropriate parameters. For example,  lets you define the input domain (norm), the output range (values), and the function that maps between them (trans), while  allows you to specify an ordering:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(diamonds, x=\"carat\", y=\"price\", color=\"carat\", marker=\"cut\")\n    .add(so.Dots())\n    .scale(\n        color=so.Continuous(\"crest\", norm=(0, 3), trans=\"sqrt\"),\n        marker=so.Nominal([\"o\", \"+\", \"x\"], order=[\"Ideal\", \"Premium\", \"Good\"]),\n    )\n)\n"
            },
            {
                "cell_type": "code",
                "code": "/Users/mwaskom/code/seaborn/seaborn/_core/properties.py:370: RuntimeWarning: invalid value encountered in cast\n  ixs = np.asarray(x, np.intp)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Customizing legends and ticks"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  objects are also how you specify which values should appear as tick labels / in the legend, along with how they appear. For example, the  method lets you control the density or locations of the ticks, and the  method lets you modify the format:"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(diamonds, x=\"carat\", y=\"price\", color=\"carat\")\n    .add(so.Dots())\n    .scale(\n        x=so.Continuous().tick(every=0.5),\n        y=so.Continuous().label(like=\"${x:.0f}\"),\n        color=so.Continuous().tick(at=[1, 2, 3, 4]),\n    )\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Customizing limits, labels, and titles"
            },
            {
                "cell_type": "markdown",
                "nl_original": " has a number of methods for simple customization, including , , and :"
            },
            {
                "cell_type": "code",
                "code": "(\n    so.Plot(penguins, x=\"body_mass_g\", y=\"species\", color=\"island\")\n    .facet(col=\"sex\")\n    .add(so.Dot(), so.Jitter(.5))\n    .share(x=False)\n    .limit(y=(2.5, -.5))\n    .label(\n        x=\"Body mass (g)\", y=\"\",\n        color=str.capitalize,\n        title=\"{} penguins\".format,\n    )\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Theme customization"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Finally,  supports data-independent theming through the  method. Currently, this method accepts a dictionary of matplotlib rc parameters. You can set them directly and/or pass a package of parameters from seaborn\u2019s theming functions:"
            },
            {
                "cell_type": "code",
                "code": "from seaborn import axes_style\nso.Plot().theme({**axes_style(\"whitegrid\"), \"grid.linestyle\": \":\"})\n"
            }
        ],
        "Other properties": [
            {
                "cell_type": "markdown",
                "nl_original": "# Properties of Mark objects"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Coordinate properties"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### x, y, xmin, xmax, ymin, ymax"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Coordinate properties determine where a mark is drawn on a plot. Canonically, the x coordinate is the horizontal positon and the y coordinate is the vertical position. Some marks accept a span (i.e., min, max) parameterization for one or both variables. Others may accept x and y but also use a baseline parameter to show a span. The layer\u2019s orient parameter determines how this works."
            },
            {
                "cell_type": "markdown",
                "nl_original": "If a variable does not contain numeric data, its scale will apply a conversion so that data can be drawn on a screen. For instance, Nominal scales assign an integer index to each distinct category, and Temporal scales represent dates as the number of days from a reference \u201cepoch\u201d:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A Continuous scale can also apply a nonlinear transform between data values and spatial positions:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Color properties"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### color, fillcolor, edgecolor"
            },
            {
                "cell_type": "markdown",
                "nl_original": "All marks can be given a color, and many distinguish between the color of the mark\u2019s \u201cedge\u201d and \u201cfill\u201d. Often, simply using color will set both, while the more-specific properties allow further control:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When the color property is mapped, the default palette depends on the type of scale. Nominal scales use discrete, unordered hues, while continuous scales (including temporal ones) use a sequential gradient:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The default continuous scale is subject to change in future releases to improve discriminability."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Color scales are parameterized by the name of a palette, such as 'viridis', 'rocket', or 'deep'. Some palette names can include parameters, including simple gradients (e.g. 'dark:blue') or the cubehelix system (e.g. 'ch:start=.2,rot=-.4`). See the  for guidance on making an appropriate selection."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Continuous scales can also be parameterized by a tuple of colors that the scale should interpolate between. When using a nominal scale, it is possible to provide either the name of the palette (which will be discretely-sampled, if necessary), a list of individual color values, or a dictionary directly mapping data values to colors."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Individual colors may be specified . These include indexed references to the current color cycle ('C0'), single-letter shorthands ('b'), grayscale values ('.4'), RGB hex codes ('#4c72b0'), X11 color names ('seagreen'), and XKCD color survey names ('purpleish'):"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### alpha, fillalpha, edgealpha"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The alpha property determines the mark\u2019s opacity. Lowering the alpha can be helpful for representing density in the case of overplotting:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Mapping the alpha property can also be useful even when marks do not overlap because it conveys a sense of importance and can be combined with a color scale to represent two variables. Moreover, colors with lower alpha appear less saturated, which can improve the appearance of larger filled marks (such as bars)."
            },
            {
                "cell_type": "markdown",
                "nl_original": "As with color, some marks define separate edgealpha and fillalpha properties for additional control."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Style properties"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### fill"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The fill property is relevant to marks with a distinction between the edge and interior and determines whether the interior is visible. It is a boolean state: fill can be set only to True or False:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### marker"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The marker property is relevant for dot marks and some line marks. The API for specifying markers is very flexible, as detailed in the matplotlib API docs: ."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Markers can be specified using a number of simple string codes:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "They can also be programatically generated using a (num_sides, fill_style, angle) tuple:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "See the matplotlib docs for additional formats, including mathtex character codes ('$...$') and arrays of vertices."
            },
            {
                "cell_type": "markdown",
                "nl_original": "A marker property is always mapped with a nominal scale; there is no inherent ordering to the different shapes. If no scale is provided, the plot will programmatically generate a suitably large set of unique markers:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "While this ensures that the shapes are technically distinct, bear in mind that \u2014 in most cases \u2014\u00a0it will be difficult to tell the markers apart if more than a handful are used in a single plot."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The default marker scale is subject to change in future releases to improve discriminability."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### linestyle, edgestyle"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The linestyle property is relevant to line marks, and the edgestyle propety is relevant to a number of marks with \u201cedges. Both properties determine the \u201cdashing\u201d of a line in terms of on-off segments."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Dashes can be specified with a small number of shorthand codes ('-', '--', '-.', and ':') or programatically using (on, off, ...) tuples. In the tuple specification, the unit is equal to the linewidth:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Size properties"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### pointsize"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The pointsize property is relevant to dot marks and to line marks that can show markers at individual data points. The units correspond to the diameter of the mark in points."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The pointsize scales with the square root of the data by default so that magnitude is represented by diameter rather than area:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### linewidth"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The linewidth property is relevant to line marks and determines their thickness. The value should be non-negative and has point units:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### edgewidth"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The edgewidth property is akin to linewidth but applies to marks with an edge/fill rather than to lines. It also has a different default range when used in a scale. The units are the same:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### stroke"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The stroke property is akin to edgewidth but applies when a dot mark is defined by its stroke rather than its fill. It also has a slightly different default scale range, but otherwise behaves similarly:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Text properties"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### halign, valign"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The halign and valign properties control the <em>horizontal</em> and <em>vertical</em> alignment of text marks. The options for horizontal alignment are 'left', 'right', and 'center', while the options for vertical alignment are 'top', 'bottom', 'center', 'baseline', and 'center_baseline'."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### fontsize"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The fontsize property controls the size of textual marks. The value has point units:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### offset"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The offset property controls the spacing between a text mark and its anchor position. It applies when <em>not</em> using center alignment (i.e., when using left/right or top/bottom). The value has point units."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Other properties"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### text"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The text property is used to set the content of a textual mark. It is always used literally (not mapped), and cast to string when necessary."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### group"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The group property is special in that it does not change anything about the mark\u2019s appearance but defines additional data subsets that transforms should operate on independently."
            }
        ]
    },
    "Plotting functions": {
        "Showing multiple relationships with facets": [
            {
                "cell_type": "markdown",
                "nl_original": "# Visualizing statistical relationships"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Statistical analysis is a process of understanding how variables in a dataset relate to each other and how those relationships depend on other variables. Visualization can be a core component of this process because, when data are visualized properly, the human visual system can see trends and patterns that indicate a relationship."
            },
            {
                "cell_type": "markdown",
                "nl_original": "We will discuss three seaborn functions in this tutorial. The one we will use most is . This is a  for visualizing statistical relationships using two common approaches: scatter plots and line plots.  combines a  with one of two axes-level functions:"
            },
            {
                "cell_type": "markdown",
                "nl_original": " (with kind=\"scatter\"; the default)"
            },
            {
                "cell_type": "markdown",
                "nl_original": " (with kind=\"line\")"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As we will see, these functions can be quite illuminating because they use simple and easily-understood representations of data that can nevertheless represent complex dataset structures. They can do so because they plot two-dimensional graphics that can be enhanced by mapping up to three additional variables using the semantics of hue, size, and style."
            },
            {
                "cell_type": "code",
                "code": "import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_theme(style=\"darkgrid\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Relating variables with scatter plots"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The scatter plot is a mainstay of statistical visualization. It depicts the joint distribution of two variables using a cloud of points, where each point represents an observation in the dataset. This depiction allows the eye to infer a substantial amount of information about whether there is any meaningful relationship between them."
            },
            {
                "cell_type": "markdown",
                "nl_original": "There are several ways to draw a scatter plot in seaborn. The most basic, which should be used when both variables are numeric, is the  function. In the , we will see specialized tools for using scatterplots to visualize categorical data. The  is the default kind in  (it can also be forced by setting kind=\"scatter\"):"
            },
            {
                "cell_type": "code",
                "code": "tips = sns.load_dataset(\"tips\")\nsns.relplot(data=tips, x=\"total_bill\", y=\"tip\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "While the points are plotted in two dimensions, another dimension can be added to the plot by coloring the points according to a third variable. In seaborn, this is referred to as using a \u201chue semantic\u201d, because the color of the point gains meaning:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(data=tips, x=\"total_bill\", y=\"tip\", hue=\"smoker\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "To emphasize the difference between the classes, and to improve accessibility, you can use a different marker style for each class:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=tips,\n    x=\"total_bill\", y=\"tip\", hue=\"smoker\", style=\"smoker\"\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s also possible to represent four variables by changing the hue and style of each point independently. But this should be done carefully, because the eye is much less sensitive to shape than to color:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=tips,\n    x=\"total_bill\", y=\"tip\", hue=\"smoker\", style=\"time\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In the examples above, the hue semantic was categorical, so the default  was applied. If the hue semantic is numeric (specifically, if it can be cast to float), the default coloring switches to a sequential palette:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=tips, x=\"total_bill\", y=\"tip\", hue=\"size\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In both cases, you can customize the color palette. There are many options for doing so. Here, we customize a sequential palette using the string interface to :"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=tips,\n    x=\"total_bill\", y=\"tip\",\n    hue=\"size\", palette=\"ch:r=-.5,l=.75\"\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The third kind of semantic variable changes the size of each point:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(data=tips, x=\"total_bill\", y=\"tip\", size=\"size\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Unlike with , the literal value of the variable is not used to pick the area of the point. Instead, the range of values in data units is normalized into a range in area units. This range can be customized:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=tips, x=\"total_bill\", y=\"tip\",\n    size=\"size\", sizes=(15, 200)\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "More examples for customizing how the different semantics are used to show statistical relationships are shown in the  API examples."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Emphasizing continuity with line plots"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Scatter plots are highly effective, but there is no universally optimal type of visualisation. Instead, the visual representation should be adapted for the specifics of the dataset and to the question you are trying to answer with the plot."
            },
            {
                "cell_type": "markdown",
                "nl_original": "With some datasets, you may want to understand changes in one variable as a function of time, or a similarly continuous variable. In this situation, a good choice is to draw a line plot. In seaborn, this can be accomplished by the  function, either directly or with  by setting kind=\"line\":"
            },
            {
                "cell_type": "code",
                "code": "dowjones = sns.load_dataset(\"dowjones\")\nsns.relplot(data=dowjones, x=\"Date\", y=\"Price\", kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Aggregation and representing uncertainty"
            },
            {
                "cell_type": "markdown",
                "nl_original": "More complex datasets will have multiple measurements for the same value of the x variable. The default behavior in seaborn is to aggregate the multiple measurements at each x value by plotting the mean and the 95% confidence interval around the mean:"
            },
            {
                "cell_type": "code",
                "code": "fmri = sns.load_dataset(\"fmri\")\nsns.relplot(data=fmri, x=\"timepoint\", y=\"signal\", kind=\"line\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The confidence intervals are computed using bootstrapping, which can be time-intensive for larger datasets. It\u2019s therefore possible to disable them:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri, kind=\"line\",\n    x=\"timepoint\", y=\"signal\", errorbar=None,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Another good option, especially with larger data, is to represent the spread of the distribution at each timepoint by plotting the standard deviation instead of a confidence interval:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri, kind=\"line\",\n    x=\"timepoint\", y=\"signal\", errorbar=\"sd\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "To turn off aggregation altogether, set the estimator parameter to None This might produce a strange effect when the data have multiple observations at each point."
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri, kind=\"line\",\n    x=\"timepoint\", y=\"signal\",\n    estimator=None,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Plotting subsets of data with semantic mappings"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  function has the same flexibility as : it can show up to three additional variables by modifying the hue, size, and style of the plot elements. It does so using the same API as , meaning that we don\u2019t need to stop and think about the parameters that control the look of lines vs. points in matplotlib."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Using semantics in  will also determine how the data get aggregated. For example, adding a hue semantic with two levels splits the plot into two lines and error bands, coloring each to indicate which subset of the data they correspond to."
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri, kind=\"line\",\n    x=\"timepoint\", y=\"signal\", hue=\"event\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Adding a style semantic to a line plot changes the pattern of dashes in the line by default:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri, kind=\"line\",\n    x=\"timepoint\", y=\"signal\",\n    hue=\"region\", style=\"event\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "But you can identify subsets by the markers used at each observation, either together with the dashes or instead of them:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri, kind=\"line\",\n    x=\"timepoint\", y=\"signal\", hue=\"region\", style=\"event\",\n    dashes=False, markers=True,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As with scatter plots, be cautious about making line plots using multiple semantics. While sometimes informative, they can also be difficult to parse and interpret. But even when you are only examining changes across one additional variable, it can be useful to alter both the color and style of the lines. This can make the plot more accessible when printed to black-and-white or viewed by someone with color blindness:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri, kind=\"line\",\n    x=\"timepoint\", y=\"signal\", hue=\"event\", style=\"event\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When you are working with repeated measures data (that is, you have units that were sampled multiple times), you can also plot each sampling unit separately without distinguishing them through semantics. This avoids cluttering the legend:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri.query(\"event == 'stim'\"), kind=\"line\",\n    x=\"timepoint\", y=\"signal\", hue=\"region\",\n    units=\"subject\", estimator=None,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The default colormap and handling of the legend in  also depends on whether the hue semantic is categorical or numeric:"
            },
            {
                "cell_type": "code",
                "code": "dots = sns.load_dataset(\"dots\").query(\"align == 'dots'\")\nsns.relplot(\n    data=dots, kind=\"line\",\n    x=\"time\", y=\"firing_rate\",\n    hue=\"coherence\", style=\"choice\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It may happen that, even though the hue variable is numeric, it is poorly represented by a linear color scale. That\u2019s the case here, where the levels of the hue variable are logarithmically scaled. You can provide specific color values for each line by passing a list or dictionary:"
            },
            {
                "cell_type": "code",
                "code": "palette = sns.cubehelix_palette(light=.8, n_colors=6)\nsns.relplot(\n    data=dots, kind=\"line\",\n    x=\"time\", y=\"firing_rate\",\n    hue=\"coherence\", style=\"choice\", palette=palette,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Or you can alter how the colormap is normalized:"
            },
            {
                "cell_type": "code",
                "code": "from matplotlib.colors import LogNorm\npalette = sns.cubehelix_palette(light=.7, n_colors=6)\nsns.relplot(\n    data=dots.query(\"coherence &gt; 0\"), kind=\"line\",\n    x=\"time\", y=\"firing_rate\",\n    hue=\"coherence\", style=\"choice\",\n    hue_norm=LogNorm(),\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The third semantic, size, changes the width of the lines:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=dots, kind=\"line\",\n    x=\"time\", y=\"firing_rate\",\n    size=\"coherence\", style=\"choice\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "While the size variable will typically be numeric, it\u2019s also possible to map a categorical variable with the width of the lines. Be cautious when doing so, because it will be difficult to distinguish much more than \u201cthick\u201d vs \u201cthin\u201d lines. However, dashes can be hard to perceive when lines have high-frequency variability, so using different widths may be more effective in that case:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=dots, kind=\"line\",\n    x=\"time\", y=\"firing_rate\",\n    hue=\"coherence\", size=\"choice\", palette=palette,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Controlling sorting and orientation"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Because  assumes that you are most often trying to draw y as a function of x, the default behavior is to sort the data by the x values before plotting. However, this can be disabled:"
            },
            {
                "cell_type": "code",
                "code": "healthexp = sns.load_dataset(\"healthexp\").sort_values(\"Year\")\nsns.relplot(\n    data=healthexp, kind=\"line\",\n    x=\"Spending_USD\", y=\"Life_Expectancy\", hue=\"Country\",\n    sort=False\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s also possible to sort (and aggregate) along the y axis:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri, kind=\"line\",\n     x=\"signal\", y=\"timepoint\", hue=\"event\",\n    orient=\"y\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Showing multiple relationships with facets"
            },
            {
                "cell_type": "markdown",
                "nl_original": "We\u2019ve emphasized in this tutorial that, while these functions <em>can</em> show several semantic variables at once, it\u2019s not always effective to do so. But what about when you do want to understand how a relationship between two variables depends on more than one other variable?"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The best approach may be to make more than one plot. Because  is based on the , this is easy to do. To show the influence of an additional variable, instead of assigning it to one of the semantic roles in the plot, use it to \u201cfacet\u201d the visualization. This means that you make multiple axes and plot subsets of the data on each of them:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=tips,\n    x=\"total_bill\", y=\"tip\", hue=\"smoker\", col=\"time\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can also show the influence of two variables this way: one by faceting on the columns and one by faceting on the rows. As you start adding more variables to the grid, you may want to decrease the figure size. Remember that the size  is parameterized by the height and aspect ratio of <em>each facet</em>:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri, kind=\"line\",\n    x=\"timepoint\", y=\"signal\", hue=\"subject\",\n    col=\"region\", row=\"event\", height=3,\n    estimator=None\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When you want to examine effects across many levels of a variable, it can be a good idea to facet that variable on the columns and then \u201cwrap\u201d the facets into the rows:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(\n    data=fmri.query(\"region == 'frontal'\"), kind=\"line\",\n    x=\"timepoint\", y=\"signal\", hue=\"event\", style=\"event\",\n    col=\"subject\", col_wrap=5,\n    height=3, aspect=.75, linewidth=2.5,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "These visualizations, which are sometimes called \u201clattice\u201d plots or \u201csmall-multiples\u201d, are very effective because they present the data in a format that makes it easy for the eye to detect both overall patterns and deviations from those patterns. While you should make use of the flexibility afforded by  and , always try to keep in mind that several simple plots are usually more effective than one complex plot."
            }
        ],
        "Distribution visualization in other settings": [
            {
                "cell_type": "markdown",
                "nl_original": "# Visualizing distributions of data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "An early step in any effort to analyze or model data should be to understand how the variables are distributed. Techniques for distribution visualization can provide quick answers to many important questions. What range do the observations cover? What is their central tendency? Are they heavily skewed in one direction? Is there evidence for bimodality? Are there significant outliers? Do the answers to these questions vary across subsets defined by other variables?"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  contains several functions designed to answer questions such as these. The axes-level functions are , , , and . They are grouped together within the figure-level , , and  functions."
            },
            {
                "cell_type": "markdown",
                "nl_original": "There are several different approaches to visualizing a distribution, and each has its relative advantages and drawbacks. It is important to understand these factors so that you can choose the best approach for your particular aim."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Plotting univariate histograms"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Perhaps the most common approach to visualizing a distribution is the <em>histogram</em>. This is the default approach in , which uses the same underlying code as . A histogram is a bar plot where the axis representing the data variable is divided into a set of discrete bins and the count of observations falling within each bin is shown using the height of the corresponding bar:"
            },
            {
                "cell_type": "code",
                "code": "penguins = sns.load_dataset(\"penguins\")\nsns.displot(penguins, x=\"flipper_length_mm\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This plot immediately affords a few insights about the flipper_length_mm variable. For instance, we can see that the most common flipper length is about 195 mm, but the distribution appears bimodal, so this one number does not represent the data well."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Choosing the bin size"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The size of the bins is an important parameter, and using the wrong bin size can mislead by obscuring important features of the data or by creating apparent features out of random variability. By default, / choose a default bin size based on the variance of the data and the number of observations. But you should not be over-reliant on such automatic approaches, because they depend on particular assumptions about the structure of your data. It is always advisable to check that your impressions of the distribution are consistent across different bin sizes. To choose the size directly, set the binwidth parameter:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", binwidth=3)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In other circumstances, it may make more sense to specify the <em>number</em> of bins, rather than their size:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", bins=20)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "One example of a situation where defaults fail is when the variable takes a relatively small number of integer values. In that case, the default bin width may be too small, creating awkward gaps in the distribution:"
            },
            {
                "cell_type": "code",
                "code": "tips = sns.load_dataset(\"tips\")\nsns.displot(tips, x=\"size\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "One approach would be to specify the precise bin breaks by passing an array to bins:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(tips, x=\"size\", bins=[1, 2, 3, 4, 5, 6, 7])\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This can also be accomplished by setting discrete=True, which chooses bin breaks that represent the unique values in a dataset with bars that are centered on their corresponding value."
            },
            {
                "cell_type": "code",
                "code": "sns.displot(tips, x=\"size\", discrete=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s also possible to visualize the distribution of a categorical variable using the logic of a histogram. Discrete bins are automatically set for categorical variables, but it may also be helpful to \u201cshrink\u201d the bars slightly to emphasize the categorical nature of the axis:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(tips, x=\"day\", shrink=.8)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Conditioning on other variables"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Once you understand the distribution of a variable, the next step is often to ask whether features of that distribution differ across other variables in the dataset. For example, what accounts for the bimodal distribution of flipper lengths that we saw above?  and  provide support for conditional subsetting via the hue semantic. Assigning a variable to hue will draw a separate histogram for each of its unique values and distinguish them by color:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"species\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "By default, the different histograms are \u201clayered\u201d on top of each other and, in some cases, they may be difficult to distinguish. One option is to change the visual representation of the histogram from a bar plot to a \u201cstep\u201d plot:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"species\", element=\"step\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Alternatively, instead of layering each bar, they can be \u201cstacked\u201d, or moved vertically. In this plot, the outline of the full histogram will match the plot with only a single variable:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"species\", multiple=\"stack\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The stacked histogram emphasizes the part-whole relationship between the variables, but it can obscure other features (for example, it is difficult to determine the mode of the Adelie distribution. Another option is \u201cdodge\u201d the bars, which moves them horizontally and reduces their width. This ensures that there are no overlaps and that the bars remain comparable in terms of height. But it only works well when the categorical variable has a small number of levels:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"sex\", multiple=\"dodge\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Because  is a figure-level function and is drawn onto a , it is also possible to draw each individual distribution in a separate subplot by assigning the second variable to col or row rather than (or in addition to) hue. This represents the distribution of each subset well, but it makes it more difficult to draw direct comparisons:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", col=\"sex\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "None of these approaches are perfect, and  we will soon see some alternatives to a histogram that are better-suited to the task of comparison."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Normalized histogram statistics"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Before we do, another point to note is that, when the subsets have unequal numbers of observations, comparing their distributions in terms of counts may not be ideal. One solution is to <em>normalize</em> the counts using the stat parameter:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"species\", stat=\"density\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "By default, however, the normalization is applied to the entire distribution, so this simply rescales the height of the bars. By setting common_norm=False, each subset will be normalized independently:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"species\", stat=\"density\", common_norm=False)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Density normalization scales the bars so that their <em>areas</em> sum to 1. As a result, the density axis is not directly interpretable. Another option is to normalize the bars to that their <em>heights</em> sum to 1. This makes most sense when the variable is discrete, but  it is an option for all histograms:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"species\", stat=\"probability\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Kernel density estimation"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A histogram aims to approximate the underlying probability density function that generated the data by binning and counting observations. Kernel density estimation (KDE) presents a different solution to the same problem. Rather than using discrete bins, a KDE plot smooths the observations with a Gaussian kernel, producing a continuous density estimate:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", kind=\"kde\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Choosing the smoothing bandwidth"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Much like with the bin size in the histogram, the ability of the KDE to accurately represent the data depends on the choice of smoothing bandwidth. An over-smoothed estimate might erase meaningful features, but an under-smoothed estimate can obscure the true shape within random noise. The easiest way to check the robustness of the estimate is to adjust the default bandwidth:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", kind=\"kde\", bw_adjust=.25)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note how the narrow bandwidth makes the bimodality much more apparent, but the curve is much less smooth. In contrast, a larger bandwidth obscures the bimodality almost completely:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", kind=\"kde\", bw_adjust=2)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Conditioning on other variables"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As with histograms, if you assign a hue variable, a separate density estimate will be computed for each level of that variable:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"species\", kind=\"kde\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In many cases, the layered KDE is easier to interpret than the layered histogram, so it is often a good choice for the task of comparison. Many of the same options for resolving multiple distributions apply to the KDE as well, however:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"species\", kind=\"kde\", multiple=\"stack\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note how the stacked plot filled in the area between each curve by default. It is also possible to fill in the curves for single or layered densities, although the default alpha value (opacity) will be different, so that the individual densities are easier to resolve."
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"species\", kind=\"kde\", fill=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Kernel density estimation pitfalls"
            },
            {
                "cell_type": "markdown",
                "nl_original": "KDE plots have many advantages. Important features of the data are easy to discern (central tendency, bimodality, skew), and they afford easy comparisons between subsets. But there are also situations where KDE poorly represents the underlying data. This is because the logic of KDE assumes that the underlying distribution is smooth and unbounded. One way this assumption can fail is when a variable reflects a quantity that is naturally bounded. If there are observations lying close to the bound (for example, small values of a variable that cannot be negative), the KDE curve may extend to unrealistic values:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(tips, x=\"total_bill\", kind=\"kde\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This can be partially avoided with the cut parameter, which specifies how far the curve should extend beyond the extreme datapoints. But this influences only where the curve is drawn; the density estimate will still smooth over the range where no data can exist, causing it to be artificially low at the extremes of the distribution:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(tips, x=\"total_bill\", kind=\"kde\", cut=0)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The KDE approach also fails for discrete data or when data are naturally continuous but specific values are over-represented. The important thing to keep in mind is that the KDE will <em>always show you a smooth curve</em>, even when the data themselves are not smooth. For example, consider this distribution of diamond weights:"
            },
            {
                "cell_type": "code",
                "code": "diamonds = sns.load_dataset(\"diamonds\")\nsns.displot(diamonds, x=\"carat\", kind=\"kde\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "While the KDE suggests that there are peaks around specific values, the histogram reveals a much more jagged distribution:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(diamonds, x=\"carat\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As a compromise, it is possible to combine these two approaches. While in histogram mode,  (as with ) has the option of including the smoothed KDE curve (note kde=True, not kind=\"kde\"):"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(diamonds, x=\"carat\", kde=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Empirical cumulative distributions"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A third option for visualizing distributions computes the \u201cempirical cumulative distribution function\u201d (ECDF). This plot draws a monotonically-increasing curve through each datapoint such that the height of the curve reflects the proportion of observations with a smaller value:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", kind=\"ecdf\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The ECDF plot has two key advantages. Unlike the histogram or KDE, it directly represents each datapoint. That means there is no bin size or smoothing parameter to consider. Additionally, because the curve is monotonically increasing, it is well-suited for comparing multiple distributions:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"flipper_length_mm\", hue=\"species\", kind=\"ecdf\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The major downside to the ECDF plot is that it represents the shape of the distribution less intuitively than a histogram or density curve. Consider how the bimodality of flipper lengths is immediately apparent in the histogram, but to see it in the ECDF plot, you must look for varying slopes. Nevertheless, with practice, you can learn to answer all of the important questions about a distribution by examining the ECDF, and doing so can be a powerful approach."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Visualizing bivariate distributions"
            },
            {
                "cell_type": "markdown",
                "nl_original": "All of the examples so far have considered <em>univariate</em> distributions: distributions of a single variable, perhaps conditional on a second variable assigned to hue. Assigning a second variable to y, however, will plot a <em>bivariate</em> distribution:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A bivariate histogram bins the data within rectangles that tile the plot and then shows the count of observations within each rectangle with the fill color (analogous to a ). Similarly, a bivariate KDE plot smoothes the (x, y) observations with a 2D Gaussian. The default representation then shows the <em>contours</em> of the 2D density:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\", kind=\"kde\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Assigning a hue variable will plot multiple heatmaps or contour sets using different colors. For bivariate histograms, this will only work well if there is minimal overlap between the conditional distributions:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\", hue=\"species\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The contour approach of the bivariate KDE plot lends itself better to evaluating overlap, although a plot with too many contours can get busy:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\", hue=\"species\", kind=\"kde\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Just as with univariate plots, the choice of bin size or smoothing bandwidth will determine how well the plot represents the underlying bivariate distribution. The same parameters apply, but they can be tuned for each variable by passing a pair of values:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\", binwidth=(2, .5))\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "To aid interpretation of the heatmap, add a colorbar to show the mapping between counts and color intensity:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\", binwidth=(2, .5), cbar=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The meaning of the bivariate density contours is less straightforward. Because the density is not directly interpretable, the contours are drawn at <em>iso-proportions</em> of the density, meaning that each curve shows a level set such that some proportion <em>p</em> of the density lies below it. The <em>p</em> values are evenly spaced, with the lowest level contolled by the thresh parameter and the number controlled by levels:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\", kind=\"kde\", thresh=.2, levels=4)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The levels parameter also accepts a list of values, for more control:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\", kind=\"kde\", levels=[.01, .05, .1, .8])\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The bivariate histogram allows one or both variables to be discrete. Plotting one discrete and one continuous variable offers another way to compare conditional univariate distributions:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(diamonds, x=\"price\", y=\"clarity\", log_scale=(True, False))\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In contrast, plotting two discrete variables is an easy to way show the cross-tabulation of the observations:"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(diamonds, x=\"color\", y=\"clarity\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Distribution visualization in other settings"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Several other figure-level plotting functions in seaborn make use of the  and  functions."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Plotting joint and marginal distributions"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The first is , which augments a bivariate relatonal or distribution plot with the marginal distributions of the two variables. By default,  represents the bivariate distribution using  and the marginal distributions using :"
            },
            {
                "cell_type": "code",
                "code": "sns.jointplot(data=penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Similar to , setting a different kind=\"kde\" in  will change both the joint and marginal plots the use :"
            },
            {
                "cell_type": "code",
                "code": "sns.jointplot(\n    data=penguins,\n    x=\"bill_length_mm\", y=\"bill_depth_mm\", hue=\"species\",\n    kind=\"kde\"\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": " is a convenient interface to the  class, which offeres more flexibility when used directly:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.JointGrid(data=penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\")\ng.plot_joint(sns.histplot)\ng.plot_marginals(sns.boxplot)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A less-obtrusive way to show marginal distributions uses a \u201crug\u201d plot, which adds a small tick on the edge of the plot to represent each individual observation. This is built into :"
            },
            {
                "cell_type": "code",
                "code": "sns.displot(\n    penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\",\n    kind=\"kde\", rug=True\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "And the axes-level  function can be used to add rugs on the side of any other kind of plot:"
            },
            {
                "cell_type": "code",
                "code": "sns.relplot(data=penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\")\nsns.rugplot(data=penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Plotting many distributions"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  function offers a similar blend of joint and marginal distributions. Rather than focusing on a single relationship, however,  uses a \u201csmall-multiple\u201d approach to visualize the univariate distribution of all variables in a dataset along with all of their pairwise relationships:"
            },
            {
                "cell_type": "code",
                "code": "sns.pairplot(penguins)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As with /, using the underlying  directly will afford more flexibility with only a bit more typing:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.PairGrid(penguins)\ng.map_upper(sns.histplot)\ng.map_lower(sns.kdeplot, fill=True)\ng.map_diag(sns.histplot, kde=True)\n"
            }
        ],
        "Showing additional dimensions": [
            {
                "cell_type": "markdown",
                "nl_original": "# Visualizing categorical data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In the  we saw how to use different visual representations to show the relationship between multiple variables in a dataset. In the examples, we focused on cases where the main relationship was between two numerical variables. If one of the main variables is \u201ccategorical\u201d (divided into discrete groups) it may be helpful to use a more specialized approach to visualization."
            },
            {
                "cell_type": "markdown",
                "nl_original": "In seaborn, there are several different ways to visualize a relationship involving categorical data. Similar to the relationship between  and either  or , there are two ways to make these plots. There are a number of axes-level functions for plotting categorical data in different ways and a figure-level interface, , that gives unified higher-level access to them."
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s helpful to think of the different categorical plot kinds as belonging to three different families, which we\u2019ll discuss in detail below. They are:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Categorical scatterplots:"
            },
            {
                "cell_type": "markdown",
                "nl_original": " (with kind=\"strip\"; the default)"
            },
            {
                "cell_type": "markdown",
                "nl_original": " (with kind=\"swarm\")"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Categorical distribution plots:"
            },
            {
                "cell_type": "markdown",
                "nl_original": " (with kind=\"box\")"
            },
            {
                "cell_type": "markdown",
                "nl_original": " (with kind=\"violin\")"
            },
            {
                "cell_type": "markdown",
                "nl_original": " (with kind=\"boxen\")"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Categorical estimate plots:"
            },
            {
                "cell_type": "markdown",
                "nl_original": " (with kind=\"point\")"
            },
            {
                "cell_type": "markdown",
                "nl_original": " (with kind=\"bar\")"
            },
            {
                "cell_type": "markdown",
                "nl_original": " (with kind=\"count\")"
            },
            {
                "cell_type": "markdown",
                "nl_original": "These families represent the data using different levels of granularity. When deciding which to use, you\u2019ll have to think about the question that you want to answer. The unified API makes it easy to switch between different kinds and see your data from several perspectives."
            },
            {
                "cell_type": "markdown",
                "nl_original": "In this tutorial, we\u2019ll mostly focus on the figure-level interface, . Remember that this function is a higher-level interface each of the functions above, so we\u2019ll reference them when we show each kind of plot, keeping the more verbose kind-specific API documentation at hand."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Categorical scatterplots"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The default representation of the data in  uses a scatterplot. There are actually two different categorical scatter plots in seaborn. They take different approaches to resolving the main challenge in representing categorical data with a scatter plot, which is that all of the points belonging to one category would fall on the same position along the axis corresponding to the categorical variable. The approach used by , which is the default \u201ckind\u201d in  is to adjust the positions of points on the categorical axis with a small amount of random \u201cjitter\u201d:"
            },
            {
                "cell_type": "code",
                "code": "tips = sns.load_dataset(\"tips\")\nsns.catplot(data=tips, x=\"day\", y=\"total_bill\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The jitter parameter controls the magnitude of jitter or disables it altogether:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=tips, x=\"day\", y=\"total_bill\", jitter=False)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The second approach adjusts the points along the categorical axis using an algorithm that prevents them from overlapping. It can give a better representation of the distribution of observations, although it only works well for relatively small datasets. This kind of plot is sometimes called a \u201cbeeswarm\u201d and is drawn in seaborn by , which is activated by setting kind=\"swarm\" in :"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=tips, x=\"day\", y=\"total_bill\", kind=\"swarm\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Similar to the relational plots, it\u2019s possible to add another dimension to a categorical plot by using a hue semantic. (The categorical plots do not currently support size or style semantics). Each different categorical plotting function handles the hue semantic differently. For the scatter plots, it is only necessary to change the color of the points:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=tips, x=\"day\", y=\"total_bill\", hue=\"sex\", kind=\"swarm\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Unlike with numerical data, it is not always obvious how to order the levels of the categorical variable along its axis. In general, the seaborn categorical plotting functions try to infer the order of categories from the data. If your data have a pandas Categorical datatype, then the default order of the categories can be set there. If the variable passed to the categorical axis looks numerical, the levels will be sorted. But the data are still treated as categorical and drawn at ordinal positions on the categorical axes (specifically, at 0, 1, \u2026) even when numbers are used to label them:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=tips.query(\"size != 3\"), x=\"size\", y=\"total_bill\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The other option for choosing a default ordering is to take the levels of the category as they appear in the dataset. The ordering can also be controlled on a plot-specific basis using the order parameter. This can be important when drawing multiple categorical plots in the same figure, which we\u2019ll see more of below:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=tips, x=\"smoker\", y=\"tip\", order=[\"No\", \"Yes\"])\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "We\u2019ve referred to the idea of \u201ccategorical axis\u201d. In these examples, that\u2019s always corresponded to the horizontal axis. But it\u2019s often helpful to put the categorical variable on the vertical axis (particularly when the category names are relatively long or there are many categories). To do this, swap the assignment of variables to axes:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=tips, x=\"total_bill\", y=\"day\", hue=\"time\", kind=\"swarm\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Comparing distributions"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As the size of the dataset grows, categorical scatter plots become limited in the information they can provide about the distribution of values within each category. When this happens, there are several approaches for summarizing the distributional information in ways that facilitate easy comparisons across the category levels."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Boxplots"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The first is the familiar . This kind of plot shows the three quartile values of the distribution along with extreme values. The \u201cwhiskers\u201d extend to points that lie within 1.5 IQRs of the lower and upper quartile, and then observations that fall outside this range are displayed independently. This means that each value in the boxplot corresponds to an actual observation in the data."
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=tips, x=\"day\", y=\"total_bill\", kind=\"box\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When adding a hue semantic, the box for each level of the semantic variable is moved along the categorical axis so they don\u2019t overlap:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=tips, x=\"day\", y=\"total_bill\", hue=\"smoker\", kind=\"box\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This behavior is called \u201cdodging\u201d and is turned on by default because it is assumed that the semantic variable is nested within the main categorical variable. If that\u2019s not the case, you can disable the dodging:"
            },
            {
                "cell_type": "code",
                "code": "tips[\"weekend\"] = tips[\"day\"].isin([\"Sat\", \"Sun\"])\nsns.catplot(\n    data=tips, x=\"day\", y=\"total_bill\", hue=\"weekend\",\n    kind=\"box\", dodge=False,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A related function, , draws a plot that is similar to a box plot but optimized for showing more information about the shape of the distribution. It is best suited for larger datasets:"
            },
            {
                "cell_type": "code",
                "code": "diamonds = sns.load_dataset(\"diamonds\")\nsns.catplot(\n    data=diamonds.sort_values(\"color\"),\n    x=\"color\", y=\"price\", kind=\"boxen\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Violinplots"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A different approach is a , which combines a boxplot with the kernel density estimation procedure described in the  tutorial:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(\n    data=tips, x=\"total_bill\", y=\"day\", hue=\"sex\", kind=\"violin\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This approach uses the kernel density estimate to provide a richer description of the distribution of values. Additionally, the quartile and whisker values from the boxplot are shown inside the violin. The downside is that, because the violinplot uses a KDE, there are some other parameters that may need tweaking, adding some complexity relative to the straightforward boxplot:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(\n    data=tips, x=\"total_bill\", y=\"day\", hue=\"sex\",\n    kind=\"violin\", bw=.15, cut=0,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s also possible to \u201csplit\u201d the violins when the hue parameter has only two levels, which can allow for a more efficient use of space:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(\n    data=tips, x=\"day\", y=\"total_bill\", hue=\"sex\",\n    kind=\"violin\", split=True,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Finally, there are several options for the plot that is drawn on the interior of the violins, including ways to show each individual observation instead of the summary boxplot values:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(\n    data=tips, x=\"day\", y=\"total_bill\", hue=\"sex\",\n    kind=\"violin\", inner=\"stick\", split=True, palette=\"pastel\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It can also be useful to combine  or  with a box plot or violin plot to show each observation along with a summary of the distribution:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.catplot(data=tips, x=\"day\", y=\"total_bill\", kind=\"violin\", inner=None)\nsns.swarmplot(data=tips, x=\"day\", y=\"total_bill\", color=\"k\", size=3, ax=g.ax)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Estimating central tendency"
            },
            {
                "cell_type": "markdown",
                "nl_original": "For other applications, rather than showing the distribution within each category, you might want to show an estimate of the central tendency of the values. Seaborn has two main ways to show this information. Importantly, the basic API for these functions is identical to that for the ones discussed above."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Bar plots"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A familiar style of plot that accomplishes this goal is a bar plot. In seaborn, the  function operates on a full dataset and applies a function to obtain the estimate (taking the mean by default). When there are multiple observations in each category, it also uses bootstrapping to compute a confidence interval around the estimate, which is plotted using error bars:"
            },
            {
                "cell_type": "code",
                "code": "titanic = sns.load_dataset(\"titanic\")\nsns.catplot(data=titanic, x=\"sex\", y=\"survived\", hue=\"class\", kind=\"bar\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The default error bars show 95% confidence intervals, but (starting in\nv0.12), it is possible to select from a number of other representations:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=titanic, x=\"age\", y=\"deck\", errorbar=(\"pi\", 95), kind=\"bar\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A special case for the bar plot is when you want to show the number of observations in each category rather than computing a statistic for a second variable. This is similar to a histogram over a categorical, rather than quantitative, variable. In seaborn, it\u2019s easy to do so with the  function:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=titanic, x=\"deck\", kind=\"count\", palette=\"ch:.25\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Both  and  can be invoked with all of the options discussed above, along with others that are demonstrated in the detailed documentation for each function:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(\n    data=titanic, y=\"deck\", hue=\"class\", kind=\"count\",\n    palette=\"pastel\", edgecolor=\".6\",\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Point plots"
            },
            {
                "cell_type": "markdown",
                "nl_original": "An alternative style for visualizing the same information is offered by the  function. This function also encodes the value of the estimate with height on the other axis, but rather than showing a full bar, it plots the point estimate and confidence interval. Additionally,  connects points from the same hue category. This makes it easy to see how the main relationship is changing as a function of the hue semantic, because your eyes are quite good at picking up on differences of slopes:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(data=titanic, x=\"sex\", y=\"survived\", hue=\"class\", kind=\"point\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "While the categorical functions lack the style semantic of the relational functions, it can still be a good idea to vary the marker and/or linestyle along with the hue to make figures that are maximally accessible and reproduce well in black and white:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(\n    data=titanic, x=\"class\", y=\"survived\", hue=\"sex\",\n    palette={\"male\": \"g\", \"female\": \"m\"},\n    markers=[\"^\", \"o\"], linestyles=[\"-\", \"--\"],\n    kind=\"point\"\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Showing additional dimensions"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Just like , the fact that  is built on a  means that it is easy to add faceting variables to visualize higher-dimensional relationships:"
            },
            {
                "cell_type": "code",
                "code": "sns.catplot(\n    data=tips, x=\"day\", y=\"total_bill\", hue=\"smoker\",\n    kind=\"swarm\", col=\"time\", aspect=.7,\n)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "For further customization of the plot, you can use the methods on the  object that it returns:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.catplot(\n    data=titanic,\n    x=\"fare\", y=\"embark_town\", row=\"class\",\n    kind=\"box\", orient=\"h\",\n    sharex=False, margin_titles=True,\n    height=1.5, aspect=4,\n)\ng.set(xlabel=\"Fare\", ylabel=\"\")\ng.set_titles(row_template=\"{row_name} class\")\nfor ax in g.axes.flat:\n    ax.xaxis.set_major_formatter('${x:.0f}')\n"
            }
        ]
    },
    "Statistical operations": {
        "Are error bars enough?": [
            {
                "cell_type": "markdown",
                "nl_original": "# Statistical estimation and error bars"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Data visualization sometimes involves a step of aggregation or estimation, where multiple data points are reduced to a summary statistic such as the mean or median. When showing a summary statistic, it is usually appropriate to add <em>error bars</em>, which provide a visual cue about how well the summary represents the underlying data points."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Several seaborn functions will automatically calculate both summary statistics and the error bars when given a full dataset. This chapter explains how you can control what the error bars show and why you might choose each of the options that seaborn affords."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The error bars around an estimate of central tendency can show one of two general things: either the range of uncertainty about the estimate or the spread of the underlying data around it. These measures are related: given the same sample size, estimates will be more uncertain when data has a broader spread. But uncertainty will decrease as sample sizes grow, whereas spread will not."
            },
            {
                "cell_type": "markdown",
                "nl_original": "In seaborn, there are two approaches for constructing each kind of error bar. One approach is parametric, using a formula that relies on assumptions about the shape of the distribution. The other approach is nonparametric, using only the data that you provide."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Your choice is made with the errorbar parameter, which exists for each function that does estimation as part of plotting. This parameter accepts the name of the method to use and, optionally, a parameter that controls the size of the interval. The choices can be defined in a 2D taxonomy that depends on what is shown and how it is constructed:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You will note that the size parameter is defined differently for the parametric and nonparametric approaches. For parametric error bars, it is a scalar factor that is multiplied by the statistic defining the error (standard error or standard deviation). For nonparametric error bars, it is a percentile width. This is explained further for each specific approach below."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The errorbar API described here was introduced in seaborn v0.12. In prior versions, the only options were to show a bootstrap confidence interval or a standard deviation, with the choice controlled by the ci parameter (i.e., ci=&lt;size&gt; or ci=\"sd\")."
            },
            {
                "cell_type": "markdown",
                "nl_original": "To compare the different parameterizations, we\u2019ll use the following helper function:"
            },
            {
                "cell_type": "code",
                "code": "def plot_errorbars(arg, **kws):\n    np.random.seed(sum(map(ord, \"error_bars\")))\n    x = np.random.normal(0, 1, 100)\n    f, axs = plt.subplots(2, figsize=(7, 2), sharex=True, layout=\"tight\")\n    sns.pointplot(x=x, errorbar=arg, **kws, capsize=.3, ax=axs[0])\n    sns.stripplot(x=x, jitter=.3, ax=axs[1])\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Measures of data spread"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Error bars that represent data spread present a compact display of the distribution, using three numbers where  would use 5 or more and  would use a complicated algorithm."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Standard deviation error bars"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Standard deviation error bars are the simplest to explain, because the standard deviation is a familiar statistic. It is the average distance from each data point to the sample mean. By default, errorbar=\"sd\" will draw error bars at +/- 1 sd around the estimate, but the range can be increased by passing a scaling size parameter. Note that, assuming normally-distributed data, ~68% of the data will lie within one standard deviation, ~95% will lie within two, and ~99.7% will lie within three:"
            },
            {
                "cell_type": "code",
                "code": "plot_errorbars(\"sd\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Percentile interval error bars"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Percentile intervals also represent the range where some amount of the data fall, but they do so by\ncomputing those percentiles directly from your sample. By default, errorbar=\"pi\" will show a 95% interval, ranging from the 2.5 to the 97.5 percentiles. You can choose a different range by passing a size parameter, e.g., to show the inter-quartile range:"
            },
            {
                "cell_type": "code",
                "code": "plot_errorbars((\"pi\", 50))\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The standard deviation error bars will always be symmetrical around the estimate. This can be a problem when the data are skewed, especially if there are natural bounds (e.g., if the data represent a quantity that can only be positive). In some cases, standard deviation error bars may extend to \u201cimpossible\u201d values. The nonparametric approach does not have this problem, because it can account for asymmetrical spread and will never extend beyond the range of the data."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Measures of estimate uncertainty"
            },
            {
                "cell_type": "markdown",
                "nl_original": "If your data are a random sample from a larger population, then the mean (or other estimate) will be an imperfect measure of the true population average. Error bars that show estimate uncertainty try to represent the range of likely values for the true parameter."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Standard error bars"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The standard error statistic is related to the standard deviation: in fact it is just the standard deviation divided by the square root of the sample size. The default, with errorbar=\"se\", draws an interval +/-1 standard error from the mean:"
            },
            {
                "cell_type": "code",
                "code": "plot_errorbars(\"se\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Confidence interval error bars"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The nonparametric approach to representing uncertainty uses <em>bootstrapping</em>: a procedure where the dataset is randomly resampled with replacement a number of times, and the estimate is recalculated from each resample. This procedure creates a distribution of statistics approximating the distribution of values that you could have gotten for your estimate if you had a different sample."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The confidence interval is constructed by taking a percentile interval of the <em>bootstrap distribution</em>. By default errorbar=\"ci\" draws a 95% confidence interval:"
            },
            {
                "cell_type": "code",
                "code": "plot_errorbars(\"ci\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The seaborn terminology is somewhat specific, because a confidence interval in statistics can be parametric or nonparametric. To draw a parametric confidence interval, you scale the standard error, using a formula similar to the one mentioned above. For example, an approximate 95% confidence interval can be constructed by taking the mean +/- two standard errors:"
            },
            {
                "cell_type": "code",
                "code": "plot_errorbars((\"se\", 2))\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The nonparametric bootstrap has advantages similar to those of the percentile interval: it will naturally adapt to skewed and bounded data in a way that a standard error interval cannot. It is also more general. While the standard error formula is specific to the mean, error bars can be computed using the bootstrap for any estimator:"
            },
            {
                "cell_type": "code",
                "code": "plot_errorbars(\"ci\", estimator=\"median\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Bootstrapping involves randomness, and the error bars will appear slightly different each time you run the code that creates them. A few parameters control this. One sets the number of iterations (n_boot): with more iterations, the resulting intervals will be more stable. The other sets the seed for the random number generator, which will ensure identical results:"
            },
            {
                "cell_type": "code",
                "code": "plot_errorbars(\"ci\", n_boot=5000, seed=10)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Because of its iterative process, bootstrap intervals can be expensive to compute, especially for large datasets. But because uncertainty decreases with sample size, it may be more informative in that case to use an error bar that represents data spread."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Custom error bars"
            },
            {
                "cell_type": "markdown",
                "nl_original": "If these recipes are not sufficient, it is also possible to pass a generic function to the errorbar parameter. This function should take a vector and produce a pair of values representing the minimum and maximum points of the interval:"
            },
            {
                "cell_type": "code",
                "code": "plot_errorbars(lambda x: (x.min(), x.max()))\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "(In practice, you could show the full range of the data with errorbar=(\"pi\", 100) rather than the custom function shown above)."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note that seaborn functions cannot currently draw error bars from values that have been calculated externally, although matplotlib functions can be used to add such error bars to seaborn plots."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Error bars on regression fits"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The preceding discussion has focused on error bars shown around parameter estimates for aggregate data. Error bars also arise in seaborn when estimating regression models to visualize relationships. Here, the error bars will be represented by a \u201cband\u201d around the regression line:"
            },
            {
                "cell_type": "code",
                "code": "x = np.random.normal(0, 1, 50)\ny = x * 2 + np.random.normal(0, 2, size=x.size)\nsns.regplot(x=x, y=y)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Currently, the error bars on a regression estimate are less flexible, only showing a confidence interval with a size set through ci=. This may change in the future."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Are error bars enough?"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You should always ask yourself whether it\u2019s best to use a plot that displays only a summary statistic and error bar. In many cases, it isn\u2019t."
            },
            {
                "cell_type": "markdown",
                "nl_original": "If you are interested in questions about summaries (such as whether the mean value differs between groups or increases over time), aggregation reduces the complexity of the plot and makes those inferences easier. But in doing so, it obscures valuable information about the underlying data points, such as the shape of the distributions and the presence of outliers."
            },
            {
                "cell_type": "markdown",
                "nl_original": "When analyzing your own data, don\u2019t be satisfied with summary statistics. Always look at the underlying distributions too. Sometimes, it can be helpful to combine both perspectives into the same figure. Many seaborn functions can help with this task, especially those discussed in the ."
            }
        ],
        "Plotting a regression in other contexts": [
            {
                "cell_type": "markdown",
                "nl_original": "# Estimating regression fits"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Many datasets contain multiple quantitative variables, and the goal of an analysis is often to relate those variables to each other. We  functions that can accomplish this by showing the joint distribution of two variables. It can be very helpful, though, to use statistical models to estimate a simple relationship between two noisy sets of observations. The functions discussed in this chapter will do so through the common framework of linear regression."
            },
            {
                "cell_type": "markdown",
                "nl_original": "In the spirit of Tukey, the regression plots in seaborn are primarily intended to add a visual guide that helps to emphasize patterns in a dataset during exploratory data analyses. That is to say that seaborn is not itself a package for statistical analysis. To obtain quantitative measures related to the fit of regression models, you should use . The goal of seaborn, however, is to make exploring a dataset through visualization quick and easy, as doing so is just as (if not more) important than exploring a dataset through tables of statistics."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Functions for drawing linear regression models"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The two functions that can be used to visualize a linear fit are  and ."
            },
            {
                "cell_type": "markdown",
                "nl_original": "In the simplest invocation, both functions draw a scatterplot of two variables, x and y, and then fit the regression model y ~ x and plot the resulting regression line and a 95% confidence interval for that regression:"
            },
            {
                "cell_type": "code",
                "code": "tips = sns.load_dataset(\"tips\")\nsns.regplot(x=\"total_bill\", y=\"tip\", data=tips);\n"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"total_bill\", y=\"tip\", data=tips);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "These functions draw similar plots, but  is an , and  is a figure-level function. Additionally,  accepts the x and y variables in a variety of formats including simple numpy arrays,  objects, or as references to variables in a  object passed to data. In contrast,  has data as a required parameter and the x and y variables must be specified as strings. Finally, only  has hue as a parameter."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The core functionality is otherwise similar, though, so this tutorial will focus on :."
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s possible to fit a linear regression when one of the variables takes discrete values, however, the simple scatterplot produced by this kind of dataset is often not optimal:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"size\", y=\"tip\", data=tips);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "One option is to add some random noise (\u201cjitter\u201d) to the discrete values to make the distribution of those values more clear. Note that jitter is applied only to the scatterplot data and does not influence the regression line fit itself:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"size\", y=\"tip\", data=tips, x_jitter=.05);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A second option is to collapse over the observations in each discrete bin to plot an estimate of central tendency along with a confidence interval:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"size\", y=\"tip\", data=tips, x_estimator=np.mean);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Fitting different kinds of models"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The simple linear regression model used above is very simple to fit, however, it is not appropriate for some kinds of datasets. The  dataset shows a few examples where simple linear regression provides an identical estimate of a relationship where simple visual inspection clearly shows differences. For example, in the first case, the linear regression is a good model:"
            },
            {
                "cell_type": "code",
                "code": "anscombe = sns.load_dataset(\"anscombe\")\n"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"x\", y=\"y\", data=anscombe.query(\"dataset == 'I'\"),\n           ci=None, scatter_kws={\"s\": 80});\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The linear relationship in the second dataset is the same, but the plot clearly shows that this is not a good model:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"x\", y=\"y\", data=anscombe.query(\"dataset == 'II'\"),\n           ci=None, scatter_kws={\"s\": 80});\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In the presence of these kind of higher-order relationships,  and  can fit a polynomial regression model to explore simple kinds of nonlinear trends in the dataset:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"x\", y=\"y\", data=anscombe.query(\"dataset == 'II'\"),\n           order=2, ci=None, scatter_kws={\"s\": 80});\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A different problem is posed by \u201coutlier\u201d observations that deviate for some reason other than the main relationship under study:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"x\", y=\"y\", data=anscombe.query(\"dataset == 'III'\"),\n           ci=None, scatter_kws={\"s\": 80});\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In the presence of outliers, it can be useful to fit a robust regression, which uses a different loss function to downweight relatively large residuals:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"x\", y=\"y\", data=anscombe.query(\"dataset == 'III'\"),\n           robust=True, ci=None, scatter_kws={\"s\": 80});\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When the y variable is binary, simple linear regression also \u201cworks\u201d but provides implausible predictions:"
            },
            {
                "cell_type": "code",
                "code": "tips[\"big_tip\"] = (tips.tip / tips.total_bill) &gt; .15\nsns.lmplot(x=\"total_bill\", y=\"big_tip\", data=tips,\n           y_jitter=.03);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The solution in this case is to fit a logistic regression, such that the regression line shows the estimated probability of y = 1 for a given value of x:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"total_bill\", y=\"big_tip\", data=tips,\n           logistic=True, y_jitter=.03);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note that the logistic regression estimate is considerably more computationally intensive (this is true of robust regression as well). As the confidence interval around the regression line is computed using a bootstrap procedure, you may wish to turn this off for faster iteration (using ci=None)."
            },
            {
                "cell_type": "markdown",
                "nl_original": "An altogether different approach is to fit a nonparametric regression using a . This approach has the fewest assumptions, although it is computationally intensive and so currently confidence intervals are not computed at all:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"total_bill\", y=\"tip\", data=tips,\n           lowess=True, line_kws={\"color\": \"C1\"});\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  function can be a useful tool for checking whether the simple regression model is appropriate for a dataset. It fits and removes a simple linear regression and then plots the residual values for each observation. Ideally, these values should be randomly scattered around y = 0:"
            },
            {
                "cell_type": "code",
                "code": "sns.residplot(x=\"x\", y=\"y\", data=anscombe.query(\"dataset == 'I'\"),\n              scatter_kws={\"s\": 80});\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "If there is structure in the residuals, it suggests that simple linear regression is not appropriate:"
            },
            {
                "cell_type": "code",
                "code": "sns.residplot(x=\"x\", y=\"y\", data=anscombe.query(\"dataset == 'II'\"),\n              scatter_kws={\"s\": 80});\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Conditioning on other variables"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The plots above show many ways to explore the relationship between a pair of variables. Often, however, a more interesting question is \u201chow does the relationship between these two variables change as a function of a third variable?\u201d This is where the main differences between  and  appear. While  always shows a single relationship,  combines  with  to show multiple fits using hue mapping or faceting."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The best way to separate out a relationship is to plot both levels on the same axes and to use color to distinguish them:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"total_bill\", y=\"tip\", hue=\"smoker\", data=tips);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Unlike , it\u2019s not possible to map a distinct variable to the style properties of the scatter plot, but you can redundantly code the hue variable with marker shape:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"total_bill\", y=\"tip\", hue=\"smoker\", data=tips,\n           markers=[\"o\", \"x\"], palette=\"Set1\");\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "To add another variable, you can draw multiple \u201cfacets\u201d with each level of the variable appearing in the rows or columns of the grid:"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"total_bill\", y=\"tip\", hue=\"smoker\", col=\"time\", data=tips);\n"
            },
            {
                "cell_type": "code",
                "code": "sns.lmplot(x=\"total_bill\", y=\"tip\", hue=\"smoker\",\n           col=\"time\", row=\"sex\", data=tips, height=3);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Plotting a regression in other contexts"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A few other seaborn functions use  in the context of a larger, more complex plot. The first is the  function that we introduced in the . In addition to the plot styles previously discussed,  can use  to show the linear regression fit on the joint axes by passing kind=\"reg\":"
            },
            {
                "cell_type": "code",
                "code": "sns.jointplot(x=\"total_bill\", y=\"tip\", data=tips, kind=\"reg\");\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Using the  function with kind=\"reg\" combines  and  to show the linear relationship between variables in a dataset. Take care to note how this is different from . In the figure below, the two axes don\u2019t show the same relationship conditioned on two levels of a third variable; rather,  is used to show multiple relationships between different pairings of the variables in a dataset:"
            },
            {
                "cell_type": "code",
                "code": "sns.pairplot(tips, x_vars=[\"total_bill\", \"size\"], y_vars=[\"tip\"],\n             height=5, aspect=.8, kind=\"reg\");\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Conditioning on an additional categorical variable is built into both of these functions using the hue parameter:"
            },
            {
                "cell_type": "code",
                "code": "sns.pairplot(tips, x_vars=[\"total_bill\", \"size\"], y_vars=[\"tip\"],\n             hue=\"smoker\", height=5, aspect=.8, kind=\"reg\");\n"
            }
        ]
    },
    "Multi-plot grids": {
        "Plotting pairwise data relationships": [
            {
                "cell_type": "markdown",
                "nl_original": "# Building structured multi-plot grids"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When exploring multi-dimensional data, a useful approach is to draw multiple instances of the same plot on different subsets of your dataset. This technique is sometimes called either \u201clattice\u201d or \u201ctrellis\u201d plotting, and it is related to the idea of . It allows a viewer to quickly extract a large amount of information about a complex dataset. Matplotlib offers good support for making figures with multiple axes; seaborn builds on top of this to directly link the structure of the plot to the structure of your dataset."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  functions are built on top of the objects discussed in this chapter of the tutorial. In most cases, you will want to work with those functions. They take care of some important bookkeeping that synchronizes the multiple plots in each grid. This chapter explains how the underlying objects work, which may be useful for advanced applications."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Conditional small multiples"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  class is useful when you want to visualize the distribution of a variable or the relationship between multiple variables separately within subsets of your dataset. A  can be drawn with up to three dimensions: row, col, and hue. The first two have obvious correspondence with the resulting array of axes; think of the hue variable as a third dimension along a depth axis, where different levels are plotted with different colors."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Each of , , , and  use this object internally, and they return the object when they are finished so that it can be used for further tweaking."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The class is used by initializing a  object with a dataframe and the names of the variables that will form the row, column, or hue dimensions of the grid. These variables should be categorical or discrete, and then the data at each level of the variable will be used for a facet along that axis. For example, say we wanted to examine differences between lunch and dinner in the tips dataset:"
            },
            {
                "cell_type": "code",
                "code": "tips = sns.load_dataset(\"tips\")\ng = sns.FacetGrid(tips, col=\"time\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Initializing the grid like this sets up the matplotlib figure and axes, but doesn\u2019t draw anything on them."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The main approach for visualizing data on this grid is with the  method. Provide it with a plotting function and the name(s) of variable(s) in the dataframe to plot. Let\u2019s look at the distribution of tips in each of these subsets, using a histogram:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.FacetGrid(tips, col=\"time\")\ng.map(sns.histplot, \"tip\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This function will draw the figure and annotate the axes, hopefully producing a finished plot in one step. To make a relational plot, just pass multiple variable names. You can also provide keyword arguments, which will be passed to the plotting function:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.FacetGrid(tips, col=\"sex\", hue=\"smoker\")\ng.map(sns.scatterplot, \"total_bill\", \"tip\", alpha=.7)\ng.add_legend()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "There are several options for controlling the look of the grid that can be passed to the class constructor."
            },
            {
                "cell_type": "code",
                "code": "g = sns.FacetGrid(tips, row=\"smoker\", col=\"time\", margin_titles=True)\ng.map(sns.regplot, \"size\", \"total_bill\", color=\".3\", fit_reg=False, x_jitter=.1)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Note that margin_titles isn\u2019t formally supported by the matplotlib API, and may not work well in all cases. In particular, it currently can\u2019t be used with a legend that lies outside of the plot."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The size of the figure is set by providing the height of <em>each</em> facet, along with the aspect ratio:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.FacetGrid(tips, col=\"day\", height=4, aspect=.5)\ng.map(sns.barplot, \"sex\", \"total_bill\", order=[\"Male\", \"Female\"])\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The default ordering of the facets is derived from the information in the DataFrame. If the variable used to define facets has a categorical type, then the order of the categories is used. Otherwise, the facets will be in the order of appearance of the category levels. It is possible, however, to specify an ordering of any facet dimension with the appropriate *_order parameter:"
            },
            {
                "cell_type": "code",
                "code": "ordered_days = tips.day.value_counts().index\ng = sns.FacetGrid(tips, row=\"day\", row_order=ordered_days,\n                  height=1.7, aspect=4,)\ng.map(sns.kdeplot, \"total_bill\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Any seaborn color palette (i.e., something that can be passed to ) can be provided. You can also use a dictionary that maps the names of values in the hue variable to valid matplotlib colors:"
            },
            {
                "cell_type": "code",
                "code": "pal = dict(Lunch=\"seagreen\", Dinner=\".7\")\ng = sns.FacetGrid(tips, hue=\"time\", palette=pal, height=5)\ng.map(sns.scatterplot, \"total_bill\", \"tip\", s=100, alpha=.5)\ng.add_legend()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "If you have many levels of one variable, you can plot it along the columns but \u201cwrap\u201d them so that they span multiple rows. When doing this, you cannot use a row variable."
            },
            {
                "cell_type": "code",
                "code": "attend = sns.load_dataset(\"attention\").query(\"subject &lt;= 12\")\ng = sns.FacetGrid(attend, col=\"subject\", col_wrap=4, height=2, ylim=(0, 10))\ng.map(sns.pointplot, \"solutions\", \"score\", order=[1, 2, 3], color=\".3\", errorbar=None)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Once you\u2019ve drawn a plot using  (which can be called multiple times), you may want to adjust some aspects of the plot. There are also a number of methods on the  object for manipulating the figure at a higher level of abstraction. The most general is , and there are other more specialized methods like , which respects the fact that interior facets do not have axis labels. For example:"
            },
            {
                "cell_type": "code",
                "code": "with sns.axes_style(\"white\"):\n    g = sns.FacetGrid(tips, row=\"sex\", col=\"smoker\", margin_titles=True, height=2.5)\ng.map(sns.scatterplot, \"total_bill\", \"tip\", color=\"#334488\")\ng.set_axis_labels(\"Total bill (US Dollars)\", \"Tip\")\ng.set(xticks=[10, 30, 50], yticks=[2, 6, 10])\ng.figure.subplots_adjust(wspace=.02, hspace=.02)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "For even more customization, you can  work directly with the underling matplotlib Figure and Axes objects, which are stored as member attributes at figure and axes_dict, respectively. When making a figure without row or column faceting, you can also use the ax attribute to directly access the single axes."
            },
            {
                "cell_type": "code",
                "code": "g = sns.FacetGrid(tips, col=\"smoker\", margin_titles=True, height=4)\ng.map(plt.scatter, \"total_bill\", \"tip\", color=\"#338844\", edgecolor=\"white\", s=50, lw=1)\nfor ax in g.axes_dict.values():\n    ax.axline((0, 0), slope=.2, c=\".2\", ls=\"--\", zorder=0)\ng.set(xlim=(0, 60), ylim=(0, 14))\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Using custom functions"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You\u2019re not limited to existing matplotlib and seaborn functions when using . However, to work properly, any function you use must follow a few rules:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It must plot onto the \u201ccurrently active\u201d matplotlib Axes. This will be true of functions in the matplotlib.pyplot namespace, and you can call  to get a reference to the current Axes if you want to work directly with its methods."
            },
            {
                "cell_type": "markdown",
                "nl_original": "It must accept the data that it plots in positional arguments. Internally,  will pass a Series of data for each of the named positional arguments passed to ."
            },
            {
                "cell_type": "markdown",
                "nl_original": "It must be able to accept color and label keyword arguments, and, ideally, it will do something useful with them. In most cases, it\u2019s easiest to catch a generic dictionary of **kwargs and pass it along to the underlying plotting function."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Let\u2019s look at minimal example of a function you can plot with. This function will just take a single vector of data for each facet:"
            },
            {
                "cell_type": "code",
                "code": "from scipy import stats\ndef quantile_plot(x, **kwargs):\n    quantiles, xr = stats.probplot(x, fit=False)\n    plt.scatter(xr, quantiles, **kwargs)\n\ng = sns.FacetGrid(tips, col=\"sex\", height=4)\ng.map(quantile_plot, \"total_bill\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "If we want to make a bivariate plot, you should write the function so that it accepts the x-axis variable first and the y-axis variable second:"
            },
            {
                "cell_type": "code",
                "code": "def qqplot(x, y, **kwargs):\n    _, xr = stats.probplot(x, fit=False)\n    _, yr = stats.probplot(y, fit=False)\n    plt.scatter(xr, yr, **kwargs)\n\ng = sns.FacetGrid(tips, col=\"smoker\", height=4)\ng.map(qqplot, \"total_bill\", \"tip\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Because  accepts color and label keyword arguments and does the right thing with them, we can add a hue facet without any difficulty:"
            },
            {
                "cell_type": "code",
                "code": "g = sns.FacetGrid(tips, hue=\"time\", col=\"sex\", height=4)\ng.map(qqplot, \"total_bill\", \"tip\")\ng.add_legend()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Sometimes, though, you\u2019ll want to map a function that doesn\u2019t work the way you expect with the color and label keyword arguments. In this case, you\u2019ll want to explicitly catch them and handle them in the logic of your custom function. For example, this approach will allow use to map , which otherwise does not play well with the  API:"
            },
            {
                "cell_type": "code",
                "code": "def hexbin(x, y, color, **kwargs):\n    cmap = sns.light_palette(color, as_cmap=True)\n    plt.hexbin(x, y, gridsize=15, cmap=cmap, **kwargs)\n\nwith sns.axes_style(\"dark\"):\n    g = sns.FacetGrid(tips, hue=\"time\", col=\"time\", height=4)\ng.map(hexbin, \"total_bill\", \"tip\", extent=[0, 50, 0, 10]);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Plotting pairwise data relationships"
            },
            {
                "cell_type": "markdown",
                "nl_original": " also allows you to quickly draw a grid of small subplots using the same plot type to visualize data in each. In a , each row and column is assigned to a different variable, so the resulting plot shows each pairwise relationship in the dataset. This style of plot is sometimes called a \u201cscatterplot matrix\u201d, as this is the most common way to show each relationship, but  is not limited to scatterplots."
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s important to understand the differences between a  and a . In the former, each facet shows the same relationship conditioned on different levels of other variables. In the latter, each plot shows a different relationship (although the upper and lower triangles will have mirrored plots). Using  can give you a very quick, very high-level summary of interesting relationships in your dataset."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The basic usage of the class is very similar to . First you initialize the grid, then you pass plotting function to a map method and it will be called on each subplot. There is also a companion function,  that trades off some flexibility for faster plotting."
            },
            {
                "cell_type": "code",
                "code": "iris = sns.load_dataset(\"iris\")\ng = sns.PairGrid(iris)\ng.map(sns.scatterplot)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s possible to plot a different function on the diagonal to show the univariate distribution of the variable in each column. Note that the axis ticks won\u2019t correspond to the count or density axis of this plot, though."
            },
            {
                "cell_type": "code",
                "code": "g = sns.PairGrid(iris)\ng.map_diag(sns.histplot)\ng.map_offdiag(sns.scatterplot)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A very common way to use this plot colors the observations by a separate categorical variable. For example, the iris dataset has four measurements for each of three different species of iris flowers so you can see how they differ."
            },
            {
                "cell_type": "code",
                "code": "g = sns.PairGrid(iris, hue=\"species\")\ng.map_diag(sns.histplot)\ng.map_offdiag(sns.scatterplot)\ng.add_legend()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "By default every numeric column in the dataset is used, but you can focus on particular relationships if you want."
            },
            {
                "cell_type": "code",
                "code": "g = sns.PairGrid(iris, vars=[\"sepal_length\", \"sepal_width\"], hue=\"species\")\ng.map(sns.scatterplot)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s also possible to use a different function in the upper and lower triangles to emphasize different aspects of the relationship."
            },
            {
                "cell_type": "code",
                "code": "g = sns.PairGrid(iris)\ng.map_upper(sns.scatterplot)\ng.map_lower(sns.kdeplot)\ng.map_diag(sns.kdeplot, lw=3, legend=False)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The square grid with identity relationships on the diagonal is actually just a special case, and you can plot with different variables in the rows and columns."
            },
            {
                "cell_type": "code",
                "code": "g = sns.PairGrid(tips, y_vars=[\"tip\"], x_vars=[\"total_bill\", \"size\"], height=4)\ng.map(sns.regplot, color=\".3\")\ng.set(ylim=(-1, 11), yticks=[0, 5, 10])\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Of course, the aesthetic attributes are configurable. For instance, you can use a different palette (say, to show an ordering of the hue variable) and pass keyword arguments into the plotting functions."
            },
            {
                "cell_type": "code",
                "code": "g = sns.PairGrid(tips, hue=\"size\", palette=\"GnBu_d\")\ng.map(plt.scatter, s=50, edgecolor=\"white\")\ng.add_legend()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": " is flexible, but to take a quick look at a dataset, it can be easier to use . This function uses scatterplots and histograms by default, although a few other kinds will be added (currently, you can also plot regression plots on the off-diagonals and KDEs on the diagonal)."
            },
            {
                "cell_type": "code",
                "code": "sns.pairplot(iris, hue=\"species\", height=2.5)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can also control the aesthetics of the plot with keyword arguments, and it returns the  instance for further tweaking."
            },
            {
                "cell_type": "code",
                "code": "g = sns.pairplot(iris, hue=\"species\", palette=\"Set2\", diag_kind=\"kde\", height=2.5)\n"
            }
        ]
    },
    "Figure aesthetics": {
        "Scaling plot elements": [
            {
                "cell_type": "markdown",
                "nl_original": "# Controlling figure aesthetics"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Drawing attractive figures is important. When making figures for yourself, as you explore a dataset, it\u2019s nice to have plots that are pleasant to look at. Visualizations are also central to communicating quantitative insights to an audience, and in that setting it\u2019s even more necessary to have figures that catch the attention and draw a viewer in."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Matplotlib is highly customizable, but it can be hard to know what settings to tweak to achieve an attractive plot. Seaborn comes with a number of customized themes and a high-level interface for controlling the look of matplotlib figures."
            },
            {
                "cell_type": "code",
                "code": "import numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Let\u2019s define a simple function to plot some offset sine waves, which will help us see the different stylistic parameters we can tweak."
            },
            {
                "cell_type": "code",
                "code": "def sinplot(n=10, flip=1):\n    x = np.linspace(0, 14, 100)\n    for i in range(1, n + 1):\n        plt.plot(x, np.sin(x + i * .5) * (n + 2 - i) * flip)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This is what the plot looks like with matplotlib defaults:"
            },
            {
                "cell_type": "code",
                "code": "sinplot()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "To switch to seaborn defaults, simply call the  function."
            },
            {
                "cell_type": "code",
                "code": "sns.set_theme()\nsinplot()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "(Note that in versions of seaborn prior to 0.8,  was called on import. On later versions, it must be explicitly invoked)."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Seaborn splits matplotlib parameters into two independent groups. The first group sets the aesthetic style of the plot, and the second scales various elements of the figure so that it can be easily incorporated into different contexts."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The interface for manipulating these parameters are two pairs of functions. To control the style, use the  and  functions. To scale the plot, use the  and  functions. In both cases, the first function returns a dictionary of parameters and the second sets the matplotlib defaults."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Seaborn figure styles"
            },
            {
                "cell_type": "markdown",
                "nl_original": "There are five preset seaborn themes: darkgrid, whitegrid, dark, white, and ticks. They are each suited to different applications and personal preferences. The default theme is darkgrid. As mentioned above, the grid helps the plot serve as a lookup table for quantitative information, and the white-on grey helps to keep the grid from competing with lines that represent data. The whitegrid theme is similar, but it is better suited to plots with heavy data elements:"
            },
            {
                "cell_type": "code",
                "code": "sns.set_style(\"whitegrid\")\ndata = np.random.normal(size=(20, 6)) + np.arange(6) / 2\nsns.boxplot(data=data);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "For many plots, (especially for settings like talks, where you primarily want to use figures to provide impressions of patterns in the data), the grid is less necessary."
            },
            {
                "cell_type": "code",
                "code": "sns.set_style(\"dark\")\nsinplot()\n"
            },
            {
                "cell_type": "code",
                "code": "sns.set_style(\"white\")\nsinplot()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Sometimes you might want to give a little extra structure to the plots, which is where ticks come in handy:"
            },
            {
                "cell_type": "code",
                "code": "sns.set_style(\"ticks\")\nsinplot()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Removing axes spines"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Both the white and ticks styles can benefit from removing the top and right axes spines, which are not needed. The seaborn function  can be called to remove them:"
            },
            {
                "cell_type": "code",
                "code": "sinplot()\nsns.despine()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Some plots benefit from offsetting the spines away from the data, which can also be done when calling . When the ticks don\u2019t cover the whole range of the axis, the trim parameter will limit the range of the surviving spines."
            },
            {
                "cell_type": "code",
                "code": "f, ax = plt.subplots()\nsns.violinplot(data=data)\nsns.despine(offset=10, trim=True);\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can also control which spines are removed with additional arguments to :"
            },
            {
                "cell_type": "code",
                "code": "sns.set_style(\"whitegrid\")\nsns.boxplot(data=data, palette=\"deep\")\nsns.despine(left=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Temporarily setting figure style"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Although it\u2019s easy to switch back and forth, you can also use the  function in a with statement to temporarily set plot parameters. This also allows you to make figures with differently-styled axes:"
            },
            {
                "cell_type": "code",
                "code": "f = plt.figure(figsize=(6, 6))\ngs = f.add_gridspec(2, 2)\n\nwith sns.axes_style(\"darkgrid\"):\n    ax = f.add_subplot(gs[0, 0])\n    sinplot(6)\n\nwith sns.axes_style(\"white\"):\n    ax = f.add_subplot(gs[0, 1])\n    sinplot(6)\n\nwith sns.axes_style(\"ticks\"):\n    ax = f.add_subplot(gs[1, 0])\n    sinplot(6)\n\nwith sns.axes_style(\"whitegrid\"):\n    ax = f.add_subplot(gs[1, 1])\n    sinplot(6)\n\nf.tight_layout()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Overriding elements of the seaborn styles"
            },
            {
                "cell_type": "markdown",
                "nl_original": "If you want to customize the seaborn styles, you can pass a dictionary of parameters to the rc argument of  and . Note that you can only override the parameters that are part of the style definition through this method. (However, the higher-level  function takes a dictionary of any matplotlib parameters)."
            },
            {
                "cell_type": "markdown",
                "nl_original": "If you want to see what parameters are included, you can just call the function with no arguments, which will return the current settings:"
            },
            {
                "cell_type": "code",
                "code": "sns.axes_style()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can then set different versions of these parameters:"
            },
            {
                "cell_type": "code",
                "code": "sns.set_style(\"darkgrid\", {\"axes.facecolor\": \".9\"})\nsinplot()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Scaling plot elements"
            },
            {
                "cell_type": "markdown",
                "nl_original": "A separate set of parameters control the scale of plot elements, which should let you use the same code to make plots that are suited for use in settings where larger or smaller plots are appropriate."
            },
            {
                "cell_type": "markdown",
                "nl_original": "First let\u2019s reset the default parameters by calling :"
            },
            {
                "cell_type": "code",
                "code": "sns.set_theme()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The four preset contexts, in order of relative size, are paper, notebook, talk, and poster. The notebook style is the default, and was used in the plots above."
            },
            {
                "cell_type": "code",
                "code": "sns.set_context(\"paper\")\nsinplot()\n"
            },
            {
                "cell_type": "code",
                "code": "sns.set_context(\"talk\")\nsinplot()\n"
            },
            {
                "cell_type": "code",
                "code": "sns.set_context(\"poster\")\nsinplot()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Most of what you now know about the style functions should transfer to the context functions."
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can call  with one of these names to set the parameters, and you can override the parameters by providing a dictionary of parameter values."
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can also independently scale the size of the font elements when changing the context. (This option is also available through the top-level  function)."
            },
            {
                "cell_type": "code",
                "code": "sns.set_context(\"notebook\", font_scale=1.5, rc={\"lines.linewidth\": 2.5})\nsinplot()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Similarly, you can temporarily control the scale of figures nested under a with statement."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Both the style and the context can be quickly configured with the  function. This function also sets the default color palette, but that will be covered in more detail in the  of the tutorial."
            }
        ],
        "Diverging color palettes": [
            {
                "cell_type": "markdown",
                "nl_original": "# Choosing color palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Seaborn makes it easy to use colors that are well-suited to the characteristics of your data and your visualization goals. This chapter discusses both the general principles that should guide your choices and the tools in seaborn that help you quickly find the best solution for a given application."
            },
            {
                "cell_type": "markdown",
                "nl_original": "## General principles for using color in plots"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Components of color"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Because of the way our eyes work, a particular color can be defined using three components. We usually program colors in a computer by specifying their RGB values, which set the intensity of the red, green, and blue channels in a display. But for analyzing the perceptual attributes of a color, it\u2019s better to think in terms of <em>hue</em>, <em>saturation</em>, and <em>luminance</em> channels."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Hue is the component that distinguishes \u201cdifferent colors\u201d in a non-technical sense. It\u2019s property of color that leads to first-order names like \u201cred\u201d and \u201cblue\u201d:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Saturation (or chroma) is the <em>colorfulness</em>. Two colors with different hues will look more distinct when they have more saturation:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "And lightness corresponds to how much light is emitted (or reflected, for printed colors), ranging from black to white:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Vary hue to distinguish categories"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When you want to represent multiple categories in a plot, you typically should vary the color of the elements. Consider this simple example: in which of these two plots is it easier to count the number of triangular points?"
            },
            {
                "cell_type": "markdown",
                "nl_original": "In the plot on the right, the orange triangles \u201cpop out\u201d, making it easy to distinguish them from the circles. This pop-out effect happens because our visual system prioritizes color differences."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The blue and orange colors differ mostly in terms of their hue. Hue is useful for representing categories: most people can distinguish a moderate number of hues relatively easily, and points that have different hues but similar brightness or intensity seem equally important. It also makes plots easier to talk about. Consider this example:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Most people would be able to quickly ascertain that there are five distinct categories in the plot on the left and, if asked to characterize the \u201cblue\u201d points, would be able to do so."
            },
            {
                "cell_type": "markdown",
                "nl_original": "With the plot on the right, where the points are all blue but vary in their luminance and saturation, it\u2019s harder to say how many unique categories are present. And how would we talk about a particular category? \u201cThe fairly-but-not-too-blue points?\u201d What\u2019s more, the gray dots seem to fade into the background, de-emphasizing them relative to the more intense blue dots. If the categories are equally important, this is a poor representation."
            },
            {
                "cell_type": "markdown",
                "nl_original": "So as a general rule, use hue variation to represent categories. With that said, here are few notes of caution. If you have more than a handful of colors in your plot, it can become difficult to keep in mind what each one means, unless there are pre-existing associations between the categories and the colors used to represent them. This makes your plot harder to interpret: rather than focusing on the data, a viewer will have to continually refer to the legend to make sense of what is shown. So you should strive not to make plots that are too complex. And be mindful that not everyone sees colors the same way. Varying both shape (or some other attribute) and color can help people with anomalous color vision understand your plots, and it can keep them (somewhat) interpretable if they are printed to black-and-white."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Vary luminance to represent numbers"
            },
            {
                "cell_type": "markdown",
                "nl_original": "On the other hand, hue variations are not well suited to representing numeric data. Consider this example, where we need colors to represent the counts in a bivariate histogram. On the left, we use a circular colormap, where gradual changes in the number of observation within each bin correspond to gradual changes in hue. On the right, we use a palette that uses brighter colors to represent bins with larger counts:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "With the hue-based palette, it\u2019s quite difficult to ascertain the shape of the bivariate distribution. In contrast, the luminance palette makes it much more clear that there are two prominent peaks."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Varying luminance helps you see structure in data, and changes in luminance are more intuitively processed as changes in importance. But the plot on the right does not use a grayscale colormap. Its colorfulness makes it more interesting, and the subtle hue variation increases the perceptual distance between two values. As a result, small differences slightly easier to resolve."
            },
            {
                "cell_type": "markdown",
                "nl_original": "These examples show that color palette choices are about more than aesthetics: the colors you choose can reveal patterns in your data if used effectively or hide them if used poorly. There is not one optimal palette, but there are palettes that are better or worse for particular datasets and visualization approaches."
            },
            {
                "cell_type": "markdown",
                "nl_original": "And aesthetics do matter: the more that people want to look at your figures, the greater the chance that they will learn something from them. This is true even when you are making plots for yourself. During exploratory data analysis, you may generate many similar figures. Varying the color palettes will add a sense of novelty, which keeps you engaged and prepared to notice interesting features of your data."
            },
            {
                "cell_type": "markdown",
                "nl_original": "So how can you choose color palettes that both represent your data well and look attractive?"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Tools for choosing color palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The most important function for working with color palettes is, aptly, . This function provides an interface to most of the possible ways that one can generate color palettes in seaborn. And it\u2019s used internally by any function that has a palette argument."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The primary argument to  is usually a string: either the name of a specific palette or the name of a family and additional arguments to select a specific member. In the latter case,  will delegate to more specific function, such as . It\u2019s also possible to pass a list of colors specified any way that matplotlib accepts (an RGB tuple, a hex code, or a name in the X11 table). The return value is an object that wraps a list of RGB tuples with a few useful methods, such as conversion to hex codes and a rich HTML representation."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Calling  with no arguments will return the current default color palette that matplotlib (and most seaborn functions) will use if colors are not otherwise specified. This default palette can be set with the corresponding  function, which calls  internally and accepts the same arguments."
            },
            {
                "cell_type": "markdown",
                "nl_original": "To motivate the different options that  provides, it will be useful to introduce a classification scheme for color palettes. Broadly, palettes fall into one of three categories:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "qualitative palettes, good for representing categorical data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "sequential palettes, good for representing numeric data"
            },
            {
                "cell_type": "markdown",
                "nl_original": "diverging palettes, good for representing numeric data with a categorical boundary"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Qualitative color palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Qualitative palettes are well-suited to representing categorical data because most of their variation is in the hue component. The default color palette in seaborn is a qualitative palette with ten distinct hues:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette()\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "These colors have the same ordering as the default matplotlib color palette, \"tab10\", but they are a bit less intense. Compare:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"tab10\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Seaborn in fact has six variations of matplotlib\u2019s palette, called deep, muted, pastel, bright, dark, and colorblind. These span a range of average luminance and saturation values:"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Many people find the moderated hues of the default \"deep\" palette to be aesthetically pleasing, but they are also less distinct. As a result, they may be more difficult to discriminate in some contexts, which is something to keep in mind when making publication graphics.  can be helpful for estimating how the seaborn color palettes perform when simulating different forms of colorblindess."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Using circular color systems"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When you have an arbitrary number of categories, the easiest approach to finding unique hues is to draw evenly-spaced colors in a circular color space (one where the hue changes while keeping the brightness and saturation constant). This is what most seaborn functions default to when they need to use more colors than are currently set in the default color cycle."
            },
            {
                "cell_type": "markdown",
                "nl_original": "The most common way to do this uses the hls color space, which is a simple transformation of RGB values. We saw this color palette before as a counterexample for how to plot a histogram:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"hls\", 8)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Because of the way the human visual system works, colors that have the same luminance and saturation in terms of their RGB values won\u2019t necessarily look equally intense To remedy this, seaborn provides an interface to the  system (since renamed to HSLuv), which achieves less intensity variation as you rotate around the color wheel:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"husl\", 8)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "When seaborn needs a categorical palette with more colors than are available in the current default, it will use this approach."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Using categorical Color Brewer palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Another source of visually pleasing categorical palettes comes from the  tool (which also has sequential and diverging palettes, as we\u2019ll see below)."
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"Set2\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Be aware that the qualitative Color Brewer palettes have different lengths, and the default behavior of  is to give you the full list:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"Paired\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Sequential color palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The second major class of color palettes is called \u201csequential\u201d. This kind of mapping is appropriate when data range from relatively low or uninteresting values to relatively high or interesting values (or vice versa). As we saw above, the primary dimension of variation in a sequential palette is luminance. Some seaborn functions will default to a sequential palette when you are mapping numeric data. (For historical reasons, both categorical and numeric mappings are specified with the hue parameter in functions like  or , even though numeric mappings use color palettes with relatively little hue variation)."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Perceptually uniform palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Because they are intended to represent numeric values, the best sequential palettes will be <em>perceptually uniform</em>, meaning that the relative discriminability of two colors is proportional to the difference between the corresponding data values. Seaborn includes four perceptually uniform sequential colormaps: \"rocket\", \"mako\", \"flare\", and \"crest\". The first two have a very wide luminance range and are well suited for applications such as heatmaps, where colors fill the space they are plotted into:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"rocket\", as_cmap=True)\n"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"mako\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Because the extreme values of these colormaps approach white, they are not well-suited for coloring elements such as lines or points: it will be difficult to discriminate important values against a white or gray background. The \u201cflare\u201d and \u201ccrest\u201d colormaps are a better choice for such plots. They have a more restricted range of luminance variations, which they compensate for with a slightly more pronounced variation in hue. The default direction of the luminance ramp is also reversed, so that smaller values have lighter colors:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"flare\", as_cmap=True)\n"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"crest\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It is also possible to use the perceptually uniform colormaps provided by matplotlib, such as \"magma\" and \"viridis\":"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"magma\", as_cmap=True)\n"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"viridis\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As with the convention in matplotlib, every continuous colormap has a reversed version, which has the suffix \"_r\":"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"rocket_r\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Discrete vs. continuous mapping"
            },
            {
                "cell_type": "markdown",
                "nl_original": "One thing to be aware of is that seaborn can generate discrete values from sequential colormaps and, when doing so, it will not use the most extreme values. Compare the discrete version of \"rocket\" against the continuous version shown above:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"rocket\")\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Internally, seaborn uses the discrete version for categorical data and the continuous version when in numeric mapping mode. Discrete sequential colormaps can be well-suited for visualizing categorical data with an intrinsic ordering, especially if there is some hue variation."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Sequential \u201ccubehelix\u201d palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The perceptually uniform colormaps are difficult to programmatically generate, because they are not based on the RGB color space. The  system offers an RGB-based compromise: it generates sequential palettes with a linear increase or decrease in brightness and some continuous variation in hue. While not perfectly perceptually uniform, the resulting colormaps have many good properties. Importantly, many aspects of the design process are parameterizable."
            },
            {
                "cell_type": "markdown",
                "nl_original": "Matplotlib has the default cubehelix version built into it:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"cubehelix\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The default palette returned by the seaborn  function is a bit different from the matplotlib default in that it does not rotate as far around the hue wheel or cover as wide a range of intensities. It also reverses the luminance ramp:"
            },
            {
                "cell_type": "code",
                "code": "sns.cubehelix_palette(as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Other arguments to  control how the palette looks. The two main things you\u2019ll change are the start (a value between 0 and 3) and rot, or number of rotations (an arbitrary value, but usually between -1 and 1)"
            },
            {
                "cell_type": "code",
                "code": "sns.cubehelix_palette(start=.5, rot=-.5, as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The more you rotate, the more hue variation you will see:"
            },
            {
                "cell_type": "code",
                "code": "sns.cubehelix_palette(start=.5, rot=-.75, as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can control both how dark and light the endpoints are and their order:"
            },
            {
                "cell_type": "code",
                "code": "sns.cubehelix_palette(start=2, rot=0, dark=0, light=.95, reverse=True, as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The  accepts a string code, starting with \"ch:\", for generating an arbitrary cubehelix palette. You can passs the names of parameters in the string:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"ch:start=.2,rot=-.3\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "And for compactness, each parameter can be specified with its first letter:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"ch:s=-.2,r=.6\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Custom sequential palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "For a simpler interface to custom sequential palettes, you can use  or , which are both seeded with a single color and produce a palette that ramps either from light or dark desaturated values to that color:"
            },
            {
                "cell_type": "code",
                "code": "sns.light_palette(\"seagreen\", as_cmap=True)\n"
            },
            {
                "cell_type": "code",
                "code": "sns.dark_palette(\"#69d\", reverse=True, as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As with cubehelix palettes, you can also specify light or dark palettes through  or anywhere palette is accepted:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"light:b\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Reverse the colormap by adding \"_r\":"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"dark:salmon_r\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Sequential Color Brewer palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The Color Brewer library also has some good options for sequential palettes. They include palettes with one primary hue:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"Blues\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Along with multi-hue options:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"YlOrBr\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "## Diverging color palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "The third class of color palettes is called \u201cdiverging\u201d. These are used for data where both large low and high values are interesting and span a midpoint value (often 0) that should be demphasized. The rules for choosing good diverging palettes are similar to good sequential palettes, except now there should be two dominant hues in the colormap, one at (or near) each pole. It\u2019s also important that the starting values are of similar brightness and saturation."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Perceptually uniform diverging palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "Seaborn includes two perceptually uniform diverging palettes: \"vlag\" and \"icefire\". They both use blue and red at their poles, which many intuitively processes as \u201ccold\u201d and \u201chot\u201d:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"vlag\", as_cmap=True)\n"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"icefire\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Custom diverging palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "You can also use the seaborn function  to create a custom colormap for diverging data. This function makes diverging palettes using the husl color system. You pass it two hues (in degrees) and, optionally, the lightness and saturation values for the extremes. Using husl means that the extreme values, and the resulting ramps to the midpoint, while not perfectly perceptually uniform, will be well-balanced:"
            },
            {
                "cell_type": "code",
                "code": "sns.diverging_palette(220, 20, as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "This is convenient when you want to stray from the boring confines of cold-hot approaches:"
            },
            {
                "cell_type": "code",
                "code": "sns.diverging_palette(145, 300, s=60, as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s also possible to make a palette where the midpoint is dark rather than light:"
            },
            {
                "cell_type": "code",
                "code": "sns.diverging_palette(250, 30, l=65, center=\"dark\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "It\u2019s important to emphasize here that using red and green, while intuitive, ."
            },
            {
                "cell_type": "markdown",
                "nl_original": "### Other diverging palettes"
            },
            {
                "cell_type": "markdown",
                "nl_original": "There are a few other good diverging palettes built into matplotlib, including Color Brewer palettes:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"Spectral\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "And the coolwarm palette, which has less contrast between the middle values and the extremes:"
            },
            {
                "cell_type": "code",
                "code": "sns.color_palette(\"coolwarm\", as_cmap=True)\n"
            },
            {
                "cell_type": "markdown",
                "nl_original": "As you can see, there are many options for using color in your visualizations. Seaborn tries both to use good defaults and to offer a lot of flexibility."
            },
            {
                "cell_type": "markdown",
                "nl_original": "This discussion is only the beginning, and there are a number of good resources for learning more about techniques for using color in visualizations. One great example is this  from the NASA Earth Observatory. The matplotlib docs also have a  that illustrates some of the perceptual properties of their colormaps."
            }
        ]
    }
}