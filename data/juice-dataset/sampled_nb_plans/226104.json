[
    {
        "id": 0,
        "type": "code",
        "plan": {
            "fill na values in train": "train.fillna(0, inplace=True)"
        },
        "concept": "data imputation"
    },
    {
        "id": 1,
        "type": "markdown",
        "plan": "explain collaborative filtering and show equations",
        "concept": "collaborative filtering"
    },
    {
        "id": 2,
        "type": "code",
        "plan": {
            "implement collaborative filtering given R (ratings matrix), d, lda and threshold": "def collaborative_filtering(R, d, lda, threshold):",
            "intialize binary matrix W for rating or not": "W = (R != 0).astype(np.float64)",
            "intialize mean squared error (MSE)": "MSE1 = float(\"inf\")",
            "randomly initialize latent factor matrices for jokes and users": "jokes = np.random.normal(0, 1, (d, R.shape[1]))\nusers = np.random.normal(0, 1, (R.shape[0], d))",
            "": "S_idx = np.where(R.values != 0)",
            "predict ratings from user and joke latent matrices": "predicted_ratings = users.dot(jokes)",
            "compute MSE loss for the iteration": "MSE2 = np.mean((predicted_ratings[S_idx] - R.values[S_idx])**2)",
            "check if MSE loss decreased by threshold": "while MSE1 - MSE2 > threshold:",
            "update MSE loss": "MSE1 = MSE2"
        },
        "concept": "collaborative filtering"
    },
    {
        "id": 3,
        "type": "markdown",
        "plan": "train on historical data",
        "concept": "training"
    },
    {
        "id": 4,
        "run collaborative filtering on train data": "users, jokes = collaborative_filtering(train, d, lda, 0.1)",
        "concept": "training"
    }
]